"""
VisualizePath - Visualization Module for Neural Pathways

This module provides standalone visualization capabilities for neural pathways
discovered through connectome analysis. It can be used independently or 
integrated with FindNeuronConnection.

Classes:
    VisualizePath: Main class for pathway visualization

Author: Kun-Da Wu
Date: 2025-10-27
"""

import pandas as pd
import numpy as np
import networkx as nx
import os
import json
import webbrowser
from pathlib import Path
import ast
import re


def parse_color_to_hex_opacity(color_str):
    """
    Parse a color string (hex, rgb, rgba, named) into hex color and opacity.
    
    Parameters
    ----------
    color_str : str
        Color in any CSS format: '#3498db', 'rgb(52, 152, 219)', 
        'rgba(52, 152, 219, 0.5)', 'blue', etc.
    
    Returns
    -------
    tuple
        (hex_color: str, opacity: float) e.g., ('#3498db', 1.0)
    
    Examples
    --------
    >>> parse_color_to_hex_opacity('rgba(44, 160, 44, 0.2)')
    ('#2ca02c', 0.2)
    >>> parse_color_to_hex_opacity('#1f77b4')
    ('#1f77b4', 1.0)
    """
    if not color_str:
        return ('#000000', 1.0)
    
    color_str = color_str.strip()
    
    # Parse rgba(r, g, b, a) or rgb(r, g, b)
    rgba_match = re.match(r'rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+))?\s*\)', color_str)
    if rgba_match:
        r = int(rgba_match.group(1))
        g = int(rgba_match.group(2))
        b = int(rgba_match.group(3))
        a = float(rgba_match.group(4)) if rgba_match.group(4) else 1.0
        hex_color = '#{:02x}{:02x}{:02x}'.format(r, g, b)
        return (hex_color, a)
    
    # Parse hex color #RRGGBB or #RGB
    if color_str.startswith('#'):
        hex_color = color_str
        # Expand #RGB to #RRGGBB
        if len(hex_color) == 4:
            hex_color = '#' + ''.join([c*2 for c in hex_color[1:]])
        return (hex_color, 1.0)
    
    # Named colors (basic support)
    named_colors = {
        'red': '#ff0000', 'green': '#00ff00', 'blue': '#0000ff',
        'white': '#ffffff', 'black': '#000000', 'gray': '#808080', 'grey': '#808080',
        'yellow': '#ffff00', 'cyan': '#00ffff', 'magenta': '#ff00ff',
        'orange': '#ffa500', 'purple': '#800080', 'pink': '#ffc0cb',
        'brown': '#a52a2a', 'navy': '#000080', 'teal': '#008080'
    }
    if color_str.lower() in named_colors:
        return (named_colors[color_str.lower()], 1.0)
    
    # Default fallback
    return (color_str, 1.0)


class VisualizePath:
    """
    A class for visualizing neural pathways from CSV/Excel files.
    
    This class provides methods to create interactive visualizations (Sankey diagrams
    and network graphs) from pathway data, typically generated by FindNeuronConnection.FindAllPath().
    
    Attributes:
        path_file (str or pd.DataFrame): Path to CSV/Excel file or DataFrame with pathway data
        sheet_name (str): Excel sheet name to read (default: auto-detect)
        output_folder (str): Folder to save visualization outputs
        source_color (str): Color for source nodes
        intermediate_color (str): Color for intermediate nodes
        target_color (str): Color for target nodes
        link_color (str): Color for connections in Sankey
        network_layout (str): Layout algorithm for network graph
        showfig (bool): Whether to automatically open visualizations in browser
        
    Example:
        >>> # Standalone usage
        >>> vp = VisualizePath(path_file='path_type.xlsx')
        >>> vp.visualize()
        
        >>> # With custom colors
        >>> vp = VisualizePath(
        ...     path_file='selected_paths.csv',
        ...     source_color='#FF6B6B',
        ...     intermediate_color='#FFA500',
        ...     target_color='#FFD700',
        ...     output_folder='./my_viz',
        ...     network_layout='spring',
        ...     showfig=True
        ... )
        >>> conn_df, G = vp.visualize()
    """
    
    def __init__(
        self,
        path_file,
        sheet_name=None,
        output_folder=None,
        source_color=None,
        intermediate_color=None,
        target_color=None,
        link_color=None,
        node_color=None,  # For backward compatibility
        node_colors=None,  # NEW: Custom node colors
        network_layout='hierarchical',
        showfig=False,
        edge_width_scale='log',  # NEW: Edge width scaling method
        edge_width_factor=1.0,   # NEW: Edge width multiplier
        edge_width_log_base=None, # NEW: Log base for logarithmic scaling (None = natural log e)
        min_edge_width=0.5,      # NEW: Minimum edge width in pixels
        max_edge_width=30,       # NEW: Maximum edge width in pixels
        min_font_size=6,         # NEW: Minimum font size in pixels
        max_font_size=48,        # NEW: Maximum font size in pixels
        min_node_size=20,        # NEW: Minimum node size in pixels
        max_node_size=80,        # NEW: Maximum node size in pixels
        heatmap_row_order=None,  # NEW: Custom row order for heatmap
        heatmap_col_order=None,  # NEW: Custom column order for heatmap
        generate_empty_network=False  # NEW: Generate empty network HTML template
    ):
        """
        Initialize VisualizePath with pathway data and visualization settings.
        
        Parameters
        ----------
        path_file : str or pd.DataFrame
            Path to CSV/Excel file or DataFrame containing pathway data.
            Required columns: 'path_block', 'weights'
            Optional columns: 'connection_ratios', 'traversal_probabilities'
            
        sheet_name : str, optional
            Excel sheet name to read. If None, auto-detects 'path_type' or 'path_bodyId'.
            Ignored for CSV files and DataFrames.
            
        output_folder : str, optional
            Directory to save visualization files. If None, creates '[filename]_figure'
            relative to the input file location (for files) or './selected_paths' (for DataFrames).
            Example: 'L3_to_MeVPMe_allpaths_info.xlsx' ‚Üí 'L3_to_MeVPMe_allpaths_info_figure/'
            
        source_color : str, optional
            Color for source nodes.
            Default: '#1f77b4' (blue)
            Format: Any valid CSS color (hex, rgb, rgba, named)
            
        intermediate_color : str, optional
            Color for intermediate nodes.
            Default: '#2ca02c' (green)
            Format: Any valid CSS color (hex, rgb, rgba, named)
            
        target_color : str, optional
            Color for target nodes.
            Default: '#d62728' (red)
            
        link_color : str, optional
            Color for connections in Sankey diagram.
            Default: 'rgba(100,100,100,0.3)' (semi-transparent gray)
            
        node_color : list of str, optional
            [DEPRECATED] Colors for [source_nodes, intermediate_nodes].
            Use source_color and intermediate_color instead.
            Kept for backward compatibility.
            
        node_colors : str or pd.DataFrame, optional
            Custom colors for specific nodes. Can be:
            - Sheet name (str): Name of sheet in Excel file with 'node' and 'color' columns
            - File path (str): Path to CSV/Excel file with 'node' and 'color' columns
            - DataFrame: DataFrame with 'node' and 'color' columns
            Color column supports hex (#RRGGBB) and rgba (rgba(r,g,b,a)) formats.
            Nodes not specified will use default source/intermediate/target colors.
            
        network_layout : str, optional
            Layout algorithm for network graph.
            Options: 'hierarchical', 'spring', 'circular', 'distributed'
            Default: 'hierarchical'
            
        showfig : bool, optional
            Whether to automatically open visualizations in web browser.
            Default: False
            
        edge_width_scale : str, optional
            Edge width scaling method for network graph visualization.
            Options: 'linear', 'log', 'sqrt', 'none'
            - 'linear': Direct proportional scaling (width ‚àù weight)
            - 'log': Logarithmic scaling (width ‚àù log(weight)) - DEFAULT
            - 'sqrt': Square root scaling (width ‚àù ‚àöweight)
            - 'none': No scaling (constant width)
            Default: 'log'
            Note: For Sankey diagrams, Plotly auto-scales link widths proportionally.
            
        edge_width_factor : float, optional
            Multiplier for edge widths in network graph (applies after scaling).
            Larger values make edges thicker. Default: 1.0
            
        edge_width_log_base : float, optional
            Base for logarithmic scaling when edge_width_scale='log'.
            - None: Natural logarithm (base e ‚âà 2.718) - DEFAULT
            - 2: Binary logarithm (log‚ÇÇ)
            - 10: Common logarithm (log‚ÇÅ‚ÇÄ)
            - Any positive number > 1: Custom base
            Only used when edge_width_scale='log'. Ignored for other scaling methods.
            Default: None (natural log)
            
        min_edge_width : float, optional
            Minimum edge width in pixels for network visualization.
            This is a fixed lower bound - the slider controls max width.
            Default: 0.5
            
        max_edge_width : float, optional
            Maximum edge width in pixels for network visualization.
            This value is controlled by the "Edge Width" slider in the UI.
            Default: 30
            
        min_font_size : int, optional
            Minimum font size in pixels for node labels.
            This is the minimum value for the "Font Size" slider.
            Default: 6
            
        max_font_size : int, optional
            Maximum font size in pixels for node labels.
            This is the maximum value for the "Font Size" slider.
            Default: 48
            
        min_node_size : int, optional
            Minimum node size in pixels.
            This is the minimum value for the "Node Size" slider.
            Default: 20
            
        max_node_size : int, optional
            Maximum node size in pixels.
            This is the maximum value for the "Node Size" slider.
            Default: 80
            
        heatmap_row_order : list of str, optional
            Custom order for heatmap row nodes (sources).
            If None, uses default sorted order.
            Nodes not in the list will be appended at the end (sorted).
            Example: ['PN_A', 'PN_B', 'LHN_X', 'LHN_Y']
            Default: None
            
        heatmap_col_order : list of str, optional
            Custom order for heatmap column nodes (targets).
            If None, uses default sorted order.
            Nodes not in the list will be appended at the end (sorted).
            Example: ['LHN_X', 'MBON_1', 'MBON_2']
            Default: None
            
        generate_empty_network : bool, optional
            If True, generates an empty network HTML template without requiring
            path_file data. Useful for creating blank network visualizations that
            can be populated later or used as templates.
            When enabled, path_file can be None.
            Default: False
            
        Raises
        ------
        FileNotFoundError
            If path_file is a string and the file doesn't exist
        ValueError
            If required columns are missing from the data
        """
        self.path_file = path_file
        self.sheet_name = sheet_name
        self.output_folder = output_folder
        
        # Edge width scaling parameters
        self.edge_width_scale = edge_width_scale
        self.edge_width_factor = edge_width_factor
        self.edge_width_log_base = edge_width_log_base if edge_width_log_base is not None else 'e'  # Default to natural log
        self.min_edge_width = min_edge_width  # Minimum edge width in pixels (fixed lower bound)
        self.max_edge_width = max_edge_width  # Maximum edge width in pixels (controlled by slider)
        
        # Font and node size parameters
        self.min_font_size = min_font_size  # Minimum font size in pixels
        self.max_font_size = max_font_size  # Maximum font size in pixels
        self.min_node_size = min_node_size  # Minimum node size in pixels
        self.max_node_size = max_node_size  # Maximum node size in pixels
        
        # Heatmap ordering parameters
        self.heatmap_row_order = heatmap_row_order  # Custom row order for heatmap
        self.heatmap_col_order = heatmap_col_order  # Custom column order for heatmap
        
        # Empty network generation flag
        self.generate_empty_network = generate_empty_network
        
        # Handle color parameters - support both new (source_color, intermediate_color)
        # and old (node_color) API for backward compatibility
        # Parse colors to separate hex and opacity
        if source_color is not None or intermediate_color is not None:
            # New API: individual colors
            source_hex, source_opacity = parse_color_to_hex_opacity(source_color or '#1f77b4')
            intermediate_hex, intermediate_opacity = parse_color_to_hex_opacity(intermediate_color or '#2ca02c')
            self.source_color = source_hex
            self.source_opacity = source_opacity
            self.intermediate_color = intermediate_hex
            self.intermediate_opacity = intermediate_opacity
        elif node_color is not None:
            # Old API: node_color array for backward compatibility
            if isinstance(node_color, list) and len(node_color) >= 2:
                source_hex, source_opacity = parse_color_to_hex_opacity(node_color[0])
                intermediate_hex, intermediate_opacity = parse_color_to_hex_opacity(node_color[1])
                self.source_color = source_hex
                self.source_opacity = source_opacity
                self.intermediate_color = intermediate_hex
                self.intermediate_opacity = intermediate_opacity
            else:
                self.source_color = '#1f77b4'
                self.source_opacity = 1.0
                self.intermediate_color = '#2ca02c'
                self.intermediate_opacity = 1.0
        else:
            # Defaults
            self.source_color = '#1f77b4'  # Blue
            self.source_opacity = 1.0
            self.intermediate_color = '#2ca02c'  # Green
            self.intermediate_opacity = 1.0
        
        # Parse target color
        target_hex, target_opacity = parse_color_to_hex_opacity(target_color or '#d62728')
        self.target_color = target_hex
        self.target_opacity = target_opacity
        
        # Parse link/edge color - extract hex and opacity for network edges
        link_hex, link_opacity = parse_color_to_hex_opacity(link_color or 'rgba(100,100,100,0.3)')
        self.link_color = link_color or 'rgba(100,100,100,0.3)'  # Keep original for Sankey
        self.edge_color = link_hex  # Hex color for network edges
        self.edge_opacity = link_opacity  # Opacity for network edges
        
        # Create node_color array for compatibility with internal methods
        self.node_color = [self.source_color, self.intermediate_color]
        
        # Store custom node colors (will be loaded later)
        self.node_colors_input = node_colors
        self.custom_node_colors = None  # Will be populated in _load_custom_colors()
        self.custom_edge_colors = None  # Will be populated if edge-list has color column
        
        self.network_layout = network_layout
        self.showfig = showfig
        
        # Data storage
        self.path_df = None
        self.conn_df = None
        self.G_network = None
        
        # Skip data loading for empty network generation
        if self.generate_empty_network:
            # Generate unique filename with timestamp
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # Set default output folder and filename for empty network
            if self.output_folder is None:
                self.output_folder = './empty_network'
                self.base_filename = f'empty_network_{timestamp}'
            else:
                # Use folder name + timestamp for uniqueness
                folder_name = os.path.basename(self.output_folder.rstrip(os.sep))
                self.base_filename = f'{folder_name}_{timestamp}'
            os.makedirs(self.output_folder, exist_ok=True)
            return
        
        # Load and validate data
        self._load_data()
        self._validate_data()
        
        # Load custom colors if provided
        if self.node_colors_input is not None:
            self._load_custom_colors()
        
    def _load_data(self):
        """Load pathway data from file or DataFrame."""
        if isinstance(self.path_file, pd.DataFrame):
            self.path_df = self.path_file.copy()
            # Set default output folder for DataFrame input
            if self.output_folder is None:
                self.output_folder = './selected_paths'
                self.base_filename = 'selected_paths'
            else:
                self.base_filename = os.path.basename(self.output_folder.rstrip(os.sep))
        else:
            # Track if file picker was used (affects sheet selection behavior)
            file_picker_used = False
            
            # Check if file exists, if not or if path_file is None/empty, prompt user to select
            if self.path_file is None or self.path_file == '' or not os.path.exists(self.path_file):
                if self.path_file and not os.path.exists(self.path_file):
                    print(f"‚ö†Ô∏è Path file not found: {self.path_file}")
                print("Please select a path file...")
                self.path_file = self._select_file()
                if self.path_file is None:
                    raise ValueError("No file selected. Cannot proceed without pathway data.")
                file_picker_used = True
            
            file_ext = Path(self.path_file).suffix.lower()
            
            if file_ext == '.csv':
                print(f"Loading CSV file: {self.path_file}")
                self.path_df = pd.read_csv(self.path_file)
                # For CSV files, ignore sheet_name parameter
                if self.sheet_name:
                    print(f"  Note: sheet_name '{self.sheet_name}' ignored for CSV files")
                    
            elif file_ext in ['.xlsx', '.xls']:
                print(f"Loading Excel file: {self.path_file}")
                excel_file = pd.ExcelFile(self.path_file)
                
                # If file picker was used, always ask user to confirm/select sheet
                # Otherwise, auto-select if sheet_name is None
                if file_picker_used:
                    # File picker was used - always ask for confirmation
                    self.sheet_name = self._select_sheet(excel_file, auto_confirm=True)
                    if self.sheet_name is None:
                        raise ValueError("No sheet selected. Cannot proceed without sheet selection.")
                elif self.sheet_name is None:
                    # File path provided but no sheet_name - auto-select quietly
                    self.sheet_name = self._select_sheet(excel_file, auto_confirm=False)
                    if self.sheet_name is None:
                        raise ValueError("No sheet selected. Cannot proceed without sheet selection.")
                # else: sheet_name was explicitly provided, use it
                
                self.path_df = pd.read_excel(self.path_file, sheet_name=self.sheet_name)
                print(f"  Loaded sheet: '{self.sheet_name}'")
                
            else:
                raise ValueError(f"Unsupported file format: {file_ext}. Use .csv, .xlsx, or .xls")
            
            # Set default output folder relative to input file
            if self.output_folder is None:
                input_dir = os.path.dirname(os.path.abspath(self.path_file))
                input_filename = os.path.splitext(os.path.basename(self.path_file))[0]
                self.output_folder = os.path.join(input_dir, input_filename + '_figure')
                self.base_filename = input_filename  # Store for output file naming
            else:
                # If custom output_folder provided, extract folder name as base
                self.base_filename = os.path.basename(self.output_folder.rstrip(os.sep))
        
        # Create output folder
        os.makedirs(self.output_folder, exist_ok=True)
    
    def _select_file(self):
        """
        Interactive file selection dialog with cross-platform support.
        Uses the fastest available GUI backend (PyQt5 > wxPython > tkinter).
        
        Returns
        -------
        str or None
            Path to selected file, or None if cancelled
            
        Notes
        -----
        - Tries PyQt5 first (fastest, most native)
        - Falls back to wxPython (fast alternative)
        - Falls back to tkinter (slower, but always available)
        - Works on Windows, macOS, and Linux
        """
        # Try PyQt5 first (fastest and most native-looking)
        try:
            from PyQt5.QtWidgets import QApplication, QFileDialog
            import sys
            
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            print("Please select a path file...")
            
            file_path, _ = QFileDialog.getOpenFileName(
                None,
                "Select Pathway Data File",
                os.getcwd(),
                "Excel files (*.xlsx *.xls);;CSV files (*.csv);;All files (*.*)"
            )
            
            # Process events to ensure clean exit
            app.processEvents()
            
            if file_path:
                file_path = os.path.normpath(file_path)
                print(f"‚úì Selected file: {file_path}")
                return file_path
            else:
                print("‚úó No file selected")
                return None
                
        except ImportError:
            pass
        
        # Try PyQt6 (similar to PyQt5)
        try:
            from PyQt6.QtWidgets import QApplication, QFileDialog  # type: ignore
            import sys
            
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            print("Please select a path file...")
            
            file_path, _ = QFileDialog.getOpenFileName(
                None,
                "Select Pathway Data File",
                os.getcwd(),
                "Excel files (*.xlsx *.xls);;CSV files (*.csv);;All files (*.*)"
            )
            
            app.processEvents()
            
            if file_path:
                file_path = os.path.normpath(file_path)
                print(f"‚úì Selected file: {file_path}")
                return file_path
            else:
                print("‚úó No file selected")
                return None
                
        except ImportError:
            pass
        
        # Try wxPython (good performance, native look)
        try:
            import wx  # type: ignore
            
            app = wx.App(False)
            
            wildcard = "Excel files (*.xlsx;*.xls)|*.xlsx;*.xls|CSV files (*.csv)|*.csv|All files (*.*)|*.*"
            
            print("Please select a path file...")
            
            dialog = wx.FileDialog(
                None,
                "Select Pathway Data File",
                defaultDir=os.getcwd(),
                wildcard=wildcard,
                style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST
            )
            
            if dialog.ShowModal() == wx.ID_OK:
                file_path = dialog.GetPath()
                dialog.Destroy()
                app.Destroy()
                
                file_path = os.path.normpath(file_path)
                print(f"‚úì Selected file: {file_path}")
                return file_path
            else:
                dialog.Destroy()
                app.Destroy()
                print("‚úó No file selected")
                return None
                
        except ImportError:
            pass
        
        # Fallback to tkinter (slower but widely available)
        try:
            import tkinter as tk
            from tkinter import filedialog
            
            root = tk.Tk()
            root.withdraw()
            root.update_idletasks()
            
            try:
                root.attributes('-topmost', True)
            except tk.TclError:
                pass
            
            root.lift()
            root.focus_force()
            root.update()
            
            initial_dir = os.getcwd()
            
            print("Please select a path file...")
            
            file_path = filedialog.askopenfilename(
                parent=root,
                title='Select Pathway Data File',
                filetypes=[
                    ('Excel files', '*.xlsx *.xls'),
                    ('CSV files', '*.csv'),
                    ('All files', '*.*')
                ],
                initialdir=initial_dir
            )
            
            root.update()
            root.quit()
            root.destroy()
            
            if file_path:
                file_path = os.path.normpath(file_path)
                print(f"‚úì Selected file: {file_path}")
                return file_path
            else:
                print("‚úó No file selected")
                return None
                
        except ImportError:
            print("‚ö†Ô∏è No GUI library available (tried PyQt5, PyQt6, wxPython, tkinter)")
            print("   Install one of:")
            print("   - pip install PyQt5  (recommended - fastest)")
            print("   - pip install PyQt6")
            print("   - pip install wxPython")
            print("   - python3-tk (tkinter)")
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è Error opening file dialog: {e}")
            return None
    
    def _select_sheet(self, excel_file, auto_confirm=False):
        """
        Interactive sheet selection for Excel files.
        
        Parameters
        ----------
        excel_file : pd.ExcelFile
            Excel file object
        auto_confirm : bool, optional
            If True, always ask user to confirm even auto-detected sheets
            If False, silently auto-select common sheets (default)
            
        Returns
        -------
        str or None
            Selected sheet name, or None if cancelled
            
        Notes
        -----
        When auto_confirm=True (file picker was used):
        - Shows auto-detected sheet and asks for confirmation
        - User can accept or choose different sheet
        
        When auto_confirm=False (file path provided):
        - Silently auto-selects common sheet names
        - Only prompts if no common names found
        """
        sheet_names = excel_file.sheet_names
        
        # If only one sheet, use it automatically (no confirmation needed)
        if len(sheet_names) == 1:
            sheet_name = sheet_names[0]
            if auto_confirm:
                print(f"  Only one sheet found: '{sheet_name}'")
                confirm = self._confirm_sheet_selection(sheet_name, sheet_names, excel_file)
                return confirm if confirm else sheet_name
            else:
                print(f"  Only one sheet found: '{sheet_name}'")
                return sheet_name
        
        # Try to auto-detect common sheet names
        priority_sheets = ['path_type', 'path_bodyId', 'path_block', 'paths']
        auto_detected = None
        for sheet in priority_sheets:
            if sheet in sheet_names:
                auto_detected = sheet
                break
        
        # If auto-detected and confirmation requested, ask user
        if auto_detected and auto_confirm:
            print(f"  Auto-detected sheet: '{auto_detected}'")
            confirmed = self._confirm_sheet_selection(auto_detected, sheet_names, excel_file)
            return confirmed if confirmed else auto_detected
        
        # If auto-detected and no confirmation needed, use it
        elif auto_detected:
            print(f"  Auto-selected sheet: '{auto_detected}'")
            return auto_detected
        
        # No auto-detection possible - always ask user
        return self._prompt_sheet_selection(sheet_names, excel_file)
    
    def _confirm_sheet_selection(self, suggested_sheet, all_sheets, excel_file):
        """
        Show sheet selection dialog with auto-detected sheet pre-selected.
        
        Parameters
        ----------
        suggested_sheet : str
            Auto-detected sheet name (will be pre-selected)
        all_sheets : list
            List of all available sheet names
        excel_file : pd.ExcelFile
            Excel file object
            
        Returns
        -------
        str or None
            Selected sheet name, or None if cancelled
        """
        # Use the combined selection dialog with suggested sheet pre-selected
        return self._prompt_sheet_selection(all_sheets, excel_file, default_sheet=suggested_sheet)
    
    def _prompt_sheet_selection(self, sheet_names, excel_file, default_sheet=None):
        """
        Prompt user to select a sheet from available sheets using GUI dialog.
        Uses the fastest available GUI backend (PyQt5 > wxPython > tkinter).
        
        Parameters
        ----------
        sheet_names : list
            List of available sheet names
        excel_file : pd.ExcelFile
            Excel file object
        default_sheet : str, optional
            Sheet name to pre-select in the dialog (e.g., auto-detected sheet)
            
        Returns
        -------
        str or None
            Selected sheet name, or None if cancelled
        """
        # Try PyQt5 first (fastest)
        result = self._prompt_sheet_pyqt5(sheet_names, excel_file, default_sheet)
        if result is not False:
            return result
        
        # Try PyQt6
        result = self._prompt_sheet_pyqt6(sheet_names, excel_file, default_sheet)
        if result is not False:
            return result
        
        # Try wxPython
        result = self._prompt_sheet_wx(sheet_names, excel_file, default_sheet)
        if result is not False:
            return result
        
        # Fallback to tkinter
        result = self._prompt_sheet_tkinter(sheet_names, excel_file, default_sheet)
        if result is not False:
            return result
        
        # If all fail, use terminal
        return self._prompt_sheet_selection_terminal(sheet_names, excel_file, default_sheet)
    
    def _prompt_sheet_pyqt5(self, sheet_names, excel_file, default_sheet=None):
        """PyQt5 implementation - fastest and most responsive"""
        try:
            from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QPushButton, QLabel, QListWidgetItem
            from PyQt5.QtCore import Qt
            import sys
            
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            dialog = QDialog()
            dialog.setWindowTitle("Select Excel Sheet")
            dialog.setMinimumWidth(700)
            dialog.setMinimumHeight(400)
            
            layout = QVBoxLayout()
            
            # Title
            if default_sheet:
                title = QLabel(f"<b>Auto-detected: '{default_sheet}'</b>")
                subtitle = QLabel("Press OK to use it, or select a different sheet:")
                layout.addWidget(title)
                layout.addWidget(subtitle)
            else:
                title = QLabel("<b>Select a sheet:</b>")
                layout.addWidget(title)
            
            # List widget
            list_widget = QListWidget()
            list_widget.setAlternatingRowColors(True)
            
            default_idx = 0
            for idx, sheet in enumerate(sheet_names):
                try:
                    df = pd.read_excel(excel_file, sheet_name=sheet, nrows=0)
                    row_count = len(pd.read_excel(excel_file, sheet_name=sheet))
                    col_count = len(df.columns)
                    
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} ({row_count} rows, {col_count} cols) [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet} ({row_count} rows, {col_count} cols)"
                except:
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet}"
                
                item = QListWidgetItem(text)
                list_widget.addItem(item)
            
            list_widget.setCurrentRow(default_idx)
            list_widget.itemDoubleClicked.connect(dialog.accept)
            layout.addWidget(list_widget)
            
            # Tip label
            tip = QLabel("üí° Tip: Double-click or press OK to select")
            tip.setStyleSheet("color: gray;")
            layout.addWidget(tip)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            ok_button = QPushButton("OK")
            ok_button.setDefault(True)
            ok_button.clicked.connect(dialog.accept)
            button_layout.addWidget(ok_button)
            
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_button)
            
            layout.addLayout(button_layout)
            dialog.setLayout(layout)
            
            # Show dialog
            result = dialog.exec_()
            
            if result == QDialog.Accepted:
                selected_idx = list_widget.currentRow()
                selected_sheet = sheet_names[selected_idx]
                
                if default_sheet and selected_sheet == default_sheet:
                    print(f"‚úì Using auto-detected sheet: '{selected_sheet}'")
                else:
                    print(f"‚úì Selected sheet: '{selected_sheet}'")
                
                app.processEvents()
                return selected_sheet
            else:
                print("‚úó Sheet selection cancelled")
                app.processEvents()
                return None
                
        except ImportError:
            return False  # Not available, try next backend
        except Exception as e:
            print(f"‚ö†Ô∏è PyQt5 error: {e}")
            return False
    
    def _prompt_sheet_pyqt6(self, sheet_names, excel_file, default_sheet=None):
        """PyQt6 implementation - similar to PyQt5"""
        try:
            from PyQt6.QtWidgets import QApplication, QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QPushButton, QLabel, QListWidgetItem  # type: ignore
            from PyQt6.QtCore import Qt  # type: ignore
            import sys
            
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            dialog = QDialog()
            dialog.setWindowTitle("Select Excel Sheet")
            dialog.setMinimumWidth(700)
            dialog.setMinimumHeight(400)
            
            layout = QVBoxLayout()
            
            # Title
            if default_sheet:
                title = QLabel(f"<b>Auto-detected: '{default_sheet}'</b>")
                subtitle = QLabel("Press OK to use it, or select a different sheet:")
                layout.addWidget(title)
                layout.addWidget(subtitle)
            else:
                title = QLabel("<b>Select a sheet:</b>")
                layout.addWidget(title)
            
            # List widget
            list_widget = QListWidget()
            list_widget.setAlternatingRowColors(True)
            
            default_idx = 0
            for idx, sheet in enumerate(sheet_names):
                try:
                    df = pd.read_excel(excel_file, sheet_name=sheet, nrows=0)
                    row_count = len(pd.read_excel(excel_file, sheet_name=sheet))
                    col_count = len(df.columns)
                    
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} ({row_count} rows, {col_count} cols) [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet} ({row_count} rows, {col_count} cols)"
                except:
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet}"
                
                item = QListWidgetItem(text)
                list_widget.addItem(item)
            
            list_widget.setCurrentRow(default_idx)
            list_widget.itemDoubleClicked.connect(dialog.accept)
            layout.addWidget(list_widget)
            
            # Tip label
            tip = QLabel("üí° Tip: Double-click or press OK to select")
            tip.setStyleSheet("color: gray;")
            layout.addWidget(tip)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            ok_button = QPushButton("OK")
            ok_button.setDefault(True)
            ok_button.clicked.connect(dialog.accept)
            button_layout.addWidget(ok_button)
            
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_button)
            
            layout.addLayout(button_layout)
            dialog.setLayout(layout)
            
            # Show dialog
            result = dialog.exec()
            
            if result == QDialog.DialogCode.Accepted:
                selected_idx = list_widget.currentRow()
                selected_sheet = sheet_names[selected_idx]
                
                if default_sheet and selected_sheet == default_sheet:
                    print(f"‚úì Using auto-detected sheet: '{selected_sheet}'")
                else:
                    print(f"‚úì Selected sheet: '{selected_sheet}'")
                
                app.processEvents()
                return selected_sheet
            else:
                print("‚úó Sheet selection cancelled")
                app.processEvents()
                return None
                
        except ImportError:
            return False  # Not available, try next backend
        except Exception as e:
            print(f"‚ö†Ô∏è PyQt6 error: {e}")
            return False
    
    def _prompt_sheet_wx(self, sheet_names, excel_file, default_sheet=None):
        """wxPython implementation - fast alternative"""
        try:
            import wx  # type: ignore
            
            app = wx.App(False)
            
            # Build sheet info list
            sheet_info = []
            default_idx = 0
            for idx, sheet in enumerate(sheet_names):
                try:
                    df = pd.read_excel(excel_file, sheet_name=sheet, nrows=0)
                    row_count = len(pd.read_excel(excel_file, sheet_name=sheet))
                    col_count = len(df.columns)
                    
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} ({row_count} rows, {col_count} cols) [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet} ({row_count} rows, {col_count} cols)"
                except:
                    if sheet == default_sheet:
                        text = f"‚úì {sheet} [Suggested]"
                        default_idx = idx
                    else:
                        text = f"  {sheet}"
                
                sheet_info.append(text)
            
            if default_sheet:
                message = f"Auto-detected: '{default_sheet}'\n\nPress OK to use it, or select a different sheet:"
            else:
                message = "Select a sheet:"
            
            dialog = wx.SingleChoiceDialog(
                None,
                message,
                "Select Excel Sheet",
                sheet_info,
                wx.CHOICEDLG_STYLE
            )
            
            dialog.SetSelection(default_idx)
            
            if dialog.ShowModal() == wx.ID_OK:
                selected_idx = dialog.GetSelection()
                selected_sheet = sheet_names[selected_idx]
                dialog.Destroy()
                app.Destroy()
                
                if default_sheet and selected_sheet == default_sheet:
                    print(f"‚úì Using auto-detected sheet: '{selected_sheet}'")
                else:
                    print(f"‚úì Selected sheet: '{selected_sheet}'")
                
                return selected_sheet
            else:
                dialog.Destroy()
                app.Destroy()
                print("‚úó Sheet selection cancelled")
                return None
                
        except ImportError:
            return False  # Not available, try next backend
        except Exception as e:
            print(f"‚ö†Ô∏è wxPython error: {e}")
            return False
    
    def _prompt_sheet_tkinter(self, sheet_names, excel_file, default_sheet=None):
        """Tkinter implementation - slower but widely available fallback"""
        try:
            import tkinter as tk
            from tkinter import simpledialog, font
        except ImportError:
            return False
        
        try:
            # Create a custom dialog for sheet selection
            class SheetSelectionDialog(simpledialog.Dialog):
                def __init__(self, parent, title, sheet_names, excel_file, default_sheet=None):
                    self.sheet_names = sheet_names
                    self.excel_file = excel_file
                    self.default_sheet = default_sheet
                    self.selected_sheet = None
                    super().__init__(parent, title)
                
                def body(self, master):
                    master.configure(padx=15, pady=15)
                    
                    # Title
                    if self.default_sheet:
                        title_text = f"Auto-detected: '{self.default_sheet}'"
                        title_label = tk.Label(master, text=title_text, font=('Helvetica', 12, 'bold'))
                        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 5), sticky='w')
                        
                        subtitle = tk.Label(master, text="Press OK to use it, or select a different sheet:", font=('Helvetica', 9))
                        subtitle.grid(row=1, column=0, columnspan=2, pady=(0, 10), sticky='w')
                        current_row = 2
                    else:
                        title_label = tk.Label(master, text="Select a sheet:", font=('Helvetica', 12, 'bold'))
                        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 10), sticky='w')
                        current_row = 1
                    
                    # List frame
                    list_frame = tk.Frame(master, relief=tk.SUNKEN, borderwidth=1)
                    list_frame.grid(row=current_row, column=0, columnspan=2, pady=10, sticky='nsew')
                    
                    master.grid_rowconfigure(current_row, weight=1)
                    master.grid_columnconfigure(0, weight=1)
                    
                    # Listbox with scrollbar
                    scrollbar = tk.Scrollbar(list_frame, orient=tk.VERTICAL)
                    self.listbox = tk.Listbox(
                        list_frame, 
                        yscrollcommand=scrollbar.set, 
                        width=70, 
                        height=min(10, max(4, len(self.sheet_names))),
                        selectmode=tk.SINGLE
                    )
                    
                    scrollbar.config(command=self.listbox.yview)
                    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                    self.listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=2, pady=2)
                    
                    # Add sheet names
                    default_idx = 0
                    for idx, sheet in enumerate(self.sheet_names):
                        try:
                            df = pd.read_excel(self.excel_file, sheet_name=sheet, nrows=0)
                            row_count = len(pd.read_excel(self.excel_file, sheet_name=sheet))
                            col_count = len(df.columns)
                            
                            if sheet == self.default_sheet:
                                text = f"‚úì {sheet} ({row_count} rows, {col_count} cols) [Suggested]"
                                default_idx = idx
                            else:
                                text = f"  {sheet} ({row_count} rows, {col_count} cols)"
                        except:
                            if sheet == self.default_sheet:
                                text = f"‚úì {sheet} [Suggested]"
                                default_idx = idx
                            else:
                                text = f"  {sheet}"
                        
                        self.listbox.insert(tk.END, text)
                    
                    self.listbox.select_set(default_idx)
                    self.listbox.see(default_idx)
                    self.listbox.bind('<Double-Button-1>', lambda e: self.ok())
                    self.listbox.bind('<Return>', lambda e: self.ok())
                    
                    # Tip
                    tip_label = tk.Label(master, text="üí° Tip: Double-click or press Enter/OK to select", font=('Helvetica', 9))
                    tip_label.grid(row=current_row+1, column=0, columnspan=2, pady=(5, 0))
                    
                    return self.listbox
                
                def apply(self):
                    selection = self.listbox.curselection()
                    if selection:
                        self.selected_sheet = self.sheet_names[selection[0]]
            
            root = tk.Tk()
            root.withdraw()
            root.update_idletasks()
            
            try:
                root.attributes('-topmost', True)
            except tk.TclError:
                pass
            
            root.lift()
            root.focus_force()
            root.update()
            
            dialog = SheetSelectionDialog(root, "Select Excel Sheet", sheet_names, excel_file, default_sheet)
            selected_sheet = dialog.selected_sheet
            
            root.update()
            root.quit()
            root.destroy()
            
            if selected_sheet:
                if default_sheet and selected_sheet == default_sheet:
                    print(f"‚úì Using auto-detected sheet: '{selected_sheet}'")
                else:
                    print(f"‚úì Selected sheet: '{selected_sheet}'")
                return selected_sheet
            else:
                print("‚úó Sheet selection cancelled")
                return None
                
        except Exception as e:
            print(f"‚ö†Ô∏è Tkinter error: {e}")
            return False
    
    def _prompt_sheet_selection_terminal(self, sheet_names, excel_file, default_sheet=None):
        """
        Terminal fallback for sheet selection (when tkinter unavailable).
        
        Parameters
        ----------
        sheet_names : list
            List of available sheet names
        excel_file : pd.ExcelFile
            Excel file object
        default_sheet : str, optional
            Sheet name to suggest as default
            
        Returns
        -------
        str or None
            Selected sheet name, or None if cancelled
        """
        print("\n" + "="*60)
        if default_sheet:
            print(f"Auto-detected sheet: '{default_sheet}'")
            print("Select a sheet (or press Enter to use auto-detected):")
        else:
            print("Multiple sheets found. Please select one:")
        print("="*60)
        
        for idx, sheet in enumerate(sheet_names, 1):
            # Try to get row count for each sheet
            try:
                df = pd.read_excel(excel_file, sheet_name=sheet, nrows=0)
                row_count = len(pd.read_excel(excel_file, sheet_name=sheet))
                col_count = len(df.columns)
                marker = " ‚úì [Auto-detected]" if sheet == default_sheet else ""
                print(f"  [{idx}] {sheet:30s} ({row_count} rows, {col_count} cols){marker}")
            except:
                marker = " ‚úì [Auto-detected]" if sheet == default_sheet else ""
                print(f"  [{idx}] {sheet}{marker}")
        print("="*60)
        
        # Get user input
        while True:
            try:
                if default_sheet:
                    prompt = f"Enter number (1-{len(sheet_names)}), sheet name, or [Enter] for '{default_sheet}': "
                else:
                    prompt = f"Enter number (1-{len(sheet_names)}) or sheet name: "
                
                choice = input(prompt).strip()
                
                # Enter key - use default if available
                if choice == '' and default_sheet:
                    print(f"‚úì Using auto-detected sheet: '{default_sheet}'")
                    return default_sheet
                
                # Try as number first
                if choice.isdigit():
                    idx = int(choice)
                    if 1 <= idx <= len(sheet_names):
                        selected = sheet_names[idx - 1]
                        print(f"‚úì Selected: '{selected}'")
                        return selected
                    else:
                        print(f"‚ö†Ô∏è Invalid number. Please enter 1-{len(sheet_names)}")
                        
                # Try as sheet name
                elif choice in sheet_names:
                    print(f"‚úì Selected: '{choice}'")
                    return choice
                    
                # Allow cancel
                elif choice.lower() in ['q', 'quit', 'cancel', 'exit']:
                    print("‚úó Selection cancelled")
                    return None
                    
                else:
                    print(f"‚ö†Ô∏è Invalid input. Enter a number, sheet name, or 'q' to cancel")
                    
            except KeyboardInterrupt:
                print("\n‚úó Selection cancelled")
                return None
            except EOFError:
                print("\n‚úó No input available")
                return None
        
    def _validate_data(self):
        """
        Validate that required columns exist in the data.
        
        Supports two input formats:
        
        1. **Path-based format** (original):
           Required: 'path_block', 'weights'
           Optional: 'connection_ratios', 'traversal_probabilities', 'layer'
           
        2. **Edge-list format** (new - simple network):
           Required: source + target + weight columns
           Column names can be:
           - 'source' / 'target' / 'weight'
           - '{prefix}_pre' / '{prefix}_post' / 'weight' (e.g., 'bodyId_pre', 'bodyId_post')
           - 'from' / 'to' / 'weight'
           - 'pre' / 'post' / 'weight'
           
        The system automatically detects the format and converts edge-list
        to internal path format for visualization.
        """
        # Check for path-based format
        path_cols = ['path_block', 'weights']
        has_path_format = all(col in self.path_df.columns for col in path_cols)
        
        if has_path_format:
            print(f"‚úì Detected path-based format")
            print(f"  Loaded {len(self.path_df)} pathways from data")
            print(f"  Output folder: {self.output_folder}")
            return
        
        # Check for edge-list format
        print("Path-based format not detected, checking for edge-list format...")
        
        # Try to find source/target/weight columns
        source_col = self._find_column(['source', 'from', 'pre'], suffix='_pre')
        target_col = self._find_column(['target', 'to', 'post'], suffix='_post')
        weight_col = self._find_column(['weight', 'weights', 'synapse_count', 'count'])
        
        # Check for optional color column
        color_col = self._find_column(['color', 'edge_color', 'link_color'])
        
        if source_col and target_col and weight_col:
            print(f"‚úì Detected edge-list format")
            print(f"  Source column: '{source_col}'")
            print(f"  Target column: '{target_col}'")
            print(f"  Weight column: '{weight_col}'")
            if color_col:
                print(f"  Color column: '{color_col}'")
            print(f"  Converting {len(self.path_df)} edges to path format...")
            
            # Convert edge-list to path format
            self._convert_edgelist_to_paths(source_col, target_col, weight_col, color_col)
            
            print(f"‚úì Converted to {len(self.path_df)} paths")
            print(f"  Output folder: {self.output_folder}")
            return
        
        # Neither format found - raise error
        available_cols = list(self.path_df.columns)
        raise ValueError(
            f"Invalid data format. Could not find required columns.\n\n"
            f"Supported formats:\n"
            f"1. Path-based: 'path_block' + 'weights'\n"
            f"2. Edge-list: (source/from/pre/*_pre) + (target/to/post/*_post) + (weight/weights)\n\n"
            f"Available columns: {available_cols}\n\n"
            f"Examples:\n"
            f"  Path format:    path_block='A -> B -> C', weights='[10, 5]'\n"
            f"  Edge format:    source='A', target='B', weight=10\n"
            f"  BodyId format:  bodyId_pre=123, bodyId_post=456, weight=10\n"
        )
    
    def _load_custom_colors(self):
        """
        Load custom node colors from file, sheet, or DataFrame.
        
        Populates self.custom_node_colors as a dict mapping node name to color.
        Colors can be in hex (#RRGGBB) or rgba (rgba(r,g,b,a)) format.
        """
        node_colors_df = None
        
        # Determine source type and load data
        if isinstance(self.node_colors_input, pd.DataFrame):
            # Direct DataFrame input
            node_colors_df = self.node_colors_input.copy()
            print("Loading custom node colors from DataFrame...")
            
        elif isinstance(self.node_colors_input, str):
            # Could be sheet name or file path
            if os.path.exists(self.node_colors_input):
                # File path
                print(f"Loading custom node colors from file: {self.node_colors_input}")
                file_ext = Path(self.node_colors_input).suffix.lower()
                if file_ext == '.csv':
                    node_colors_df = pd.read_csv(self.node_colors_input)
                elif file_ext in ['.xlsx', '.xls']:
                    node_colors_df = pd.read_excel(self.node_colors_input)
                else:
                    raise ValueError(f"Unsupported file type for node_colors: {file_ext}")
            else:
                # Assume it's a sheet name in the main Excel file
                if isinstance(self.path_file, str) and Path(self.path_file).suffix.lower() in ['.xlsx', '.xls']:
                    print(f"Loading custom node colors from sheet '{self.node_colors_input}'...")
                    try:
                        node_colors_df = pd.read_excel(self.path_file, sheet_name=self.node_colors_input)
                    except Exception as e:
                        raise ValueError(
                            f"Could not load node_colors from sheet '{self.node_colors_input}': {e}\n"
                            f"Make sure the sheet exists in the Excel file."
                        )
                else:
                    raise ValueError(
                        f"node_colors is a string but not a valid file path: {self.node_colors_input}\n"
                        f"And path_file is not an Excel file, so can't interpret as sheet name."
                    )
        else:
            raise ValueError(f"node_colors must be a DataFrame, file path, or sheet name (str), got {type(self.node_colors_input)}")
        
        # Validate required columns (case-insensitive)
        cols_lower = {col.lower(): col for col in node_colors_df.columns}
        
        if 'node' not in cols_lower:
            raise ValueError(f"node_colors must have a 'node' column (case-insensitive). Found columns: {list(node_colors_df.columns)}")
        if 'color' not in cols_lower:
            raise ValueError(f"node_colors must have a 'color' column (case-insensitive). Found columns: {list(node_colors_df.columns)}")
        
        # Get actual column names
        node_col = cols_lower['node']
        color_col = cols_lower['color']
        
        # Build color mapping dictionary
        self.custom_node_colors = {}
        for _, row in node_colors_df.iterrows():
            node_name = str(row[node_col]).strip()
            color_value = str(row[color_col]).strip()
            
            # Validate color format (hex or rgba)
            if color_value.startswith('#') or color_value.startswith('rgb'):
                # Parse to validate and normalize
                hex_color, opacity = parse_color_to_hex_opacity(color_value)
                # Store as rgba format for consistency
                if opacity < 1.0:
                    # Convert hex back to rgb and add opacity
                    r = int(hex_color[1:3], 16)
                    g = int(hex_color[3:5], 16)
                    b = int(hex_color[5:7], 16)
                    self.custom_node_colors[node_name] = f'rgba({r},{g},{b},{opacity})'
                else:
                    self.custom_node_colors[node_name] = hex_color
            else:
                print(f"‚ö†Ô∏è Warning: Invalid color format for node '{node_name}': {color_value}. Skipping.")
                continue
        
        print(f"‚úì Loaded custom colors for {len(self.custom_node_colors)} nodes")
    
    def _find_column(self, candidates, suffix=None):
        """
        Find a column from list of candidates.
        
        Parameters
        ----------
        candidates : list
            List of possible column names
        suffix : str, optional
            Suffix to also check (e.g., '_pre', '_post')
            Matches any column ending with suffix that has a prefix
            (e.g., 'bodyId_pre', 'type_pre', 'neuron_pre')
            
        Returns
        -------
        str or None
            Found column name, or None
        """
        cols = self.path_df.columns
        
        # Check exact matches
        for candidate in candidates:
            if candidate in cols:
                return candidate
        
        # Check with suffix (e.g., 'bodyId_pre', 'type_pre', 'anything_pre')
        if suffix:
            for col in cols:
                # Must end with suffix AND have a prefix (not just '_pre' alone)
                if col.endswith(suffix) and len(col) > len(suffix) and '_' in col:
                    # Ensure there's actual content before the suffix
                    prefix = col[:col.rfind(suffix)]
                    if prefix and prefix != '_':  # Must have non-empty prefix
                        return col
        
        return None
    
    def _convert_edgelist_to_paths(self, source_col, target_col, weight_col, color_col=None):
        """
        Convert edge-list format to path-based format.
        
        Automatically detects and converts all numeric columns as additional metrics
        (e.g., ratio, probability, or any other numeric metric columns).
        
        Parameters
        ----------
        source_col : str
            Name of source column
        target_col : str
            Name of target column
        weight_col : str
            Name of weight column (primary metric)
        color_col : str, optional
            Name of edge color column (hex or rgba format)
        """
        # Create path_block and weights columns
        paths = []
        weights = []
        
        # Store edge colors if provided
        custom_edge_colors = {}
        
        # Identify all numeric columns (excluding source, target, and color columns)
        exclude_cols = {source_col, target_col}
        if color_col:
            exclude_cols.add(color_col)
        
        # Find all numeric columns that could be additional metrics
        numeric_cols = []
        additional_metric_names = []
        for col in self.path_df.columns:
            if col not in exclude_cols:
                # Check if column is numeric
                if pd.api.types.is_numeric_dtype(self.path_df[col]):
                    if col != weight_col:  # Weight is primary metric
                        numeric_cols.append(col)
                        # Store original column name for later use
                        additional_metric_names.append(col)
        
        # Initialize storage for additional metrics
        additional_metrics = {col: [] for col in numeric_cols}
        
        print(f"  Detected numeric columns: {[weight_col] + numeric_cols}")
        
        for idx, row in self.path_df.iterrows():
            source = str(row[source_col])
            target = str(row[target_col])
            weight = row[weight_col]
            
            # Create path block
            path_block = f"{source} -> {target}"
            paths.append(path_block)
            
            # Create weights list (primary metric)
            weights.append([weight])
            
            # Store additional metrics
            for col in numeric_cols:
                value = row[col] if pd.notna(row[col]) else 0
                additional_metrics[col].append([value])
            
            # Store edge color if provided
            if color_col and color_col in row and pd.notna(row[color_col]):
                edge_key = (source, target)
                color_value = str(row[color_col]).strip()
                # Validate and normalize color
                if color_value.startswith('#') or color_value.startswith('rgb'):
                    custom_edge_colors[edge_key] = color_value
        
        # Add new columns
        self.path_df['path_block'] = paths
        self.path_df['weights'] = weights
        
        # Add additional metric columns
        # Map common metric names to standard column names
        metric_mapping = {
            'ratio': 'connection_ratios',
            'connection_ratio': 'connection_ratios',
            'conn_ratio': 'connection_ratios',
            'probability': 'traversal_probabilities',
            'prob': 'traversal_probabilities',
            'traversal_probability': 'traversal_probabilities',
            'trav_prob': 'traversal_probabilities'
        }
        
        for col in numeric_cols:
            col_lower = col.lower()
            # Check if this matches a standard metric name
            if col_lower in metric_mapping:
                standard_col = metric_mapping[col_lower]
                self.path_df[standard_col] = additional_metrics[col]
                print(f"  ‚úì Mapped '{col}' ‚Üí '{standard_col}' for toggle support")
            else:
                # Keep original column name for custom metrics
                # These will be available in conn_df but not in toggle
                # (could be extended to support dynamic toggles in future)
                self.path_df[col] = additional_metrics[col]
                print(f"  ‚úì Added metric column '{col}' (custom metric)")
        
        # Store custom edge colors for later use
        if custom_edge_colors:
            self.custom_edge_colors = custom_edge_colors
            print(f"  ‚úì Loaded custom colors for {len(custom_edge_colors)} edges")
        else:
            self.custom_edge_colors = None
        
        # Ensure standard optional columns exist (for compatibility)
        if 'connection_ratios' not in self.path_df.columns:
            self.path_df['connection_ratios'] = [[] for _ in range(len(self.path_df))]
        
        if 'traversal_probabilities' not in self.path_df.columns:
            self.path_df['traversal_probabilities'] = [[] for _ in range(len(self.path_df))]
        
        if 'layer' not in self.path_df.columns:
            # Assign layer 0 to all paths (will be auto-detected in build_network)
            self.path_df['layer'] = 0
        
    def _parse_path_block(self, path_str):
        """
        Parse path_block string into list of nodes.
        
        Parameters
        ----------
        path_str : str
            Path string in format "A -> B -> C -> D"
            
        Returns
        -------
        list
            List of node names
        """
        return [node.strip() for node in path_str.split('->')]
    
    def _safe_eval_list(self, val):
        """
        Safely evaluate string representation of list.
        
        Parameters
        ----------
        val : str or list
            String representation of list or actual list
            
        Returns
        -------
        list
            Evaluated list
        """
        if isinstance(val, str):
            try:
                return ast.literal_eval(val)
            except:
                return []
        elif isinstance(val, list):
            return val
        else:
            return []
    
    def _apply_custom_order(self, available_nodes, custom_order):
        """
        Apply custom ordering to a list of nodes.
        
        Parameters
        ----------
        available_nodes : list
            List of all available nodes
        custom_order : list
            Desired order for nodes
            
        Returns
        -------
        list
            Nodes in custom order, with any remaining nodes appended at the end
            
        Notes
        -----
        - Only includes nodes that are in available_nodes
        - Nodes in custom_order but not in available_nodes are skipped
        - Nodes in available_nodes but not in custom_order are appended at the end (sorted)
        """
        available_set = set(available_nodes)
        ordered = []
        
        # Add nodes from custom_order that exist in available_nodes
        for node in custom_order:
            if node in available_set:
                ordered.append(node)
                available_set.remove(node)
        
        # Append remaining nodes (sorted) that weren't in custom_order
        if available_set:
            ordered.extend(sorted(available_set))
        
        return ordered
    
    def build_network(self):
        """
        Build NetworkX graph and connection DataFrame from pathway data.
        
        This method processes the pathway data to create:
        1. A connection DataFrame with aggregated edge weights
        2. A NetworkX directed graph for visualization
        
        The method aggregates multiple paths between the same nodes,
        summing weights and averaging ratios/probabilities.
        
        Returns
        -------
        tuple
            (conn_df, G_network) - Connection DataFrame and NetworkX graph
            
        Notes
        -----
        - Connections are aggregated: same source->target get weights summed
        - Ratios and probabilities are averaged across aggregated connections
        - Graph nodes are labeled with 'node_type' (source/intermediate/target)
        """
        print("\nBuilding network from pathways...")
        
        # Store connections
        connections = []
        
        # Check which optional columns are available
        has_ratios = 'connection_ratios' in self.path_df.columns
        has_probs = 'traversal_probabilities' in self.path_df.columns
        
        for idx, row in self.path_df.iterrows():
            path_block = row['path_block']
            weights = self._safe_eval_list(row['weights'])
            
            # Optional columns - only if they exist
            ratios = self._safe_eval_list(row.get('connection_ratios', [])) if has_ratios else []
            probs = self._safe_eval_list(row.get('traversal_probabilities', [])) if has_probs else []
            
            # Parse path
            nodes = self._parse_path_block(path_block)
            
            # Create connections for each hop
            for i in range(len(nodes) - 1):
                source = nodes[i]
                target = nodes[i + 1]
                weight = weights[i] if i < len(weights) else 0
                ratio = ratios[i] if i < len(ratios) else np.nan
                prob = probs[i] if i < len(probs) else np.nan
                
                conn_data = {
                    'source': source,
                    'target': target,
                    'weight': weight
                }
                
                # Only add optional columns if they exist in source data
                if has_ratios:
                    conn_data['ratio'] = ratio
                if has_probs:
                    conn_data['probability'] = prob
                    
                connections.append(conn_data)
        
        # Create DataFrame
        conn_df = pd.DataFrame(connections)

        # If there are no per-hop connections (e.g., all input paths are single-node
        # or empty), create an empty DataFrame with expected columns to avoid groupby
        # KeyError. Otherwise aggregate duplicate connections as usual.
        if conn_df.empty:
            cols = ['source', 'target', 'weight']
            if has_ratios:
                cols.append('ratio')
            if has_probs:
                cols.append('probability')
            conn_df = pd.DataFrame(columns=cols)
        else:
            # Aggregate duplicate connections - only aggregate columns that exist
            # Use 'max' for weight: same edge has same weight regardless of which path it appears in
            agg_dict = {'weight': 'max'}
            if has_ratios:
                agg_dict['ratio'] = 'mean'
            if has_probs:
                agg_dict['probability'] = 'mean'

            conn_df = conn_df.groupby(['source', 'target'], as_index=False).agg(agg_dict)

        # Drop zero-weight edges: users requested that zero-weight edges be removed from
        # visualizations while still allowing nodes mentioned only in zero-weight rows
        # to show up as orphan nodes. We therefore drop aggregated edges whose weight
        # is exactly 0 here (after aggregation), but will add all nodes that appear in
        # the original path data back into the graph later.
        before_count = len(conn_df)
        conn_df = conn_df.loc[conn_df['weight'] != 0].copy()
        after_count = len(conn_df)

        if before_count != after_count:
            print(f"Dropped {before_count - after_count} zero-weight aggregated connections")

        print(f"Created {len(conn_df)} unique connections from pathways")
        
        # Build NetworkX graph
        G = nx.DiGraph()
        
        # Add edges with attributes - only add attributes that exist
        for _, row in conn_df.iterrows():
            edge_attrs = {'weight': row['weight']}
            if 'ratio' in row:
                edge_attrs['ratio'] = row['ratio']
            if 'probability' in row:
                edge_attrs['probability'] = row['probability']
            
            G.add_edge(row['source'], row['target'], **edge_attrs)
        
        # Determine node types based on position in original paths
        # Track which nodes appear at the start or end of ANY path
        path_sources = set()
        path_targets = set()
        
        for idx, row in self.path_df.iterrows():
            path_block = row['path_block']
            nodes = self._parse_path_block(path_block)
            if len(nodes) > 0:
                path_sources.add(nodes[0])   # First node is a source
                path_targets.add(nodes[-1])  # Last node is a target

        # Ensure orphan nodes (nodes that appear in path data but have no
        # non-zero edges after filtering) are present in the graph. This
        # allows edge-list inputs that contain source/target with weight=0
        # to still produce visible nodes in the network and Sankey.
        all_nodes_in_paths = set()
        for idx, row in self.path_df.iterrows():
            nodes = self._parse_path_block(row['path_block'])
            for n in nodes:
                all_nodes_in_paths.add(n)

        missing_nodes = all_nodes_in_paths - set(G.nodes())
        if missing_nodes:
            for n in missing_nodes:
                G.add_node(n)
        
        # Classify nodes: prioritize source/target identity
        all_nodes = set(G.nodes())
        source_nodes = path_sources
        target_nodes = path_targets
        intermediate_nodes = all_nodes - source_nodes - target_nodes
        
        # Set node attributes
        for node in source_nodes:
            G.nodes[node]['node_type'] = 'source'
        for node in intermediate_nodes:
            G.nodes[node]['node_type'] = 'intermediate'
        for node in target_nodes:
            G.nodes[node]['node_type'] = 'target'
        
        print(f"Network: {len(source_nodes)} source, {len(intermediate_nodes)} intermediate, {len(target_nodes)} target nodes")
        
        self.conn_df = conn_df
        self.G_network = G
        
        return conn_df, G
    
    def create_sankey(self):
        """
        Create multi-layer Sankey diagram from pathway data.
        
        Builds a layered Sankey diagram similar to coana's implementation:
        - Extracts layer information from paths
        - Orders nodes by layer (source ‚Üí intermediate ‚Üí target)
        - Assigns colors based on node types
        - Creates connections between adjacent layers
        
        Returns
        -------
        str
            Path to the generated HTML file
            
        Notes
        -----
        - Requires pathway data with path_block column
        - Node widths represent number of connections
        - Link widths represent synapse weights
        - Colors follow source_color, intermediate_color, and target_color settings
        - Builds layers from path_block data to ensure proper ordering
        """
        if self.path_df is None:
            print("Error: No pathway data available.")
            return None
        
        print("\nCreating layered Sankey diagram...")
        
        # Extract layer information from paths
        # edge_data: {(layer_idx, source, target): {'weight': ..., 'ratio': ..., 'prob': ..., 'count': ...}}
        edge_data = {}
        node_layers = {}  # {node: set of layer indices}
        
        # Check which optional columns are available
        has_ratios = 'connection_ratios' in self.path_df.columns
        has_probs = 'traversal_probabilities' in self.path_df.columns
        
        for idx, row in self.path_df.iterrows():
            path_block = row['path_block']
            weights = self._safe_eval_list(row['weights'])
            ratios = self._safe_eval_list(row.get('connection_ratios', [])) if has_ratios else []
            probs = self._safe_eval_list(row.get('traversal_probabilities', [])) if has_probs else []
            
            nodes = self._parse_path_block(path_block)
            
            # Track which layers each node appears in
            for layer_idx, node in enumerate(nodes):
                node_layers.setdefault(node, set()).add(layer_idx)
            
            # Create edges with layer information
            for i in range(len(nodes) - 1):
                source = nodes[i]
                target = nodes[i + 1]
                layer_idx = i  # Layer index is the hop position
                
                edge_key = (layer_idx, source, target)
                weight = weights[i] if i < len(weights) else 0
                ratio = ratios[i] if i < len(ratios) else 0
                prob = probs[i] if i < len(probs) else 0
                
                if edge_key not in edge_data:
                    edge_data[edge_key] = {'weight': weight, 'ratio': ratio, 'prob': prob}
                else:
                    # Same edge in different paths: use max since it's the same biological connection
                    # (weight should be identical, but use max to be safe)
                    edge_data[edge_key]['weight'] = max(edge_data[edge_key]['weight'], weight)
                    edge_data[edge_key]['ratio'] = max(edge_data[edge_key]['ratio'], ratio)
                    edge_data[edge_key]['prob'] = max(edge_data[edge_key]['prob'], prob)
        
        # Remove zero-weight layer edges (user preference: drop zero-weight edges)
        edge_data = {k: v for k, v in edge_data.items() if v.get('weight', 0) != 0}

        if len(edge_data) == 0:
            # Warn but continue: we still want to build a node-only Sankey (or at least
            # include orphan nodes) if no non-zero links are present.
            print('\033[33mWarning: No non-zero connections found for Sankey diagram. Building node-only Sankey (no links).\033[0m')
        
        # Simplify Sankey if too many edges (> 100)
        MAX_EDGES = 100
        simplification_applied = False
        original_edge_count = len(edge_data)
        
        if len(edge_data) > MAX_EDGES:
            print(f'\033[33m‚ÑπÔ∏è  Too many edges ({original_edge_count}) - simplifying to top {MAX_EDGES} by weight\033[0m')
            # Sort edges by absolute weight (descending) and keep top MAX_EDGES
            sorted_edges = sorted(edge_data.items(), key=lambda x: abs(x[1]['weight']), reverse=True)
            edge_data = dict(sorted_edges[:MAX_EDGES])
            simplification_applied = True
            print(f'  Kept {len(edge_data)} edges (top {MAX_EDGES} by weight)')
        
        # Build node list ordered by layers (key to proper layering)
        nodes_by_layer = {}
        for (layer_idx, source, target) in edge_data.keys():
            nodes_by_layer.setdefault(layer_idx, set()).add(source)
            nodes_by_layer.setdefault(layer_idx + 1, set()).add(target)

        # Include nodes that appear in paths (node_layers) even if they had only
        # zero-weight edges and thus were removed from edge_data. Place them in
        # their earliest observed layer to preserve ordering in the Sankey.
        for node, layers in node_layers.items():
            if not layers:
                continue
            earliest = min(layers)
            nodes_by_layer.setdefault(earliest, set()).add(node)
        
        # Build network if not already done (to get node types)
        if self.G_network is None:
            self.build_network()
        
        node_list = []
        node_labels = []
        node_colors_list = []
        node_added = set()  # Track which nodes we've already added
        
        # Get node types from graph
        node_types = {node: self.G_network.nodes[node].get('node_type', 'intermediate') 
                     for node in self.G_network.nodes()}
        
        # Build nodes ordered by layer (add each node only once, at its earliest layer)
        for layer_idx in sorted(nodes_by_layer.keys()):
            layer_nodes = sorted(nodes_by_layer[layer_idx])
            for node in layer_nodes:
                if node in node_added:
                    continue  # Skip if already added
                
                node_added.add(node)
                node_list.append(node)
                
                # Create label with layer information
                all_layers = sorted(node_layers[node])
                if len(all_layers) == 1:
                    node_labels.append(f"{node} (L{all_layers[0]})")
                else:
                    layers_str = ','.join(map(str, all_layers))
                    node_labels.append(f"{node} (L{layers_str})")
                
                # Assign color: prioritize custom colors, then default by node type
                if self.custom_node_colors and node in self.custom_node_colors:
                    # Use custom color
                    node_colors_list.append(self.custom_node_colors[node])
                else:
                    # Use default color based on node type
                    node_type = node_types.get(node, 'intermediate')
                    if node_type == 'source':
                        node_colors_list.append(self.source_color)
                    elif node_type == 'target':
                        node_colors_list.append(self.target_color)
                    else:
                        node_colors_list.append(self.intermediate_color)
        
        # Create node index mapping
        node_to_idx = {node: idx for idx, node in enumerate(node_list)}
        
        # Build edge lists
        source_indices = []
        target_indices = []
        weights = []
        original_weights = []  # Store original weights (including negatives) for hover
        ratios = []
        probs = []
        edge_colors = []  # Custom edge colors
        has_negative = False  # Track if any negative weights exist
        
        for (layer_idx, source, target), data in edge_data.items():
            source_indices.append(node_to_idx[source])
            target_indices.append(node_to_idx[target])
            
            # Handle negative weights: use absolute value, mark with different color
            weight = data['weight']
            is_negative = weight < 0
            if is_negative:
                has_negative = True
            abs_weight = abs(weight)
            
            weights.append(abs_weight)
            original_weights.append(weight)  # Keep original for hover label
            ratios.append(data['ratio'])
            probs.append(data['prob'])
            
            # Determine edge color
            if is_negative:
                # Red color for negative edges
                edge_colors.append('rgba(231, 76, 60, 0.4)')
            elif self.custom_edge_colors and (source, target) in self.custom_edge_colors:
                edge_colors.append(self.custom_edge_colors[(source, target)])
            else:
                edge_colors.append(self.link_color)
        
        if has_negative:
            print(f"  ‚ÑπÔ∏è  Found negative edge weights - using absolute values for link width, light blue for negative edges")
        
        # Create custom hover labels that show source, target, and original weights
        hover_labels = []
        for i, (src_idx, tgt_idx, orig_weight, abs_weight) in enumerate(zip(source_indices, target_indices, original_weights, weights)):
            source_name = node_list[src_idx]
            target_name = node_list[tgt_idx]
            hover_text = f"{source_name} ‚Üí {target_name}<br>"
            hover_text += f"Weight: {orig_weight:,}"  # Show original (possibly negative)
            if ratios[i] != 0:
                hover_text += f"<br>Ratio: {ratios[i]:.3f}"
            if probs[i] != 0:
                hover_text += f"<br>Probability: {probs[i]:.3f}"
            hover_labels.append(hover_text)
        
        # Create Sankey figure using Plotly directly (like coana)
        import plotly.graph_objects as go
        
        # Update edge colors: gray for positive, light blue for negative
        edge_colors_updated = []
        for i, orig_weight in enumerate(original_weights):
            if orig_weight < 0:
                edge_colors_updated.append('rgba(74, 144, 226, 0.4)')  # Light blue for negative
            elif self.custom_edge_colors:
                # Check if custom color exists for this edge
                src_node = node_list[source_indices[i]]
                tgt_node = node_list[target_indices[i]]
                if (src_node, tgt_node) in self.custom_edge_colors:
                    edge_colors_updated.append(self.custom_edge_colors[(src_node, tgt_node)])
                else:
                    edge_colors_updated.append('rgba(100, 100, 100, 0.4)')  # Gray for positive
            else:
                edge_colors_updated.append('rgba(100, 100, 100, 0.4)')  # Gray for positive
        
        fig = go.Figure(data=[go.Sankey(
            node=dict(
                pad=5,
                thickness=5,
                line=dict(color="black", width=0),
                label=node_labels,
                color=node_colors_list
            ),
            link=dict(
                source=source_indices,
                target=target_indices,
                value=weights,
                color=edge_colors_updated,
                customdata=hover_labels,  # Store full hover text
                hovertemplate='%{customdata}<extra></extra>'  # Show custom hover text
            )
        )])
        
        # Add legend annotations if there are negative values
        annotations = []
        if has_negative:
            # Add legend for positive and negative edges
            annotations = [
                dict(
                    x=0.02, y=0.98,
                    xref='paper', yref='paper',
                    text='<b>Legend:</b>',
                    showarrow=False,
                    font=dict(size=12, color='black'),
                    align='left',
                    xanchor='left',
                    yanchor='top'
                ),
                dict(
                    x=0.02, y=0.94,
                    xref='paper', yref='paper',
                    text='<span style="color: rgba(100,100,100,0.6);">‚ñ†</span> Positive weight',
                    showarrow=False,
                    font=dict(size=11, color='black'),
                    align='left',
                    xanchor='left',
                    yanchor='top'
                ),
                dict(
                    x=0.02, y=0.90,
                    xref='paper', yref='paper',
                    text='<span style="color: rgba(74,144,226,0.4);">‚ñ†</span> Negative weight',
                    showarrow=False,
                    font=dict(size=11, color='black'),
                    align='left',
                    xanchor='left',
                    yanchor='top'
                )
            ]
        
        fig.update_layout(
            title_text='Sankey diagram of pathway connections',
            font_size=12,
            height=None,  # Let it fill container
            autosize=True,  # Auto-resize to container
            margin=dict(l=10, r=10, t=50, b=10),  # Minimal margins to maximize diagram space
            annotations=annotations  # Add legend
        )
        
        output_path = os.path.join(self.output_folder, self.base_filename + '_Sankey.html')
        
        # Get the basic Plotly HTML
        import plotly.io as pio
        basic_html = pio.to_html(fig, include_plotlyjs='cdn', full_html=False)
        
        # Create custom HTML with interactive controls
        html_content = self._create_sankey_html_with_controls(
            basic_html, 
            node_list, 
            node_labels, 
            node_colors_list,
            source_indices,
            target_indices,
            weights,
            ratios,
            probs,
            original_weights,
            simplification_applied,
            original_edge_count
        )
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        if self.showfig:
            import webbrowser
            webbrowser.open('file://' + os.path.abspath(output_path))
        
        print(f"  Sankey diagram saved with {len(node_list)} nodes and {len(weights)} edges")
        print(f"  Output: {output_path}")
        
        return output_path
    
    def _create_sankey_html_with_controls(self, plotly_div, node_list, node_labels, node_colors_list, 
                                          source_indices, target_indices, weights, ratios=None, probs=None, original_weights=None,
                                          simplification_applied=False, original_edge_count=0):
        """
        Create HTML with interactive controls for Sankey diagram.
        
        Adds control panel with:
        - Node color pickers for each node type
        - Edge color and opacity sliders
        - Metric toggle (weight/ratio/prob)
        - Hide/show nodes and edges by clicking
        - Reset button
        
        Parameters
        ----------
        plotly_div : str
            Plotly HTML div content
        node_list : list
            List of node names
        node_labels : list
            List of node labels with layer info
        node_colors_list : list
            List of node colors
        source_indices : list
            List of source node indices for edges
        target_indices : list
            List of target node indices for edges
        weights : list
            List of edge weights (synapse counts)
        ratios : list, optional
            List of edge connection ratios
        probs : list, optional
            List of edge traversal probabilities
        simplification_applied : bool, optional
            Whether edge simplification was applied
        original_edge_count : int, optional
            Original number of edges before simplification
        """
        
        # Check which metrics are available
        has_ratios = ratios is not None and len(ratios) > 0 and any(r > 0 for r in ratios)
        has_probs = probs is not None and len(probs) > 0 and any(p > 0 for p in probs)
        
        # Default to empty lists if not provided
        if ratios is None:
            ratios = [0] * len(weights)
        if probs is None:
            probs = [0] * len(weights)
        
        # Parse edge color and opacity
        # For Sankey, always use gray for positive edges (negative edges are light blue)
        edge_hex, edge_opacity = parse_color_to_hex_opacity('rgba(100, 100, 100, 0.4)')
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Interactive Sankey Diagram</title>
    <style>
        body {{
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }}
        #main-container {{
            display: flex;
            flex-direction: column;
            height: 100vh;
        }}
        #controls {{
            background: white;
            border-bottom: 1px solid #ddd;
            padding: 12px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 25vh;  /* Limit control panel height to 25% of viewport */
        }}
        .control-row {{
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }}
        #sankey-container {{
            flex: 1;
            background: white;
            position: relative;
            overflow: hidden;
            min-height: 0;  /* Important for flex children */
        }}
        /* Make Plotly div fill the container */
        #sankey-container > div {{
            width: 100% !important;
            height: 100% !important;
        }}
        /* Make Plotly plot fill its parent */
        #sankey-container .plotly-graph-div {{
            width: 100% !important;
            height: 100% !important;
        }}
        #sankey-container .plot-container {{
            width: 100% !important;
            height: 100% !important;
        }}
        /* Make hover labels larger and ensure text doesn't overflow */
        .hoverlayer .hovertext {{
            min-width: 300px !important;
            max-width: 500px !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            padding: 15px !important;
        }}
        .hoverlayer .hovertext text {{
            white-space: normal !important;
        }}
        /* Expand the background box */
        .hoverlayer .hovertext path {{
            opacity: 1 !important;
        }}
        .hoverlayer .hovertext rect {{
            width: auto !important;
            min-width: 300px !important;
        }}
        .control-section {{
            display: flex;
            gap: 20px;
            align-items: center;
        }}
        .control-group {{
            display: flex;
            flex-direction: column;
            gap: 5px;
        }}
        .control-label {{
            font-weight: 500;
            color: #555;
            font-size: 12px;
            white-space: nowrap;
        }}
        .color-input-group {{
            display: flex;
            gap: 5px;
            align-items: center;
        }}
        input[type="color"] {{
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }}
        input[type="range"] {{
            width: 120px;
        }}
        input[type="text"] {{
            width: 90px;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            background: #f9f9f9;
        }}
        .slider-value {{
            color: #666;
            font-size: 11px;
            min-width: 35px;
            text-align: right;
        }}
        button {{
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }}
        .btn-primary {{
            background: #4CAF50;
            color: white;
        }}
        .btn-primary:hover {{
            background: #45a049;
        }}
        .btn-secondary {{
            background: #2196F3;
            color: white;
        }}
        .btn-secondary:hover {{
            background: #0b7dda;
        }}
        .btn-danger {{
            background: #f44336;
            color: white;
        }}
        .btn-danger:hover {{
            background: #da190b;
        }}
        .btn-group {{
            display: flex;
            gap: 8px;
        }}
        .divider {{
            width: 1px;
            background: #ddd;
            margin: 0 10px;
        }}
        .visibility-panel {{
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.98);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            max-width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }}
        .visibility-panel.show {{
            display: block;
        }}
        .visibility-panel h4 {{
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }}
        .node-list, .edge-list {{
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            margin: 10px 0;
            background: #fafafa;
        }}
        .list-item {{
            padding: 5px 8px;
            margin: 2px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }}
        }}
        .list-item:hover {{
            background: #e3f2fd;
        }}
        .list-item.hidden {{
            opacity: 0.4;
            text-decoration: line-through;
        }}
        .color-indicator {{
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #999;
            display: inline-block;
            margin-right: 5px;
        }}
    </style>
</head>
<body>
    <div id="main-container">
        <div id="controls">
            <!-- Row 1: Node Colors -->
            <div class="control-row">
                <div class="control-group">
                    <label class="control-label">Source</label>
                    <div class="color-input-group">
                        <input type="color" id="sourceColor" value="{self.source_color}">
                        <input type="text" id="sourceColorText" value="{self.source_color}" readonly>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Intermediate</label>
                    <div class="color-input-group">
                        <input type="color" id="intermediateColor" value="{self.intermediate_color}">
                        <input type="text" id="intermediateColorText" value="{self.intermediate_color}" readonly>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Target</label>
                    <div class="color-input-group">
                        <input type="color" id="targetColor" value="{self.target_color}">
                        <input type="text" id="targetColorText" value="{self.target_color}" readonly>
                    </div>
                </div>
            </div>
            
            <!-- Row 2: Metric Selection & Edge Settings -->
            <div class="control-row">
                <div class="control-group">
                    <label class="control-label">Connection Metric</label>
                    <div class="color-input-group">
                        <select id="metricSelect" style="padding: 5px 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 12px;">
                            <option value="weight">Synapse Count</option>
                            <option value="ratio" {"disabled" if not has_ratios else ""}>Connection Ratio{" (N/A)" if not has_ratios else ""}</option>
                            <option value="prob" {"disabled" if not has_probs else ""}>Traversal Probability{" (N/A)" if not has_probs else ""}</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Edge Color</label>
                    <div class="color-input-group">
                        <input type="color" id="edgeColor" value="{edge_hex}">
                        <input type="text" id="edgeColorText" value="{edge_hex}" readonly>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Edge Opacity</label>
                    <div class="color-input-group">
                        <input type="range" id="edgeOpacity" min="0" max="100" value="{int(edge_opacity * 100)}">
                        <span class="slider-value" id="edgeOpacityValue">{int(edge_opacity * 100)}%</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Node Width</label>
                    <div class="color-input-group">
                        <input type="range" id="nodeWidth" min="1" max="50" value="5">
                        <span class="slider-value" id="nodeWidthValue">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Font Size</label>
                    <div class="color-input-group">
                        <input type="range" id="fontSize" min="8" max="20" value="12">
                        <span class="slider-value" id="fontSizeValue">12px</span>
                    </div>
                </div>
            </div>
            
            <!-- Row 3: Action Buttons -->
            <div class="control-row">
                <div class="btn-group">
                    <button class="btn-primary" onclick="applyColors()">Apply</button>
                    <button class="btn-secondary" onclick="resetToDefaults()">Reset</button>
                    <button class="btn-secondary" onclick="toggleVisibilityPanel()">Show/Hide</button>
                </div>
                
                <div class="btn-group">
                    <button class="btn-secondary" onclick="zoomIn()">üîç +</button>
                    <button class="btn-secondary" onclick="zoomOut()">üîç -</button>
                    <button class="btn-secondary" onclick="resetZoom()">‚ü≤</button>
                    <button class="btn-secondary" onclick="toggleLabels()">üè∑Ô∏è Labels</button>
                </div>
                
                <div class="btn-group">
                    <label style="font-size: 12px; margin-right: 5px;">Scale:</label>
                    <input type="number" id="exportScale" min="1" max="10" value="2" step="0.5" style="width: 50px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
                    <button class="btn-secondary" onclick="exportPNG()" title="Export PNG">üì∏ PNG</button>
                    <button class="btn-secondary" onclick="exportSVG()" title="Export SVG">üé® SVG</button>
                </div>
            </div>
        </div>
        
        <div id="sankey-container">
            {plotly_div}
            
            <div id="visibility-panel" class="visibility-panel">
                <h4>üëÅÔ∏è Visibility Controls</h4>
                <div>
                    <strong style="font-size: 12px;">Nodes</strong>
                    <div class="node-list" id="nodeList"></div>
                </div>
                <div>
                    <strong style="font-size: 12px;">Edges</strong>
                    <div class="edge-list" id="edgeList"></div>
                </div>
                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-secondary" onclick="showAll()">Show All</button>
                    <button class="btn-danger" onclick="hideAll()">Hide All</button>
                </div>
            </div>
        </div>
    </div>
                <div class="slider-value" id="edgeOpacityValue">{int(edge_opacity * 100)}%</div>
            </div>
    
    <script>
        // Store original data
        const nodeList = {node_list};
        const nodeLabels = {node_labels};
        const nodeColors = {node_colors_list};
        const sourceIndices = {source_indices};
        const targetIndices = {target_indices};
        const weights = {weights};
        const ratios = {ratios};
        const probs = {probs};
        const originalWeights = {original_weights};  // Original (possibly negative) weights
        const hasRatios = {str(has_ratios).lower()};
        const hasProbs = {str(has_probs).lower()};
        
        // Current metric being displayed
        let currentMetric = 'weight';
        
        // Store node types
        const nodeTypes = [];
        nodeLabels.forEach((label, idx) => {{
            if (nodeColors[idx] === '{self.source_color}') nodeTypes.push('source');
            else if (nodeColors[idx] === '{self.target_color}') nodeTypes.push('target');
            else nodeTypes.push('intermediate');
        }});
        
        // Track visibility
        let hiddenNodes = new Set();
        let hiddenEdges = new Set();
        
        // Toggle visibility panel
        function toggleVisibilityPanel() {{
            const panel = document.getElementById('visibility-panel');
            panel.classList.toggle('show');
        }}
        
        // Initialize UI
        function initializeLists() {{
            const nodeListEl = document.getElementById('nodeList');
            nodeLabels.forEach((label, idx) => {{
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `<span><span class="color-indicator" style="background: ${{nodeColors[idx]}}"></span>${{label}}</span>`;
                item.onclick = () => toggleNode(idx);
                item.id = `node-item-${{idx}}`;
                nodeListEl.appendChild(item);
            }});
            
            const edgeListEl = document.getElementById('edgeList');
            sourceIndices.forEach((src, idx) => {{
                const item = document.createElement('div');
                item.className = 'list-item';
                const metricDisplay = getMetricDisplay(idx);
                item.innerHTML = `<span>${{nodeList[src]}} ‚Üí ${{nodeList[targetIndices[idx]]}}</span><span style="color: #999;" id="edge-metric-${{idx}}">${{metricDisplay}}</span>`;
                item.onclick = () => toggleEdge(idx);
                item.id = `edge-item-${{idx}}`;
                edgeListEl.appendChild(item);
            }});
        }}
        
        // Get metric display string for an edge
        function getMetricDisplay(idx) {{
            if (currentMetric === 'ratio') {{
                return ratios[idx].toFixed(4);
            }} else if (currentMetric === 'prob') {{
                return probs[idx].toFixed(4);
            }} else {{
                return weights[idx];
            }}
        }}
        
        // Update edge list metric values
        function updateEdgeListMetrics() {{
            sourceIndices.forEach((src, idx) => {{
                const metricEl = document.getElementById(`edge-metric-${{idx}}`);
                if (metricEl) {{
                    metricEl.textContent = getMetricDisplay(idx);
                }}
            }});
        }}
        
        // Toggle node visibility
        function toggleNode(idx) {{
            const item = document.getElementById(`node-item-${{idx}}`);
            if (hiddenNodes.has(idx)) {{
                hiddenNodes.delete(idx);
                item.classList.remove('hidden');
            }} else {{
                hiddenNodes.add(idx);
                item.classList.add('hidden');
            }}
            updateDiagram();
        }}
        
        // Toggle edge visibility
        function toggleEdge(idx) {{
            const item = document.getElementById(`edge-item-${{idx}}`);
            if (hiddenEdges.has(idx)) {{
                hiddenEdges.delete(idx);
                item.classList.remove('hidden');
            }} else {{
                hiddenEdges.add(idx);
                item.classList.add('hidden');
            }}
            updateDiagram();
        }}
        
        // Show all
        function showAll() {{
            hiddenNodes.clear();
            hiddenEdges.clear();
            document.querySelectorAll('.list-item').forEach(item => item.classList.remove('hidden'));
            updateDiagram();
        }}
        
        // Hide all
        function hideAll() {{
            nodeLabels.forEach((_, idx) => hiddenNodes.add(idx));
            sourceIndices.forEach((_, idx) => hiddenEdges.add(idx));
            document.querySelectorAll('.list-item').forEach(item => item.classList.add('hidden'));
            updateDiagram();
        }}
        
        // Update color inputs
        document.getElementById('sourceColor').addEventListener('input', (e) => {{
            document.getElementById('sourceColorText').value = e.target.value;
        }});
        document.getElementById('intermediateColor').addEventListener('input', (e) => {{
            document.getElementById('intermediateColorText').value = e.target.value;
        }});
        document.getElementById('targetColor').addEventListener('input', (e) => {{
            document.getElementById('targetColorText').value = e.target.value;
        }});
        document.getElementById('edgeColor').addEventListener('input', (e) => {{
            document.getElementById('edgeColorText').value = e.target.value;
        }});
        document.getElementById('edgeOpacity').addEventListener('input', (e) => {{
            document.getElementById('edgeOpacityValue').textContent = e.target.value + '%';
        }});
        document.getElementById('nodeWidth').addEventListener('input', (e) => {{
            document.getElementById('nodeWidthValue').textContent = e.target.value;
            updateDiagram();  // Update immediately when slider changes
        }});
        document.getElementById('fontSize').addEventListener('input', (e) => {{
            document.getElementById('fontSizeValue').textContent = e.target.value + 'px';
            updateDiagram();  // Update immediately when slider changes
        }});
        document.getElementById('metricSelect').addEventListener('change', (e) => {{
            currentMetric = e.target.value;
            updateEdgeListMetrics();  // Update edge list display
            updateDiagram();  // Redraw with new metric
        }});
        
        // Apply colors
        function applyColors() {{
            const sourceColor = document.getElementById('sourceColor').value;
            const intermediateColor = document.getElementById('intermediateColor').value;
            const targetColor = document.getElementById('targetColor').value;
            
            // Update node colors based on type
            nodeLabels.forEach((label, idx) => {{
                if (nodeTypes[idx] === 'source') nodeColors[idx] = sourceColor;
                else if (nodeTypes[idx] === 'target') nodeColors[idx] = targetColor;
                else nodeColors[idx] = intermediateColor;
            }});
            
            // Update color indicators in list
            document.querySelectorAll('.color-indicator').forEach((el, idx) => {{
                el.style.background = nodeColors[idx];
            }});
            
            updateDiagram();
        }}
        
        // Reset to defaults
        function resetToDefaults() {{
            document.getElementById('sourceColor').value = '{self.source_color}';
            document.getElementById('sourceColorText').value = '{self.source_color}';
            document.getElementById('intermediateColor').value = '{self.intermediate_color}';
            document.getElementById('intermediateColorText').value = '{self.intermediate_color}';
            document.getElementById('targetColor').value = '{self.target_color}';
            document.getElementById('targetColorText').value = '{self.target_color}';
            document.getElementById('edgeColor').value = '{edge_hex}';
            document.getElementById('edgeColorText').value = '{edge_hex}';
            document.getElementById('edgeOpacity').value = {int(edge_opacity * 100)};
            document.getElementById('edgeOpacityValue').textContent = '{int(edge_opacity * 100)}%';
            document.getElementById('nodeWidth').value = 5;
            document.getElementById('nodeWidthValue').textContent = '5';
            document.getElementById('fontSize').value = 12;
            document.getElementById('fontSizeValue').textContent = '12px';
            
            // Reset node colors
            nodeLabels.forEach((label, idx) => {{
                if (nodeTypes[idx] === 'source') nodeColors[idx] = '{self.source_color}';
                else if (nodeTypes[idx] === 'target') nodeColors[idx] = '{self.target_color}';
                else nodeColors[idx] = '{self.intermediate_color}';
            }});
            
            showAll();
        }}
        
        // Update diagram with current settings
        function updateDiagram() {{
            const edgeColor = document.getElementById('edgeColor').value;
            const edgeOpacity = document.getElementById('edgeOpacity').value / 100;
            const nodeWidth = parseInt(document.getElementById('nodeWidth').value);
            
            // Create new data arrays with visibility applied
            const visibleNodeColors = nodeColors.map((color, idx) => 
                hiddenNodes.has(idx) ? 'rgba(200,200,200,0.1)' : color
            );
            
            const visibleNodeLabels = nodeLabels.map((label, idx) => {{
                if (hiddenNodes.has(idx)) return '';
                if (!labelsVisible) return '';  // Hide labels when toggled off
                return label;
            }});
            
            const visibleSourceIndices = [];
            const visibleTargetIndices = [];
            const visibleWeights = [];
            const visibleLinkColors = [];
            const visibleHoverText = [];
            
            // Get current metric values
            let metricValues;
            if (currentMetric === 'ratio') {{
                metricValues = ratios;
            }} else if (currentMetric === 'prob') {{
                metricValues = probs;
            }} else {{
                metricValues = weights;
            }}
            
            // Metric display name for hover text
            const metricDisplayName = (currentMetric === 'ratio') ? 'Ratio' : (currentMetric === 'prob' ? 'Probability' : 'Synapses');
            
            sourceIndices.forEach((src, idx) => {{
                const tgt = targetIndices[idx];
                if (hiddenEdges.has(idx) || hiddenNodes.has(src) || hiddenNodes.has(tgt)) {{
                    // Make edge nearly invisible
                    visibleSourceIndices.push(src);
                    visibleTargetIndices.push(tgt);
                    visibleWeights.push(0.001);  // Tiny value
                    visibleLinkColors.push('rgba(200,200,200,0.05)');
                    visibleHoverText.push('');
                }} else {{
                    visibleSourceIndices.push(src);
                    visibleTargetIndices.push(tgt);
                    
                    // Use selected metric value
                    const metricValue = metricValues[idx];
                    // For ratio and prob, scale them for better visualization (multiply by a factor)
                    const scaledValue = (currentMetric === 'ratio' || currentMetric === 'prob') 
                        ? metricValue * 1000  // Scale up for better visibility
                        : metricValue;
                    visibleWeights.push(scaledValue);
                    
                    // Build custom hover text with ORIGINAL (unscaled) values
                    const valueStr = (currentMetric === 'ratio' || currentMetric === 'prob') 
                        ? metricValue.toFixed(4)
                        : Math.round(metricValue).toLocaleString();
                    const hoverStr = '<b>Source:</b> ' + nodeLabels[src] + '<br><b>Target:</b> ' + nodeLabels[tgt] + '<br><b>' + metricDisplayName + ':</b> ' + valueStr;
                    visibleHoverText.push(hoverStr);
                    
                    // Determine edge color based on whether it's negative
                    const isNegative = originalWeights[idx] < 0;
                    let r, g, b;
                    
                    if (isNegative) {{
                        // Light blue for negative edges: #4A90E2 = rgb(74, 144, 226)
                        r = 74;
                        g = 144;
                        b = 226;
                    }} else {{
                        // Use selected edge color for positive edges
                        r = parseInt(edgeColor.substr(1,2), 16);
                        g = parseInt(edgeColor.substr(3,2), 16);
                        b = parseInt(edgeColor.substr(5,2), 16);
                    }}
                    
                    visibleLinkColors.push(`rgba(${{r}},${{g}},${{b}},${{edgeOpacity}})`);
                }}
            }});

            // Get current font size
            const fontSize = parseInt(document.getElementById('fontSize').value);
            
            // Build title with simplification note if applicable
            let title = 'Sankey diagram of pathway connections';
            const simplificationApplied = {str(simplification_applied).lower()};
            const originalEdgeCount = {original_edge_count};
            if (simplificationApplied) {{
                title += '<br><sub style="font-size: 0.8em; color: #e67e22;">‚ö†Ô∏è Simplified: Showing top ' + {len(weights)} + ' of ' + originalEdgeCount + ' edges by weight</sub>';
            }}

            Plotly.react(
                document.querySelector('.plotly-graph-div'),
                [{{
                    type: 'sankey',
                    node: {{
                        pad: 5,
                        thickness: nodeWidth,
                        line: {{ color: "black", width: 0 }},
                        label: visibleNodeLabels,
                        color: visibleNodeColors
                    }},
                    link: {{
                        source: visibleSourceIndices,
                        target: visibleTargetIndices,
                        value: visibleWeights,
                        color: visibleLinkColors,
                        customdata: visibleHoverText,
                        hovertemplate: '%{{customdata}}<extra></extra>'
                    }}
                }}],
                {{
                    title: {{
                        text: title,
                        font: {{ size: fontSize }}
                    }},
                    font: {{ size: fontSize }},
                    hoverlabel: {{
                        align: 'left',
                        namelength: -1,
                        font: {{ size: 14, family: 'Arial, sans-serif' }},
                        bgcolor: 'rgba(255, 255, 255, 0.95)',
                        bordercolor: '#333',
                        pad: 15
                    }}
                }}
            );
        }}
        
        // Zoom functionality
        let zoomLevel = 0.7;  // Start zoomed out to see full diagram
        const zoomStep = 0.2;
        const minZoom = 0.3;
        const maxZoom = 3.0;
        
        function zoomIn() {{
            zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
            applyZoom();
        }}
        
        function zoomOut() {{
            zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
            applyZoom();
        }}
        
        function resetZoom() {{
            zoomLevel = 1.0;
            applyZoom();
        }}
        
        function applyZoom() {{
            const container = document.querySelector('#sankey-container > div');
            if (container) {{
                container.style.transform = `scale(${{zoomLevel}})`;
                container.style.transformOrigin = 'center center';
            }}
        }}
        
        // Label toggle functionality
        let labelsVisible = true;
        
        function toggleLabels() {{
            labelsVisible = !labelsVisible;
            updateDiagram();
        }}
        
        // Export functions
        function exportPNG() {{
            const MAX_SAFE_SCALE = 4;
            let scale = parseFloat(document.getElementById('exportScale').value) || 2;
            // Warn / cap large scales to avoid browser OOM or failures
            if (scale > MAX_SAFE_SCALE) {{
                const proceed = confirm(`Exporting at ${{scale}}√ó may fail in your browser (very large image).\n\nClick OK to attempt the requested ${{scale}}√ó export, or Cancel to export at a safer ${{MAX_SAFE_SCALE}}√ó.`);
                if (!proceed) {{
                    scale = MAX_SAFE_SCALE;
                }}
            }}

            const gd = document.querySelector('.plotly-graph-div');

            try {{
                Plotly.toImage(gd, {{
                    format: 'png',
                    width: gd.offsetWidth * scale,
                    height: gd.offsetHeight * scale,
                    scale: scale
                }}).then(function(dataUrl) {{
                    const link = document.createElement('a');
                    link.download = `sankey_diagram_${{scale}}x.png`;
                    link.href = dataUrl;
                    link.click();
                    console.log(`PNG exported at ${{scale}}x scale with transparent background`);
                }}).catch(function(error) {{
                    console.error('PNG export failed:', error);
                    alert('PNG export failed. Try exporting SVG or lowering the scale (‚â§4). See console for details.');
                }});
            }} catch (err) {{
                console.error('PNG export failed (synchronous error):', err);
                alert('PNG export failed. Try exporting SVG or lowering the scale (‚â§4). See console for details.');
            }}
        }}
        
        function exportSVG() {{
            const gd = document.querySelector('.plotly-graph-div');
            
            Plotly.toImage(gd, {{
                format: 'svg',
                width: gd.offsetWidth,
                height: gd.offsetHeight
            }}).then(function(dataUrl) {{
                const link = document.createElement('a');
                link.download = 'sankey_diagram.svg';
                link.href = dataUrl;
                link.click();
                console.log('SVG exported with transparent background');
            }}).catch(function(error) {{
                console.error('SVG export failed:', error);
                alert('SVG export failed. Please try again.');
            }});
        }}
        
        // Initialize on load
        initializeLists();
        applyZoom();  // Apply initial zoom level
        updateDiagram();  // Initialize diagram with JavaScript control
    </script>
</body>
</html>"""
        
        return html
    
    def create_network(self):
        """
        Create interactive Cytoscape.js network visualization.
        
        Creates a fully interactive network graph with:
        - Draggable nodes
        - Hover tooltips showing weight/ratio/probability
        - Right-click to hide nodes
        - Keyboard shortcut (H) to hide selected nodes
        - Export to PNG functionality
        
        Returns
        -------
        str
            Path to the generated HTML file
            
        Notes
        -----
        - Layout algorithm specified by network_layout parameter
        - Edge thickness represents connection weight
        - Node colors follow node_type (source/intermediate/target)
        """
        if self.G_network is None:
            self.build_network()
        
        print("\nCreating interactive network visualization...")
        
        output_path = os.path.join(self.output_folder, self.base_filename + '_network.html')
        
        self._plot_cytoscape_network(
            self.G_network,
            output_path=output_path,
            layout=self.network_layout
        )
        
        print(f"Network graph saved: {output_path}")
        
        return output_path
    
    def generate_empty_network_html(self):
        """
        Generate an empty network HTML template without any data.
        
        Creates a blank interactive network visualization that can be used as a
        template or populated later with custom data via JavaScript.
        
        Returns
        -------
        str
            Path to the generated empty network HTML file
            
        Notes
        -----
        - Creates a minimal Cytoscape.js network with no nodes or edges
        - Includes all interactive controls (layout, filters, export)
        - Useful for creating templates or testing the visualization interface
        - The HTML includes JavaScript code to dynamically add nodes/edges
        
        Examples
        --------
        >>> vp = VisualizePath(path_file=None, generate_empty_network=True)
        >>> vp.generate_empty_network_html()
        'empty_network/empty_network_20251109_143052_network.html'
        """
        print("\nGenerating empty network HTML template...")
        print(f"  Filename: {self.base_filename}_network.html")
        
        # Create an empty NetworkX graph
        G = nx.DiGraph()
        
        output_path = os.path.join(self.output_folder, self.base_filename + '_network.html')
        
        # Use the existing method with an empty graph
        self._plot_cytoscape_network(
            G,
            output_path=output_path,
            layout=self.network_layout
        )
        
        print(f"‚úì Empty network HTML generated: {output_path}")
        print(f"  Timestamp ensures unique filename for each generation")
        print(f"  This template includes all interactive controls")
        print(f"  You can populate it with custom nodes/edges via JavaScript")
        
        if self.showfig:
            webbrowser.open('file://' + os.path.abspath(output_path))
        
        return output_path
    
    def _calculate_edge_widths(self, weights):
        """
        Calculate edge widths from weights using specified scaling method.
        
        Parameters
        ----------
        weights : list or np.ndarray
            Edge weights to scale
            
        Returns
        -------
        list
            Scaled edge widths
        """
        weights = np.array(weights, dtype=float)
        
        # Handle zero or negative weights
        weights = np.maximum(weights, 1e-6)
        
        if self.edge_width_scale == 'linear':
            # Linear scaling: width ‚àù weight
            scaled = weights
        elif self.edge_width_scale == 'log':
            # Logarithmic scaling: width ‚àù log_base(weight)
            if self.edge_width_log_base == 'e' or self.edge_width_log_base is None:
                # Natural logarithm (base e)
                scaled = np.log(weights + 1)  # +1 to avoid log(0)
            else:
                # Custom base: log_b(x) = ln(x) / ln(b)
                log_base = float(self.edge_width_log_base)
                if log_base <= 1:
                    print(f"Warning: Invalid log base {log_base}, using natural log (e)")
                    scaled = np.log(weights + 1)
                else:
                    scaled = np.log(weights + 1) / np.log(log_base)
        elif self.edge_width_scale == 'sqrt':
            # Square root scaling: width ‚àù ‚àöweight
            scaled = np.sqrt(weights)
        elif self.edge_width_scale == 'none':
            # No scaling: constant width
            scaled = np.ones_like(weights)
        else:
            # Default to log if unknown method
            print(f"Warning: Unknown edge_width_scale '{self.edge_width_scale}', using 'log'")
            scaled = np.log(weights + 1)
        
        # Apply multiplier factor
        scaled = scaled * self.edge_width_factor
        
        return scaled.tolist()
    
    def _plot_cytoscape_network(self, G, output_path, layout='hierarchical'):
        """
        Create Cytoscape.js network visualization (internal method).
        
        Parameters
        ----------
        G : networkx.DiGraph
            Network graph to visualize
        output_path : str
            Path to save HTML file
        layout : str
            Layout algorithm: 'hierarchical', 'spring', 'circular', 'distributed'
        """
        # Prepare node data
        nodes_data = []
        for node in G.nodes():
            node_type = G.nodes[node].get('node_type', 'intermediate')
            
            # Assign color based on node type
            if node_type == 'source':
                color = self.node_color[0]
            elif node_type == 'target':
                color = self.target_color
            else:  # intermediate
                color = self.node_color[1]
            
            nodes_data.append({
                'data': {
                    'id': node,
                    'label': node,
                    'node_type': node_type,
                    'color': color
                },
                'position': {},  # Will be set by layout
                'classes': ''  # For CSS classes
            })
        
        # Prepare edge data
        edges_data = []
        edge_weights = []  # Collect weights for scaling
        has_negative = False  # Track if any negative weights exist
        
        for source, target, data in G.edges(data=True):
            weight = data.get('weight', 0)
            is_negative = weight < 0
            if is_negative:
                has_negative = True
            
            # Convert all to positive for plotting (avoid Cytoscape issues)
            abs_weight = abs(weight)
            edge_weights.append(abs_weight)
            ratio = data.get('ratio', np.nan)
            prob = data.get('probability', np.nan)
            
            # Format tooltip - use actual newline character, not escaped
            tooltip_parts = [f"Weight: {weight:,}"]
            if not np.isnan(ratio):
                tooltip_parts.append(f"Ratio: {ratio:.3f}")
            if not np.isnan(prob):
                tooltip_parts.append(f"Probability: {prob:.3f}")
            tooltip = "\n".join(tooltip_parts)  # Use actual newline, not escaped
            
            edges_data.append({
                'data': {
                    'source': source,
                    'target': target,
                    'weight': abs_weight,  # Store positive for Cytoscape
                    'original_weight': weight,  # Store original for hover modification
                    'is_negative': 1 if is_negative else 0,  # Use 1/0 instead of True/False for JavaScript
                    'ratio': ratio if not np.isnan(ratio) else 0,
                    'probability': prob if not np.isnan(prob) else 0,
                    'tooltip': tooltip
                }
            })
        
        if has_negative:
            print(f"  ‚ÑπÔ∏è  Found negative edge weights - using absolute values for width, light blue color for negative edges")
        
        # Calculate scaled edge widths
        scaled_widths = self._calculate_edge_widths(edge_weights)
        
        # Add scaled width to each edge
        for i, edge in enumerate(edges_data):
            edge['data']['scaled_width'] = scaled_widths[i]
        
        # Calculate min and max scaled widths for mapData function
        min_scaled_width = min(scaled_widths) if scaled_widths else 1
        max_scaled_width = max(scaled_widths) if scaled_widths else 10
        
        # Extract output name and add timestamp for unique storage key
        import os
        from datetime import datetime
        output_name = os.path.splitext(os.path.basename(output_path))[0]
        timestamp_hash = datetime.now().strftime('%Y%m%d%H%M%S')
        storage_key = f"cytoscape_layout_{output_name}#{timestamp_hash}"
        
        # Map layout names to Cytoscape.js layout algorithms
        layout_map = {
            'hierarchical': 'dagre',        # Dagre - Best for hierarchical graphs (crossing minimization)
            'spring': 'cose',               # CoSE - Force-directed layout
            'circular': 'circle',           # Circular layout
            'distributed': 'dagre',         # Changed to Dagre (better for pathway networks)
            'dagre': 'dagre',               # Dagre (Sugiyama algorithm)
            'cose-bilkent': 'cose-bilkent', # CoSE Bilkent - Better quality force-directed
            'fcose': 'fcose',               # fCoSE - Fast CoSE with quality
            'klay': 'klay',                 # KLay - Layer-based layout (like dagre)
            'elk': 'elk'                    # ELK - Eclipse Layout Kernel
        }
        cytoscape_layout = layout_map.get(layout, 'dagre')
        
        # Create HTML content
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Neural Pathway Network - Selected Paths</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    
    <!-- Layout Extensions -->
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    
    <!-- CoSE-based layouts (need dependencies) -->
    <script src="https://unpkg.com/layout-base@1.0.2/layout-base.js"></script>
    <script src="https://unpkg.com/cose-base@1.0.3/cose-base.js"></script>
    <script src="https://unpkg.com/cytoscape-cose-bilkent@4.1.0/cytoscape-cose-bilkent.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
    
    <!-- KLay layout -->
    <script src="https://unpkg.com/klayjs@0.4.1/klay.js"></script>
    <script src="https://unpkg.com/cytoscape-klay@3.1.4/cytoscape-klay.js"></script>
    
    <!-- Export Extensions -->
    <script src="https://unpkg.com/cytoscape-svg@0.4.0/cytoscape-svg.js"></script>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }}
        #cy {{
            width: 100%;
            height: 90vh;
            background: white;
            border: 1px solid #ddd;
            position: relative;
            overflow: hidden;
        }}
        .controls {{
            padding: 15px;
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }}
        .btn {{
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
            width: 100%;
            text-align: center;
        }}
        .btn:hover {{
            background: #45a049;
        }}
        .btn.secondary {{
            background: #2196F3;
        }}
        .btn.secondary:hover {{
            background: #0b7dda;
        }}
        .slider-container {{
            display: flex;
            align-items: center;
            gap: 10px;
        }}
        .slider-container label {{
            font-size: 13px;
            color: #666;
            min-width: 80px;
        }}
        .slider-container input[type="range"] {{
            width: 120px;
        }}
        .slider-container span {{
            font-size: 13px;
            font-weight: bold;
            min-width: 35px;
        }}
        .info {{
            color: #666;
            font-size: 14px;
            text-align: left;
        }}
        .legend {{
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
            font-size: 13px;
            margin: 10px 0;
        }}
        .legend-item {{
            display: flex;
            align-items: center;
            gap: 8px;
        }}
        .legend-color {{
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }}
        .hidden {{
            display: none;
        }}
        
        /* Hover Info Box - Fixed at bottom-left */
        #hoverInfo {{
            position: fixed;
            bottom: 15px;
            left: 15px;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            line-height: 1.6;
            max-width: 400px;
            border: 1px solid rgba(0,0,0,0.1);
        }}
        #hoverInfo b {{
            color: #000;
            font-weight: 600;
        }}
        
        /* Main layout: network + right-side menubar */
        .main {{
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 0;
            align-items: stretch;  /* Stretch to full height */
            height: calc(100vh - 0px);  /* Full viewport height minus controls */
            margin: 0;
            width: 100%;
            box-sizing: border-box;
        }}

        .color-palette {{
            position: fixed;  /* Fixed positioning to overlay everything */
            top: 0;  /* Start from very top of page */
            right: 0;  /* Anchor to right side */
            background: white;
            border-left: 2px solid #eee;
            padding: 15px;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);  /* Add shadow for depth */
            z-index: 1000;  /* High z-index to overlay controls */
            height: 100vh;  /* Full viewport height */
            overflow-y: auto;
            width: 280px;
            box-sizing: border-box; /* include border/padding in width calculations */
        }}
        .color-palette h3 {{
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }}
        .palette-section {{
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }}
        .palette-section:last-child {{
            border-bottom: none;
        }}
        .palette-section h4 {{
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
        }}
        .color-group {{
            margin-bottom: 12px;
        }}
        .color-group label {{
            display: block;
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }}
        .color-input-group {{
            display: flex;
            gap: 5px;
            align-items: center;
        }}
        .color-input-group input[type="color"] {{
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }}
        .color-input-group input[type="text"] {{
            width: 70px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
        }}
        .color-input-group input[type="range"] {{
            width: 80px;
        }}
        .color-input-group select {{
            width: 130px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            background: white;
            cursor: pointer;
        }}
        .alpha-value {{
            font-size: 11px;
            color: #666;
            min-width: 35px;
        }}
        .font-select {{
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
        }}
        .apply-btn {{
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }}
        .apply-btn:hover {{
            background: #45a049;
        }}
        .selected-info {{
            background: #f0f8ff;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 11px;
            color: #333;
        }}
        .selected-info strong {{
            color: #2196F3;
        }}
        .clear-selection-btn {{
            width: 100%;
            padding: 6px;
            margin-top: 5px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }}
        .clear-selection-btn:hover {{
            background: #f57c00;
        }}
    </style>
</head>
<body>
    <div class="controls">
        <!-- Layout Controls -->
        <div style="padding: 10px; background: #e3f2fd; border-radius: 5px; margin-bottom: 8px;">
            <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #1976d2;">üìê Layout</h4>
            
            <!-- Control Buttons -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                <button class="btn" onclick="resetLayout()" style="background: #4caf50; font-size: 12px; padding: 6px; width: 100%;">üîÑ Reset</button>
                <button class="btn" onclick="fitGraph()" style="background: #2196f3; font-size: 12px; padding: 6px; width: 100%;">‚õ∂ Fit</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                <button class="btn secondary" id="toggleLabelsBtn" onclick="toggleLabels()" style="font-size: 12px; padding: 6px; width: 100%;">üëÅÔ∏è Hide Labels</button>
                <button class="btn" id="showAllBtn" onclick="showAllNodes()" style="background: #ff9800; font-size: 12px; padding: 6px; width: 100%; display: none;">üëÅÔ∏è Show All</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 8px;">
                <button class="btn" onclick="refreshEdgeStyles()" style="background: #9c27b0; font-size: 12px; padding: 6px; width: 100%;">üîÑ Refresh Edges</button>
            </div>
            
            <!-- Save/Load -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; padding-top: 8px; border-top: 1px solid #ddd;">
                <button class="btn" onclick="saveLayout()" style="background: #4caf50; font-size: 12px; padding: 6px; width: 100%;">üíæ Save</button>
                <button class="btn" onclick="loadLayout()" style="background: #2196f3; font-size: 12px; padding: 6px; width: 100%;">üìÇ Load</button>
            </div>
            <div id="layoutStatus" style="font-size: 11px; color: #666; min-height: 18px; margin-top: 8px; text-align: center;"></div>
        </div>
        
        <!-- Layout Algorithm Selector -->
        <div style="padding: 10px; background: #fff3e0; border-radius: 5px; margin-bottom: 8px; max-width: 185px;">
            <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #e65100;">üîß Layout Algorithm</h4>
            <select id="layoutSelector" onchange="changeLayout()" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; background: white; cursor: pointer;">
                <optgroup label="üåü Hierarchical">
                    <option value="dagre" {{'selected' if cytoscape_layout == 'dagre' else ''}}>Dagre ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</option>
                    <option value="klay" {{'selected' if cytoscape_layout == 'klay' else ''}}>KLay ‚≠ê‚≠ê‚≠ê‚≠ê</option>
                    <option value="breadthfirst" {{'selected' if cytoscape_layout == 'breadthfirst' else ''}}>Breadth-First ‚≠ê‚≠ê‚≠ê</option>
                </optgroup>
                <optgroup label="üéØ Force-Directed">
                    <option value="fcose" {{'selected' if cytoscape_layout == 'fcose' else ''}}>fCoSE ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</option>
                    <option value="cose-bilkent" {{'selected' if cytoscape_layout == 'cose-bilkent' else ''}}>CoSE-Bilkent ‚≠ê‚≠ê‚≠ê‚≠ê</option>
                    <option value="cose" {{'selected' if cytoscape_layout == 'cose' else ''}}>CoSE ‚≠ê‚≠ê‚≠ê</option>
                </optgroup>
                <optgroup label="üìê Other">
                    <option value="circle" {{'selected' if cytoscape_layout == 'circle' else ''}}>Circular ‚≠ê‚≠ê</option>
                    <option value="grid" {{'selected' if cytoscape_layout == 'grid' else ''}}>Grid ‚≠ê‚≠ê</option>
                    <option value="concentric" {{'selected' if cytoscape_layout == 'concentric' else ''}}>Concentric ‚≠ê‚≠ê</option>
                </optgroup>
            </select>
            <div id="layoutInfo" style="font-size: 10px; color: #666; margin-top: 8px; line-height: 1.4; word-wrap: break-word; white-space: normal;">
                üí° Dagre uses Sugiyama's algorithm for optimal edge crossing minimization in hierarchical graphs
            </div>
        </div>
        
        <!-- Three-column layout for controls -->
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 15px 0;">
            <!-- Column 1: Edge Controls -->
            <div style="padding: 10px; background: #f5f5f5; border-radius: 5px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Connection Metric:</label>
                    <select id="metricSelect" onchange="updateMetric()" style="width: 100%; padding: 5px;">
                        <option value="weight">Synapse Count</option>
                        <option value="ratio">Connection Ratio</option>
                        <option value="probability">Traversal Probability</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Edge Width Scale:</label>
                    <select id="edgeWidthScale" onchange="updateEdgeWidths()" style="width: 100%; padding: 5px;">
                        <option value="linear" {'selected' if self.edge_width_scale == 'linear' else ''}>Linear</option>
                        <option value="log_2" {'selected' if self.edge_width_scale == 'log' and str(self.edge_width_log_base) == '2' else ''}>Logarithmic (log‚ÇÇ)</option>
                        <option value="log_10" {'selected' if self.edge_width_scale == 'log' and str(self.edge_width_log_base) == '10' else ''}>Logarithmic (log‚ÇÅ‚ÇÄ)</option>
                        <option value="sqrt" {'selected' if self.edge_width_scale == 'sqrt' else ''}>Square Root</option>
                        <option value="none" {'selected' if self.edge_width_scale == 'none' else ''}>None (Constant)</option>
                    </select>
                </div>
                
                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Hide Edges (weight):</label>
                    <input type="text" id="ignoreEdgesInput" placeholder="e.g., 0, <5, >100" style="width: 100%; padding: 5px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box;" oninput="updateIgnoredEdges()">
                    <div style="font-size: 9px; color: #666; margin-top: 3px; line-height: 1.2;">
                        Comma-separated: 1, &lt;5, &gt;=10, &lt;=20
                    </div>
                </div>
            </div>
            
            <!-- Column 2: Font & Node Controls -->
            <div style="padding: 10px; background: #f5f5f5; border-radius: 5px;">
                <div class="slider-container" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Font Size: <span id="fontSizeValue" style="display: inline-block; min-width: 45px;">12px</span></label>
                    <input type="range" id="fontSizeSlider" min="{self.min_font_size}" max="{self.max_font_size}" value="12" step="1" oninput="updateFontSize(this.value)" style="width: 100%;">
                </div>
                
                <div class="slider-container" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Node Size: <span id="nodeSizeValue" style="display: inline-block; min-width: 45px;">40px</span></label>
                    <input type="range" id="nodeSizeSlider" min="{self.min_node_size}" max="{self.max_node_size}" value="40" step="5" oninput="updateNodeSize(this.value)" style="width: 100%;">
                </div>
                
                <div class="slider-container" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Edge Width: <span id="edgeWidthValue" style="display: inline-block; min-width: 45px;">3px</span></label>
                    <input type="range" id="edgeWidthSlider" min="{self.min_edge_width}" max="{self.max_edge_width}" value="3" step="0.5" oninput="updateEdgeWidth(this.value)" style="width: 100%;">
                </div>
                
                <div class="slider-container">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Arrow Size: <span id="arrowSizeValue" style="display: inline-block; min-width: 45px;">9px</span></label>
                    <input type="range" id="arrowSizeSlider" min="3" max="20" value="9" step="1" oninput="updateArrowSize(this.value)" style="width: 100%;">
                </div>
            </div>
            
            <!-- Column 3: Export Controls -->
            <div style="padding: 10px; background: #f5f5f5; border-radius: 5px;">
                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">üíæ Export</h4>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px;">Image Scale:</label>
                    <input type="number" id="exportScale" min="1" max="10" value="2" step="0.5" style="width: 100%; padding: 5px; box-sizing: border-box;">
                </div>
                
                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                    <button class="btn" onclick="exportPNG()" style="flex: 1; padding: 6px; font-size: 12px;">PNG</button>
                    <button class="btn" onclick="exportSVG()" style="flex: 1; padding: 6px; font-size: 12px;">SVG</button>
                </div>
                
                <div style="display: flex; gap: 6px; margin-bottom: 6px;">
                    <button class="btn" onclick="exportGraph()" style="flex: 1; padding: 6px; font-size: 12px; background: #9c27b0;">üìä Graph</button>
                    <button class="btn" onclick="importGraph()" style="flex: 1; padding: 6px; font-size: 12px; background: #9c27b0;">üìÇ Import</button>
                </div>
                
                <div style="display: flex; gap: 6px;">
                    <button class="btn" onclick="exportLayout()" style="flex: 1; padding: 6px; font-size: 11px; background: #607d8b;">üìç Layout</button>
                    <button class="btn" onclick="importLayout()" style="flex: 1; padding: 6px; font-size: 11px; background: #607d8b;">üìå Apply</button>
                </div>
                
                <input type="file" id="graphFileInput" accept=".json" style="display: none;" onchange="loadGraphFile(event)">
                <input type="file" id="layoutFileInput" accept=".json" style="display: none;" onchange="loadLayoutFile(event)">
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: {self.node_color[0]};"></div>
                <span>Source</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: {self.node_color[1]};"></div>
                <span>Intermediate</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: {self.target_color};"></div>
                <span>Target</span>
            </div>
        </div>
        
        <div class="info">
            <strong>{len(G.nodes())}</strong> nodes, <strong>{len(G.edges())}</strong> connections | 
            Press 'H' to hide nodes, 'E' to hide edges, 'L' to toggle label position | Right-click to hide | 
            <strong>Shift+Click</strong> for multi-selection | Double-click to highlight
        </div>
    </div>
    
    <!-- Color Palette Panel -->
    <div class="main">
        <div id="cy"></div>
        <div class="color-palette" id="colorPalette">
            <div class="palette-content">
                <!-- Edit Mode Section -->
                <div class="palette-section" style="border-bottom: 2px solid #ddd; padding-bottom: 15px; margin-bottom: 15px;">
                    <h3>‚úèÔ∏è Edit Mode</h3>
                    
                    <button class="btn" id="editModeBtn" onclick="toggleEditMode()" style="width: 100%; margin-bottom: 10px; background: #ff9800;">
                        ‚úèÔ∏è Enable Edit Mode
                    </button>
                    
                    <div id="editControls" style="display: none; margin-bottom: 10px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 6px;">
                            <button class="btn" onclick="addNode()" style="font-size: 11px; padding: 6px; background: #4caf50;">‚ûï Node</button>
                            <button class="btn" onclick="deleteSelected()" style="font-size: 11px; padding: 6px; background: #f44336;">üóëÔ∏è Delete</button>
                        </div>
                        <div style="font-size: 10px; color: #666; line-height: 1.3;">
                            ‚Ä¢ Click node ‚Üí drag to connect<br>
                            ‚Ä¢ <strong>Double-click to edit properties</strong><br>
                            ‚Ä¢ Right-click to delete
                        </div>
                    </div>
                </div>
                
                <!-- View Controls Section -->
                <div class="palette-section" style="border-bottom: 2px solid #ddd; padding-bottom: 15px; margin-bottom: 15px;">
                    <h3>üëÅÔ∏è View Controls</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 6px;">
                        <button class="btn" id="hideOrphansBtn" onclick="toggleOrphanNodes()" style="font-size: 11px; padding: 6px; background: #9c27b0;">
                            üëª Hide Orphans
                        </button>
                        <button class="btn" onclick="refreshLayout()" style="font-size: 11px; padding: 6px; background: #00bcd4;">
                            üîÑ Refresh Layout
                        </button>
                    </div>
                    <div style="font-size: 10px; color: #666; line-height: 1.3;">
                        ‚Ä¢ Orphans: nodes with no connections<br>
                        ‚Ä¢ Refresh: re-apply layout after hiding/filtering
                    </div>
                </div>
                
                <h3>üé® Color Settings</h3>
                
                <!-- Individual Selection Section -->
                <div class="palette-section">
                    <h4>Selected Element(s)</h4>
                    <div id="selectedInfo" class="selected-info">
                        Click on a node or edge to customize its color<br>
                        <em>Hold Shift to select multiple elements</em>
                    </div>
                    <div id="individualControls" style="display: none;">
                        <div class="color-group">
                            <label>Color:</label>
                            <div class="color-input-group">
                                <input type="color" id="individualColor" value="#3498db">
                                <input type="text" id="individualColorText" value="#3498db" readonly>
                            </div>
                        </div>
                        <div class="color-group">
                            <label>Opacity:</label>
                            <div class="color-input-group">
                                <input type="range" id="individualOpacity" min="0" max="100" value="100" oninput="updateOpacityDisplay('individual', this.value)">
                                <span class="alpha-value" id="individualOpacityValue">100%</span>
                            </div>
                        </div>
                        <button class="apply-btn" onclick="applyIndividualColor()">Apply to Selected</button>
                        <button class="clear-selection-btn" onclick="clearSelection()">Clear Selection</button>
                    </div>
                </div>
                
                <!-- Node Type Colors Section -->
                <div class="palette-section">
                    <h4>Node Colors by Type</h4>
                    <div class="color-group">
                        <label>Source Nodes:</label>
                        <div class="color-input-group">
                            <input type="color" id="sourceColor" value="{self.node_color[0]}">
                            <input type="text" id="sourceColorText" value="{self.node_color[0]}" readonly>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Source Opacity:</label>
                        <div class="color-input-group">
                            <input type="range" id="sourceOpacity" min="0" max="100" value="{int(self.source_opacity * 100)}" oninput="updateOpacityDisplay('source', this.value)">
                            <span class="alpha-value" id="sourceOpacityValue">{int(self.source_opacity * 100)}%</span>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Intermediate Nodes:</label>
                        <div class="color-input-group">
                            <input type="color" id="intermediateColor" value="{self.node_color[1]}">
                            <input type="text" id="intermediateColorText" value="{self.node_color[1]}" readonly>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Intermediate Opacity:</label>
                        <div class="color-input-group">
                            <input type="range" id="intermediateOpacity" min="0" max="100" value="{int(self.intermediate_opacity * 100)}" oninput="updateOpacityDisplay('intermediate', this.value)">
                            <span class="alpha-value" id="intermediateOpacityValue">{int(self.intermediate_opacity * 100)}%</span>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Target Nodes:</label>
                        <div class="color-input-group">
                            <input type="color" id="targetColor" value="{self.target_color}">
                            <input type="text" id="targetColorText" value="{self.target_color}" readonly>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Target Opacity:</label>
                        <div class="color-input-group">
                            <input type="range" id="targetOpacity" min="0" max="100" value="{int(self.target_opacity * 100)}" oninput="updateOpacityDisplay('target', this.value)">
                            <span class="alpha-value" id="targetOpacityValue">{int(self.target_opacity * 100)}%</span>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Positive Edge Color:</label>
                        <div class="color-input-group">
                            <input type="color" id="edgeColor" value="{self.edge_color}">
                            <input type="text" id="edgeColorText" value="{self.edge_color}" readonly>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Positive Edge Opacity:</label>
                        <div class="color-input-group">
                            <input type="range" id="edgeOpacity" min="0" max="100" value="{int(self.edge_opacity * 100)}" oninput="updateOpacityDisplay('edge', this.value)">
                            <span class="alpha-value" id="edgeOpacityValue">{int(self.edge_opacity * 100)}%</span>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Negative Edge Color:</label>
                        <div class="color-input-group">
                            <input type="color" id="negativeEdgeColor" value="#4A90E2">
                            <input type="text" id="negativeEdgeColorText" value="#4A90E2" readonly>
                        </div>
                    </div>
                    <div class="color-group">
                        <label>Negative Edge Opacity:</label>
                        <div class="color-input-group">
                            <input type="range" id="negativeEdgeOpacity" min="0" max="100" value="100" oninput="updateOpacityDisplay('negativeEdge', this.value)">
                            <span class="alpha-value" id="negativeEdgeOpacityValue">100%</span>
                        </div>
                    </div>
                    <button class="apply-btn" onclick="applyGlobalColors()">Apply to All</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hover Info Display (Bottom-Left) -->
    <div id="hoverInfo">
        üí° <b>Hover over nodes or edges</b> to see details<br>
        <b>Drag nodes</b> to reposition ‚Ä¢ <b>Scroll</b> to zoom ‚Ä¢ <b>Double-click</b> to highlight
    </div>

    <script>
        // Register layout extensions
        if (typeof cytoscape !== 'undefined') {{
            // Register dagre
            if (typeof dagre !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {{
                cytoscape.use(cytoscapeDagre);
            }}
            // Register cose-bilkent
            if (typeof cytoscapeCoseBilkent !== 'undefined') {{
                cytoscape.use(cytoscapeCoseBilkent);
            }}
            // Register fcose
            if (typeof cytoscapeFcose !== 'undefined') {{
                cytoscape.use(cytoscapeFcose);
            }}
            // Register klay
            if (typeof cytoscapeKlay !== 'undefined') {{
                cytoscape.use(cytoscapeKlay);
            }}
        }}
        
        const elements = {{
            nodes: {nodes_data},
            edges: {edges_data}
        }};

        const cy = cytoscape({{
            container: document.getElementById('cy'),
            elements: elements,
            style: [
                {{
                    selector: 'node',
                    style: {{
                        'label': 'data(label)',
                        'background-color': 'data(color)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '12px',
                        'font-family': "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
                        'width': '40px',
                        'height': '40px',
                        'border-width': '0px',  // No border
                        'text-wrap': 'wrap',
                        'text-max-width': '80px'
                    }}
                }},
                {{
                    selector: 'node.labels-outside',
                    style: {{
                        'text-valign': 'bottom',
                        'text-margin-y': '5px'
                    }}
                }},
                {{
                    selector: 'node.labels-hidden',
                    style: {{
                        'label': ''
                    }}
                }},
                {{
                    selector: 'node:selected',
                    style: {{
                        'border-width': '3px',
                        'border-color': '#FFD700'
                    }}
                }},
                {{
                    selector: 'node.hidden',
                    style: {{
                        'display': 'none'
                    }}
                }},
                {{
                    selector: 'node.orphan-hidden',
                    style: {{
                        'display': 'none'
                    }}
                }},
                {{
                    selector: 'edge',
                    style: {{
                        'width': 'mapData(scaled_width, {min_scaled_width}, {max_scaled_width}, 1, 10)',
                        'line-color': '{self.edge_color}',  // Use link_color parameter
                        'target-arrow-color': '{self.edge_color}',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'arrow-scale': 1.5,
                        'label': '',
                        'font-size': '10px',
                        'font-family': "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
                        'text-background-color': '#fff',
                        'text-background-opacity': 0.95,
                        'text-background-padding': '8px',
                        'text-background-shape': 'roundrectangle',
                        'text-border-color': '#999',
                        'text-border-width': 1,
                        'text-border-opacity': 0.5,
                        'text-wrap': 'wrap',
                        'text-max-width': '150px',
                        'text-halign': 'left',
                        'text-valign': 'top',
                        'color': '#000',
                        'text-margin-x': '0px',
                        'text-margin-y': '0px'
                    }}
                }},
                {{
                    selector: 'edge[is_negative = 1]',
                    style: {{
                        'line-color': '#4A90E2',  // Light blue for negative
                        'target-arrow-color': '#4A90E2'
                    }}
                }},
                {{
                    selector: 'edge.hidden',
                    style: {{
                        'display': 'none'
                    }}
                }},
                {{
                    selector: 'edge.filtered',
                    style: {{
                        'display': 'none'
                    }}
                }},
                {{
                    selector: 'edge:selected',
                    style: {{
                        'line-color': '#FFD700',
                        'target-arrow-color': '#FFD700',
                        'width': 'mapData(scaled_width, {min_scaled_width}, {max_scaled_width}, 2, 15)'
                    }}
                }},
                {{
                    selector: 'edge.highlighted',
                    style: {{
                        'line-color': '#FF6B6B',
                        'target-arrow-color': '#FF6B6B',
                        'width': 'mapData(scaled_width, {min_scaled_width}, {max_scaled_width}, 3, 20)',
                        'z-index': 999
                    }}
                }}
            ],
            layout: {{
                name: 'preset'  // Use preset first, then apply proper layout after initialization
            }},
            wheelSensitivity: 0.3,
            minZoom: 0.1,
            maxZoom: 5,
            selectionType: 'single',
            userZoomingEnabled: true,
            userPanningEnabled: true,
            boxSelectionEnabled: true,
            autoungrabify: false,
            autounselectify: false
        }});

        // Initialize layout algorithm variable and configuration function
        let currentLayoutAlgorithm = '{cytoscape_layout}';
        let labelPosition = 'center';  // 'center' or 'outside'
        let labelsVisible = true;
        
        function getLayoutConfig(layoutName) {{
            // Configure layouts with optimal settings for crossing minimization
            const configs = {{
                'dagre': {{
                    name: 'dagre',
                    rankDir: 'TB',              // Top to bottom
                    nodeSep: 50,                // Horizontal spacing between nodes
                    edgeSep: 20,                // Spacing for edges
                    rankSep: 100,               // Vertical spacing between ranks
                    ranker: 'network-simplex',  // Best ranker for crossing minimization
                    animate: false,             // No animation on initial load
                    padding: 50
                }},
                'klay': {{
                    name: 'klay',
                    direction: 'DOWN',
                    nodePlacement: 'BRANDES_KOEPF',
                    edgeRouting: 'ORTHOGONAL',
                    spacing: 50,
                    animate: false,
                    padding: 50
                }},
                'fcose': {{
                    name: 'fcose',
                    quality: 'proof',
                    randomize: false,
                    animate: false,
                    idealEdgeLength: 100,
                    edgeElasticity: 0.45,
                    nestingFactor: 0.1,
                    gravity: 0.25,
                    numIter: 2500,
                    tile: true,
                    padding: 50
                }},
                'cose-bilkent': {{
                    name: 'cose-bilkent',
                    quality: 'proof',
                    randomize: false,
                    animate: false,
                    idealEdgeLength: 100,
                    edgeElasticity: 0.45,
                    nestingFactor: 0.1,
                    gravity: 0.25,
                    numIter: 2500,
                    tile: true,
                    padding: 50
                }},
                'cose': {{
                    name: 'cose',
                    randomize: false,
                    animate: false,
                    idealEdgeLength: 100,
                    nodeOverlap: 20,
                    nodeRepulsion: 400000,
                    edgeElasticity: 100,
                    nestingFactor: 5,
                    gravity: 80,
                    numIter: 1000,
                    padding: 50
                }},
                'breadthfirst': {{
                    name: 'breadthfirst',
                    directed: true,
                    circle: false,
                    grid: false,
                    spacingFactor: 1.75,
                    animate: false,
                    padding: 50
                }},
                'circle': {{
                    name: 'circle',
                    animate: false,
                    padding: 50,
                    spacingFactor: 1.5
                }},
                'grid': {{
                    name: 'grid',
                    animate: false,
                    padding: 50,
                    spacingFactor: 1.5
                }},
                'concentric': {{
                    name: 'concentric',
                    animate: false,
                    padding: 50,
                    spacingFactor: 1.5,
                    minNodeSpacing: 50
                }}
            }};
            
            return configs[layoutName] || configs['dagre'];
        }}
        
        // Set the layout selector to show the current layout
        const layoutSelector = document.getElementById('layoutSelector');
        if (layoutSelector) {{
            layoutSelector.value = currentLayoutAlgorithm;
        }}
        
        // Apply the initial layout using proper configuration
        const initialLayout = getLayoutConfig(currentLayoutAlgorithm);
        cy.layout(initialLayout).run();
        
        // Fix for click position drift - ensure Cytoscape canvas is properly sized
        cy.resize();
        cy.fit();
        
        // Add window resize handler to keep canvas in sync
        window.addEventListener('resize', function() {{
            cy.resize();
        }});
        
        // Initialize edge widths based on current dropdown selection
        // This ensures the correct log base is applied on page load
        setTimeout(function() {{
            updateEdgeWidths();
        }}, 100);

        // Show hover info in bottom-left box (like coana)
        cy.on('mouseover', 'node', function(evt) {{
            const node = evt.target;
            const data = node.data();
            const info = document.getElementById('hoverInfo');
            info.innerHTML = `
                <b>Node:</b> ${{data.label}}<br>
                <b>Type:</b> ${{data.node_type}}<br>
                <b>Color:</b> ${{data.color}}
            `;
        }});

        cy.on('mouseover', 'edge', function(evt) {{
            const edge = evt.target;
            const data = edge.data();
            const source = edge.source().data('label');
            const target = edge.target().data('label');
            const info = document.getElementById('hoverInfo');
            
            // Get display weight (add negative sign if needed)
            const displayWeight = data.is_negative === 1 ? -data.weight : data.weight;
            
            let html = `<b>Connection:</b> ${{source}} ‚Üí ${{target}}<br>`;
            
            // Highlight the current metric
            if (currentMetric === 'weight') {{
                html += `<b>Weight:</b> <span style="color: #4CAF50; font-weight: bold;">${{displayWeight.toLocaleString()}} synapses ‚¨Ö Current</span>`;
            }} else {{
                html += `<b>Weight:</b> ${{displayWeight.toLocaleString()}} synapses`;
            }}
            
            if (data.ratio && !isNaN(data.ratio)) {{
                if (currentMetric === 'ratio') {{
                    html += `<br><b>Ratio:</b> <span style="color: #4CAF50; font-weight: bold;">${{data.ratio.toFixed(4)}} ‚¨Ö Current</span>`;
                }} else {{
                    html += `<br><b>Ratio:</b> ${{data.ratio.toFixed(4)}}`;
                }}
            }}
            if (data.probability && !isNaN(data.probability)) {{
                if (currentMetric === 'probability') {{
                    html += `<br><b>Probability:</b> <span style="color: #4CAF50; font-weight: bold;">${{data.probability.toFixed(4)}} ‚¨Ö Current</span>`;
                }} else {{
                    html += `<br><b>Probability:</b> ${{data.probability.toFixed(4)}}`;
                }}
            }}
            
            info.innerHTML = html;
        }});

        cy.on('mouseout', 'node, edge', function() {{
            const info = document.getElementById('hoverInfo');
            const hiddenCount = cy.nodes('.hidden').length;
            if (hiddenCount > 0) {{
                info.innerHTML = `
                    üí° <b>${{hiddenCount}}</b> node(s) hidden<br>
                    Click <b>Show All Nodes</b> button to restore
                `;
            }} else {{
                info.innerHTML = `
                    üí° <b>Hover over nodes or edges</b> to see details<br>
                    <b>Drag nodes</b> to reposition ‚Ä¢ <b>Scroll</b> to zoom ‚Ä¢ <b>Double-click</b> to highlight
                `;
            }}
        }});

        // Right-click to hide nodes/edges (or delete in edit mode)
        cy.on('cxttap', 'node', function(evt) {{
            if (editMode) {{
                // In edit mode: delete the node
                deleteElement(evt.target);
            }} else {{
                // Normal mode: hide the node
                const node = evt.target;
                node.addClass('hidden');
                // Hide connected edges
                node.connectedEdges().addClass('hidden');
                document.getElementById('showAllBtn').style.display = 'inline-block';
            }}
        }});

        // Right-click to hide edges (or delete in edit mode)
        cy.on('cxttap', 'edge', function(evt) {{
            if (editMode) {{
                // In edit mode: delete the edge
                deleteElement(evt.target);
            }} else {{
                // Normal mode: hide the edge
                const edge = evt.target;
                edge.addClass('hidden');
                document.getElementById('showAllBtn').style.display = 'inline-block';
            }}
        }});

        // Keyboard shortcut: H to hide selected nodes
        document.addEventListener('keydown', function(e) {{
            if (e.key === 'h' || e.key === 'H') {{
                const selected = cy.$('node:selected');
                if (selected.length > 0) {{
                    selected.addClass('hidden');
                    selected.connectedEdges().addClass('hidden');
                    document.getElementById('showAllBtn').style.display = 'inline-block';
                }}
            }}
        }});

        // Keyboard shortcut: E to hide selected edges
        document.addEventListener('keydown', function(e) {{
            if (e.key === 'e' || e.key === 'E') {{
                const selected = cy.$('edge:selected');
                if (selected.length > 0) {{
                    selected.addClass('hidden');
                    document.getElementById('showAllBtn').style.display = 'inline-block';
                }}
            }}
        }});

        // Keyboard shortcut: L to toggle label position (center/outside)
        document.addEventListener('keydown', function(e) {{
            if (e.key === 'l' || e.key === 'L') {{
                if (labelPosition === 'center') {{
                    cy.nodes().addClass('labels-outside');
                    labelPosition = 'outside';
                    console.log('Labels moved outside nodes');
                }} else {{
                    cy.nodes().removeClass('labels-outside');
                    labelPosition = 'center';
                    console.log('Labels moved to center');
                }}
            }}
        }});

        // Double-click to highlight connections
        cy.on('dblclick', 'node', function(evt) {{
            cy.edges().removeClass('highlighted');
            evt.target.connectedEdges().addClass('highlighted');
        }});

        // Click empty space to clear highlights
        cy.on('tap', function(evt) {{
            if (evt.target === cy) {{
                cy.edges().removeClass('highlighted');
            }}
        }});

        // Layout control functions (getLayoutConfig and currentLayoutAlgorithm defined earlier)
        function resetLayout() {{
            const config = getLayoutConfig(currentLayoutAlgorithm);
            // Add animation for reset
            config.animate = true;
            config.animationDuration = 500;
            cy.layout(config).run();
        }}
        
        function changeLayout() {{
            const selector = document.getElementById('layoutSelector');
            const newLayout = selector.value;
            currentLayoutAlgorithm = newLayout;
            
            // Update info text based on selected layout
            const infoDiv = document.getElementById('layoutInfo');
            const layoutInfos = {{
                'dagre': 'üí° Dagre uses Sugiyama\\'s algorithm for optimal edge crossing minimization in hierarchical graphs',
                'klay': 'üí° KLay provides layer-based layout with advanced crossing reduction techniques',
                'breadthfirst': 'üí° Breadth-first layout creates simple hierarchical structure based on graph traversal',
                'fcose': 'üí° fCoSE (fast CoSE) balances speed and quality with compound graph support',
                'cose-bilkent': 'üí° CoSE-Bilkent offers highest quality force-directed layout with better crossing minimization',
                'cose': 'üí° CoSE (Compound Spring Embedder) is a standard force-directed layout algorithm',
                'circle': 'üí° Circular layout arranges all nodes in a circle - simple but many crossings',
                'grid': 'üí° Grid layout arranges nodes in a matrix - useful for small networks',
                'concentric': 'üí° Concentric layout arranges nodes in nested circles based on hierarchy'
            }};
            infoDiv.textContent = layoutInfos[newLayout] || '';
            
            // Get visible (non-hidden) nodes and edges
            const visibleElements = cy.elements().not('.hidden, .filtered, .orphan-hidden');
            
            if (visibleElements.length === 0) {{
                updateHoverInfo('‚ö†Ô∏è No visible elements to layout');
                return;
            }}
            
            // Apply new layout with animation to visible elements only
            const config = getLayoutConfig(newLayout);
            config.animate = true;
            config.animationDuration = 500;
            visibleElements.layout(config).run();
            
            updateHoverInfo(`üîÑ Layout changed to ${{newLayout}}`);
            console.log(`Layout changed to: ${{newLayout}}`);
        }}

        function fitGraph() {{
            // Fit with extra padding to account for control panel height
            cy.fit(null, 80);
        }}

        function exportPNG() {{
            // Get the scale from the input
            const MAX_SAFE_SCALE = 4;
            const scaleInput = document.getElementById('exportScale');
            let scale = scaleInput ? parseFloat(scaleInput.value) : 2;

            if (scale > MAX_SAFE_SCALE) {{
                const proceed = confirm(`Exporting at ${{scale}}√ó may fail in your browser (very large image).\n\nClick OK to attempt the requested ${{scale}}√ó export, or Cancel to export at a safer ${{MAX_SAFE_SCALE}}√ó.`);
                if (!proceed) {{
                    scale = MAX_SAFE_SCALE;
                }}
            }}

            console.log(`Exporting PNG at ${{scale}}√ó resolution with transparent background...`);

            try {{
                const png64 = cy.png({{
                    scale: scale,
                    full: true
                }});

                const link = document.createElement('a');
                link.href = png64;
                link.download = `network_selected_paths_${{scale}}x.png`;
                link.click();

                console.log(`PNG exported successfully at ${{scale}}√ó scale with transparent background`);
            }} catch (err) {{
                console.error('PNG export failed:', err);
                alert('PNG export failed. Try exporting SVG or lowering the scale (‚â§4). See console for details.');
            }}
        }}
        
        function exportSVG() {{
            console.log('Exporting SVG with transparent background...');
            
            const svgContent = cy.svg({{
                full: true
            }});
            
            const blob = new Blob([svgContent], {{ type: 'image/svg+xml' }});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'network_selected_paths.svg';
            link.click();
            URL.revokeObjectURL(url);
            
            console.log('SVG exported successfully with transparent background');
        }}

        // Layout Persistence Functions
        // Use file-specific storage key with timestamp so each HTML copy has independent saved layouts
        const LAYOUT_STORAGE_KEY = '{storage_key}';
        
        function saveLayout() {{
            try {{
                const state = {{
                    // Node positions
                    positions: cy.nodes().map(n => ({{
                        id: n.id(),
                        position: n.position()
                    }})),
                    // Node colors
                    colors: cy.nodes().map(n => ({{
                        id: n.id(),
                        color: n.style('background-color')
                    }})),
                    // Node visibility
                    visibility: cy.nodes().map(n => ({{
                        id: n.id(),
                        visible: n.visible(),
                        hidden: n.hasClass('hidden')
                    }})),
                    // Edge visibility
                    edgeVisibility: cy.edges().map(e => ({{
                        id: e.id(),
                        visible: e.visible(),
                        hidden: e.hasClass('hidden')
                    }})),
                    // UI state
                    zoom: cy.zoom(),
                    pan: cy.pan(),
                    labelsVisible: labelsVisible,
                    // Control values
                    edgeWidth: document.getElementById('edgeWidthSlider').value,
                    edgeWidthScale: document.getElementById('edgeWidthScale').value,
                    arrowSize: document.getElementById('arrowSizeSlider').value,
                    fontSize: document.getElementById('fontSizeSlider').value,
                    nodeSize: document.getElementById('nodeSizeSlider').value,
                    // Metadata
                    timestamp: new Date().toISOString(),
                    graphName: '{output_name}'
                }};
                
                localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(state));
                showLayoutStatus('Layout saved!');
                console.log('Layout saved successfully');
            }} catch (error) {{
                showLayoutStatus('Save failed!');
                console.error('Error saving layout:', error);
            }}
        }}
        
        function loadLayout() {{
            try {{
                const saved = localStorage.getItem(LAYOUT_STORAGE_KEY);
                if (!saved) {{
                    showLayoutStatus('No saved layout found', 'warning');
                    return;
                }}
                
                const state = JSON.parse(saved);
                
                // Restore node positions
                state.positions.forEach(item => {{
                    const node = cy.getElementById(item.id);
                    if (node.length > 0) {{
                        node.position(item.position);
                    }}
                }});
                
                // Restore node colors
                state.colors.forEach(item => {{
                    const node = cy.getElementById(item.id);
                    if (node.length > 0) {{
                        node.style('background-color', item.color);
                    }}
                }});
                
                // Restore node visibility
                state.visibility.forEach(item => {{
                    const node = cy.getElementById(item.id);
                    if (node.length > 0) {{
                        if (item.hidden) {{
                            node.addClass('hidden');
                        }} else {{
                            node.removeClass('hidden');
                        }}
                    }}
                }});
                
                // Restore edge visibility
                if (state.edgeVisibility) {{
                    state.edgeVisibility.forEach(item => {{
                        const edge = cy.getElementById(item.id);
                        if (edge.length > 0) {{
                            if (item.hidden) {{
                                edge.addClass('hidden');
                            }} else {{
                                edge.removeClass('hidden');
                            }}
                        }}
                    }});
                }}
                
                // Restore zoom and pan
                cy.zoom(state.zoom);
                cy.pan(state.pan);
                
                // Restore label visibility
                if (state.labelsVisible !== undefined && state.labelsVisible !== labelsVisible) {{
                    toggleLabels();
                }}
                
                // Restore control values
                if (state.edgeWidth) {{
                    document.getElementById('edgeWidthSlider').value = state.edgeWidth;
                    updateEdgeWidth(state.edgeWidth);
                }}
                if (state.edgeWidthScale) {{
                    document.getElementById('edgeWidthScale').value = state.edgeWidthScale;
                    updateEdgeWidths();
                }}
                if (state.arrowSize) {{
                    document.getElementById('arrowSizeSlider').value = state.arrowSize;
                    updateArrowSize(state.arrowSize);
                }}
                if (state.fontSize) {{
                    document.getElementById('fontSizeSlider').value = state.fontSize;
                    updateFontSize(state.fontSize);
                }}
                if (state.nodeSize) {{
                    document.getElementById('nodeSizeSlider').value = state.nodeSize;
                    updateNodeSize(state.nodeSize);
                }}
                
                showLayoutStatus('Layout loaded!');
                console.log('Layout loaded successfully:', state);
            }} catch (error) {{
                showLayoutStatus('Load failed!');
                console.error('Error loading layout:', error);
            }}
        }}
        
        function showLayoutStatus(message) {{
            const statusDiv = document.getElementById('layoutStatus');
            statusDiv.textContent = message;
            statusDiv.style.color = '#666';
            
            // Clear after 3 seconds
            setTimeout(() => {{
                statusDiv.textContent = '';
            }}, 3000);
        }}

        function showAllNodes() {{
            cy.elements().removeClass('hidden');
            document.getElementById('showAllBtn').style.display = 'none';
        }}
        
        function refreshEdgeStyles() {{
            // Recalculate edge styles to make single edges straight (no curve)
            // This is useful when parallel/reciprocal edges are hidden
            cy.edges().forEach(edge => {{
                const source = edge.source().id();
                const target = edge.target().id();
                
                // Check if there's a parallel edge (both directions)
                const parallelEdge = cy.edges(`[source = "${{target}}"][target = "${{source}}"]`);
                
                // Count visible parallel edges (not hidden, not filtered)
                const visibleParallel = parallelEdge.filter(e => 
                    !e.hasClass('hidden') && !e.hasClass('filtered')
                );
                
                // If no visible parallel edge, make this edge straight
                if (visibleParallel.length === 0) {{
                    edge.style('curve-style', 'bezier');
                    edge.style('control-point-distances', 0);
                    edge.style('control-point-weights', 0.5);
                }} else {{
                    // Has visible parallel edge, use curved style
                    edge.style('curve-style', 'bezier');
                    edge.style('control-point-distances', 40);
                    edge.style('control-point-weights', 0.5);
                }}
            }});
            
            updateHoverInfo('‚úì Edge styles refreshed - parallel edges updated');
        }}

        function toggleLabels() {{
            const btn = document.getElementById('toggleLabelsBtn');
            
            if (labelsVisible) {{
                // Hide labels
                cy.nodes().addClass('labels-hidden');
                btn.textContent = 'Show Labels';
                labelsVisible = false;
            }} else {{
                // Show labels
                cy.nodes().removeClass('labels-hidden');
                btn.textContent = 'Hide Labels';
                labelsVisible = true;
            }}
        }}

        function updateFontSize(size) {{
            document.getElementById('fontSizeValue').textContent = size + 'px';
            cy.style()
                .selector('node')
                .style('font-size', size + 'px')
                .update();
        }}

        function updateNodeSize(size) {{
            document.getElementById('nodeSizeValue').textContent = size + 'px';
            cy.style()
                .selector('node')
                .style({{
                    'width': size + 'px',
                    'height': size + 'px'
                }})
                .update();
        }}

        function updateEdgeWidth(width) {{
            document.getElementById('edgeWidthValue').textContent = width + 'px';
            const edges = cy.edges();
            
            // Get current scaling method
            const method = document.getElementById('edgeWidthScale').value;
            
            // Calculate min/max widths based on the input width
            const minWidth = parseFloat(width) * 0.2;  // 20% of width
            const maxWidth = parseFloat(width);
            
            // Get scaled widths for current method
            const scaledWidths = edges.map(e => e.data('scaled_width'));
            
            // Calculate correct minScaled/maxScaled for the CURRENT method
            let minScaled, maxScaled;
            
            if (method.startsWith('log_')) {{
                // Use fixed scale ranges for log methods
                minScaled = 0;
                if (method === 'log_2') {{
                    maxScaled = 14;  // log2(10000) ‚âà 13.3
                }} else {{ // log_10
                    maxScaled = 4.5;  // log10(10000) = 4
                }}
            }} else {{
                // For non-log methods, use actual data range
                minScaled = Math.min(...scaledWidths);
                maxScaled = Math.max(...scaledWidths);
                
                // Handle edge case where all values are the same
                if (minScaled === maxScaled) {{
                    minScaled = 0;
                    maxScaled = 1;
                }}
            }}
            
            // Update edge widths with normalization
            cy.style()
                .selector('edge')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minWidth}}, ${{maxWidth}})`
                }})
                .selector('edge:selected')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minWidth * 1.5}}, ${{maxWidth * 1.5}})`
                }})
                .selector('edge.highlighted')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minWidth * 2}}, ${{maxWidth * 2}})`
                }})
                .update();
        }}

        function updateArrowSize(size) {{
            document.getElementById('arrowSizeValue').textContent = size + 'px';
            cy.style()
                .selector('edge')
                .style({{
                    'arrow-scale': parseFloat(size) / 9  // Normalize to default size of 9
                }})
                .update();
        }}

        // ============ Color Palette Functions ============
        let selectedElement = null;  // For single selection info display
        
        // Color palette is a fixed menubar now; collapse toggle removed

        // Update opacity display
        function updateOpacityDisplay(type, value) {{
            document.getElementById(type + 'OpacityValue').textContent = value + '%';
        }}
        
        // Recalculate and update all edge widths based on scaling method
        // Current metric being used for edge widths
        let currentMetric = 'weight';
        
        function updateMetric() {{
            const metric = document.getElementById('metricSelect').value;
            currentMetric = metric;
            
            console.log(`\\n========== UPDATE METRIC ==========`);
            console.log(`Metric selected: ${{metric}}`);
            
            // Update edge widths with new metric
            updateEdgeWidths();
            
            // Update hover info if currently hovering over an edge
            const hoverInfo = document.getElementById('hoverInfo');
            if (hoverInfo && hoverInfo.innerHTML.includes('Connection:')) {{
                // Just leave it as is - next hover will show updated info
            }}
        }}
        
        function updateEdgeWidths() {{
            const method = document.getElementById('edgeWidthScale').value;
            
            console.log(`\\n========== UPDATE EDGE WIDTHS ==========`);
            console.log(`Method selected: ${{method}}`);
            console.log(`Current metric: ${{currentMetric}}`);
            
            // Get all edge values based on current metric
            const edges = cy.edges();
            let values;
            
            if (currentMetric === 'ratio') {{
                values = edges.map(e => e.data('ratio'));
            }} else if (currentMetric === 'probability') {{
                values = edges.map(e => e.data('probability'));
            }} else {{
                values = edges.map(e => e.data('weight'));
            }}
            
            if (values.length === 0) {{
                console.warn('No edges to update');
                return;
            }}
            
            console.log(`Values: [${{values.slice(0, 5).join(', ')}}...]`);
            
            // For ratio and probability, scale them up for better visualization
            const scaleFactor = (currentMetric === 'ratio' || currentMetric === 'probability') ? 1000 : 1;
            values = values.map(v => v * scaleFactor);
            
            // Calculate scaled widths based on EXACT method string
            let scaledWidths = values.map(w => {{
                let scaled;
                
                switch(method) {{
                    case 'linear':
                        scaled = w;
                        break;
                    
                    case 'log_2':
                        scaled = Math.log(w + 1) / Math.log(2);  // Log base 2
                        break;
                    
                    case 'log_10':
                        scaled = Math.log(w + 1) / Math.log(10);  // Log base 10
                        break;
                    
                    case 'sqrt':
                        scaled = Math.sqrt(w);
                        break;
                    
                    case 'none':
                    default:
                        scaled = 1.0;
                        break;
                }}
                
                return scaled;
            }});
            
            console.log(`Scaled widths: [${{scaledWidths.map(v => v.toFixed(3)).join(', ')}}]`);
            
            // For logarithmic methods, use FIXED scale ranges based on typical weight distributions
            // For other methods, normalize to actual data range
            let minScaled, maxScaled;
            
            if (method.startsWith('log_')) {{
                // Use fixed scale ranges - assumes weights typically range from 1 to ~10000
                minScaled = 0;  // log(1) ‚âà 0 for all bases
                
                // Set max based on log base
                if (method === 'log_2') {{
                    maxScaled = 14;  // log2(10000) ‚âà 13.3
                }} else {{ // log_10
                    maxScaled = 4.5;  // log10(10000) = 4
                }}
                
                console.log(`Using FIXED scale for ${{method}}: [${{minScaled}}, ${{maxScaled}}]`);
            }} else {{
                // For non-log methods, normalize to actual data range
                minScaled = Math.min(...scaledWidths);
                maxScaled = Math.max(...scaledWidths);
                
                // Handle edge case where all values are the same
                if (minScaled === maxScaled) {{
                    minScaled = 0;
                    maxScaled = 1;
                }}
                
                console.log(`Using DATA scale: [${{minScaled.toFixed(2)}}, ${{maxScaled.toFixed(2)}}]`);
            }}
            
            // Update each edge's scaled_width data
            edges.forEach((edge, i) => {{
                edge.data('scaled_width', scaledWidths[i]);
            }});
            
            // Get edge width slider value
            const edgeWidthSlider = document.getElementById('edgeWidthSlider');
            const edgeWidth = edgeWidthSlider ? parseFloat(edgeWidthSlider.value) : 3;
            const minEdgeWidth = edgeWidth * 0.2;  // 20% of width
            const maxEdgeWidth = edgeWidth;
            
            // Update the stylesheet with new mapping range
            cy.style()
                .selector('edge')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minEdgeWidth}}, ${{maxEdgeWidth}})`
                }})
                .selector('edge:selected')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minEdgeWidth * 1.5}}, ${{maxEdgeWidth * 1.5}})`
                }})
                .selector('edge.highlighted')
                .style({{
                    'width': `mapData(scaled_width, ${{minScaled}}, ${{maxScaled}}, ${{minEdgeWidth * 2}}, ${{maxEdgeWidth * 2}})`
                }})
                .update();
            
            console.log('Edge widths updated successfully');
        }}
        
        // Get all currently selected elements (supports multi-selection)
        function getSelectedElements() {{
            return cy.$(':selected');
        }}
        
        // Count selected elements
        function getSelectionCount() {{
            const selected = getSelectedElements();
            const nodes = selected.nodes().length;
            const edges = selected.edges().length;
            return {{ nodes: nodes, edges: edges, total: nodes + edges }};
        }}

        // Update color text fields when color picker changes
        document.getElementById('sourceColor').addEventListener('input', function(e) {{
            document.getElementById('sourceColorText').value = e.target.value;
        }});
        document.getElementById('intermediateColor').addEventListener('input', function(e) {{
            document.getElementById('intermediateColorText').value = e.target.value;
        }});
        document.getElementById('targetColor').addEventListener('input', function(e) {{
            document.getElementById('targetColorText').value = e.target.value;
        }});
        document.getElementById('edgeColor').addEventListener('input', function(e) {{
            document.getElementById('edgeColorText').value = e.target.value;
        }});
        document.getElementById('negativeEdgeColor').addEventListener('input', function(e) {{
            document.getElementById('negativeEdgeColorText').value = e.target.value;
        }});
        document.getElementById('individualColor').addEventListener('input', function(e) {{
            document.getElementById('individualColorText').value = e.target.value;
        }});

        // Apply global colors to all nodes by type using CSS-based opacity (coana approach)
        function applyGlobalColors() {{
            const sourceColor = document.getElementById('sourceColor').value;
            const intermediateColor = document.getElementById('intermediateColor').value;
            const targetColor = document.getElementById('targetColor').value;
            const edgeColor = document.getElementById('edgeColor').value;
            const negativeEdgeColor = document.getElementById('negativeEdgeColor').value;
            
            const sourceOpacity = document.getElementById('sourceOpacity').value / 100;
            const intermediateOpacity = document.getElementById('intermediateOpacity').value / 100;
            const targetOpacity = document.getElementById('targetOpacity').value / 100;
            const edgeOpacity = document.getElementById('edgeOpacity').value / 100;
            const negativeEdgeOpacity = document.getElementById('negativeEdgeOpacity').value / 100;
            
            console.log('Applying global colors with CSS-based opacity...');
            
            // Update nodes by type with color AND opacity (only if they haven't been individually customized)
            // Using CSS style update (coana's approach) instead of data modification
            cy.nodes().forEach(function(node) {{
                if (!node.data('customColor')) {{  // Only update if not customized
                    const nodeType = node.data('node_type');
                    if (nodeType === 'source') {{
                        node.style({{
                            'background-color': sourceColor,
                            'opacity': sourceOpacity  // CSS opacity property (coana's approach)
                        }});
                    }} else if (nodeType === 'intermediate') {{
                        node.style({{
                            'background-color': intermediateColor,
                            'opacity': intermediateOpacity
                        }});
                    }} else if (nodeType === 'target') {{
                        node.style({{
                            'background-color': targetColor,
                            'opacity': targetOpacity
                        }});
                    }}
                }}
            }});
            
            // Update edges with separate colors for positive and negative edges
            cy.edges().forEach(function(edge) {{
                if (!edge.data('customColor')) {{
                    const isNegative = edge.data('is_negative') === 1;
                    const color = isNegative ? negativeEdgeColor : edgeColor;
                    const opacity = isNegative ? negativeEdgeOpacity : edgeOpacity;
                    
                    edge.style({{
                        'line-color': color,
                        'target-arrow-color': color,
                        'opacity': opacity  // CSS opacity property, not rgba
                    }});
                }}
            }});
            
            // Update legend colors (with opacity for visual consistency)
            const legendColors = document.querySelectorAll('.legend-color');
            if (legendColors[0]) {{
                legendColors[0].style.background = sourceColor;
                legendColors[0].style.opacity = sourceOpacity;
            }}
            if (legendColors[1]) {{
                legendColors[1].style.background = intermediateColor;
                legendColors[1].style.opacity = intermediateOpacity;
            }}
            if (legendColors[2]) {{
                legendColors[2].style.background = targetColor;
                legendColors[2].style.opacity = targetOpacity;
            }}
            
            console.log('‚úì Global colors applied (CSS opacity method for nodes and edges)');
        }}

        // Handle element selection for individual coloring
        cy.on('tap', 'node, edge', function(evt) {{
            const element = evt.target;
            selectedElement = element;  // Keep for backward compatibility
            
            // Check if multiple elements are selected
            const selectionCount = getSelectionCount();
            
            // Get current color and opacity from the tapped element
            let currentColor = '#3498db';
            let currentOpacity = 100;
            
            if (element.isNode()) {{
                const bgColor = element.style('background-color');
                currentColor = extractColorHex(bgColor);
                const opacity = element.style('opacity');
                currentOpacity = Math.round(parseFloat(opacity || 1) * 100);
                
                if (selectionCount.total > 1) {{
                    document.getElementById('selectedInfo').innerHTML = 
                        `<strong>Multi-Selection:</strong><br>` +
                        `${{selectionCount.nodes}} node(s), ${{selectionCount.edges}} edge(s)<br>` +
                        `<em>Colors from: ${{element.data('label')}}</em>`;
                }} else {{
                    document.getElementById('selectedInfo').innerHTML = 
                        `<strong>Node:</strong> ${{element.data('label')}} (${{element.data('node_type')}})`;
                }}
            }} else {{
                const lineColor = element.style('line-color');
                currentColor = extractColorHex(lineColor);
                const opacity = element.style('opacity');
                currentOpacity = Math.round(parseFloat(opacity || 1) * 100);
                
                const sourceNode = element.source().data('label');
                const targetNode = element.target().data('label');
                
                if (selectionCount.total > 1) {{
                    document.getElementById('selectedInfo').innerHTML = 
                        `<strong>Multi-Selection:</strong><br>` +
                        `${{selectionCount.nodes}} node(s), ${{selectionCount.edges}} edge(s)<br>` +
                        `<em>Colors from: ${{sourceNode}} ‚Üí ${{targetNode}}</em>`;
                }} else {{
                    document.getElementById('selectedInfo').innerHTML = 
                        `<strong>Edge:</strong> ${{sourceNode}} ‚Üí ${{targetNode}}`;
                }}
            }}
            
            // Update individual color controls
            document.getElementById('individualColor').value = currentColor;
            document.getElementById('individualColorText').value = currentColor;
            document.getElementById('individualOpacity').value = currentOpacity;
            document.getElementById('individualOpacityValue').textContent = currentOpacity + '%';
            document.getElementById('individualControls').style.display = 'block';
        }});

        // Extract hex color from rgba/rgb string
        function extractColorHex(colorStr) {{
            if (colorStr.startsWith('rgba') || colorStr.startsWith('rgb')) {{
                const matches = colorStr.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);
                if (matches) {{
                    const r = parseInt(matches[1]);
                    const g = parseInt(matches[2]);
                    const b = parseInt(matches[3]);
                    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                }}
            }} else if (colorStr.startsWith('#')) {{
                return colorStr;
            }}
            return '#3498db';
        }}

        // Apply color and opacity to ALL selected elements (supports multi-selection!)
        function applyIndividualColor() {{
            const selectedElements = getSelectedElements();
            
            if (selectedElements.length === 0) {{
                alert('Please select one or more nodes/edges first');
                return;
            }}
            
            const color = document.getElementById('individualColor').value;
            const opacity = document.getElementById('individualOpacity').value / 100;
            
            let nodesUpdated = 0;
            let edgesUpdated = 0;
            
            // Apply to all selected elements
            selectedElements.forEach(function(element) {{
                if (element.isNode()) {{
                    element.style({{
                        'background-color': color,
                        'opacity': opacity  // CSS opacity property (coana's approach)
                    }});
                    element.data('customColor', true);  // Mark as customized
                    nodesUpdated++;
                }} else {{
                    element.style({{
                        'line-color': color,
                        'target-arrow-color': color,
                        'opacity': opacity  // CSS opacity property (coana's approach)
                    }});
                    element.data('customColor', true);  // Mark as customized
                    edgesUpdated++;
                }}
            }});
            
            console.log(`Applied color+opacity to ${{nodesUpdated}} node(s) and ${{edgesUpdated}} edge(s):`, color, opacity);
            
            // Update info display
            if (nodesUpdated + edgesUpdated > 1) {{
                document.getElementById('selectedInfo').innerHTML = 
                    `<strong>‚úì Updated:</strong><br>` +
                    `${{nodesUpdated}} node(s), ${{edgesUpdated}} edge(s)`;
            }}
        }}

        // Clear selection (all selected elements)
        function clearSelection() {{
            cy.$(':selected').unselect();  // Deselect all elements
            selectedElement = null;
            document.getElementById('selectedInfo').innerHTML = 
                'Click on a node or edge to customize its color<br>' +
                '<em>Hold Shift to select multiple elements</em>';
            document.getElementById('individualControls').style.display = 'none';
        }}

        // Apply initial opacity values from parsed input colors
        function applyInitialOpacity() {{
            const sourceOpacity = {self.source_opacity};
            const intermediateOpacity = {self.intermediate_opacity};
            const targetOpacity = {self.target_opacity};
            const edgeOpacity = {self.edge_opacity};
            
            console.log('Applying initial opacity values:', {{
                source: sourceOpacity,
                intermediate: intermediateOpacity,
                target: targetOpacity,
                edge: edgeOpacity
            }});
            
            // Apply initial opacity to all nodes based on their type
            cy.nodes().forEach(function(node) {{
                const nodeType = node.data('node_type');
                if (nodeType === 'source') {{
                    node.style('opacity', sourceOpacity);
                }} else if (nodeType === 'intermediate') {{
                    node.style('opacity', intermediateOpacity);
                }} else if (nodeType === 'target') {{
                    node.style('opacity', targetOpacity);
                }}
            }});
            
            // Apply initial opacity to all edges
            cy.edges().forEach(function(edge) {{
                edge.style('opacity', edgeOpacity);
            }});
            
            console.log('‚úì Initial opacity applied from input colors (nodes + edges)');
        }}

        // Initialize log base visibility on load
        function initializeLogBaseVisibility() {{
            const scalingMethod = document.getElementById('edgeWidthScale').value;
            const logBaseGroup = document.getElementById('logBaseGroup');
            if (scalingMethod === 'log') {{
                logBaseGroup.style.display = 'flex';
            }} else {{
                logBaseGroup.style.display = 'none';
            }}
        }}

        // ===== INTERACTIVE EDITING FEATURES =====
        
        let editMode = false;
        let edgeDrawMode = false;
        let sourceNodeForEdge = null;
        let nextNodeId = 1000;  // Start custom node IDs from 1000
        let nextEdgeId = 1000;  // Start custom edge IDs from 1000
        
        // Default edge color and opacity from link_color parameter
        const defaultEdgeColor = '{self.edge_color}';
        const defaultEdgeOpacity = {self.edge_opacity};
        
        // Edge filtering variables
        let ignoredEdges = new Set();  // Set of exact weight values to ignore
        let ignoredEdgeExpressions = [];  // Array of comparison expressions for edges
        
        // Toggle edit mode
        function toggleEditMode() {{
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const controls = document.getElementById('editControls');
            
            if (editMode) {{
                btn.textContent = 'üîí Disable Edit Mode';
                btn.style.background = '#f44336';
                controls.style.display = 'block';
                
                // Enable node dragging in edit mode
                cy.autoungrabify(false);
                
                // Add click handlers for edge drawing
                cy.on('tap', 'node', function(evt) {{
                    if (editMode) {{
                        handleNodeClickForEdge(evt.target);
                    }}
                }});
                
                // Add double-click to edit properties
                cy.on('dbltap', 'node', function(evt) {{
                    if (editMode) {{
                        editNodeProperties(evt.target);
                    }}
                }});
                
                cy.on('dbltap', 'edge', function(evt) {{
                    if (editMode) {{
                        editEdgeProperties(evt.target);
                    }}
                }});
                
                // Note: Right-click handlers are managed globally above (lines ~4013-4040)
                // They check editMode status to decide between hide/delete
                
            }} else {{
                btn.textContent = '‚úèÔ∏è Enable Edit Mode';
                btn.style.background = '#ff9800';
                controls.style.display = 'none';
                
                // Disable special edit handlers (but keep cxttap for hide functionality)
                cy.off('tap', 'node');
                cy.off('dbltap', 'node');
                cy.off('dbltap', 'edge');
                edgeDrawMode = false;
                sourceNodeForEdge = null;
                
                // Remove any temporary indicators
                cy.nodes().removeClass('edge-source');
            }}
        }}
        
        // Edit node properties (double-click)
        function editNodeProperties(node) {{
            const currentId = node.id();
            const currentType = node.data('node_type');
            const currentLabel = node.data('label');
            
            const newLabel = prompt('Edit node label:', currentLabel);
            if (newLabel === null) return;  // Cancelled
            
            const newType = prompt('Edit node type (source/intermediate/target):', currentType);
            if (newType === null) return;  // Cancelled
            
            // Update node data
            node.data('label', newLabel);
            node.data('node_type', newType);
            
            // Update color based on new type
            let newColor = '{self.node_color[1]}';  // intermediate default
            if (newType === 'source') {{
                newColor = '{self.node_color[0]}';
            }} else if (newType === 'target') {{
                newColor = '{self.target_color}';
            }}
            node.data('color', newColor);
            node.style('background-color', newColor);
            
            updateHoverInfo('‚úì Updated node: ' + currentId + ' ‚Üí label="' + newLabel + '", type=' + newType);
        }}
        
        // Edit edge properties (double-click)
        function editEdgeProperties(edge) {{
            const source = edge.source().id();
            const target = edge.target().id();
            const currentWeight = edge.data('weight') || edge.data('original_weight') || 1;
            
            // Get current optional properties
            const currentRatio = edge.data('ratio') || '';
            const currentProb = edge.data('probability') || '';
            
            // Prompt for new values
            const newWeight = prompt('Edit edge weight:', currentWeight);
            if (newWeight === null) return;  // Cancelled
            
            const weightNum = parseFloat(newWeight);
            if (isNaN(weightNum)) {{
                alert('Invalid weight value. Must be a number.');
                return;
            }}
            
            // Optional: edit ratio and probability
            const editMore = confirm('Edit additional properties (ratio, probability)?');
            let newRatio = currentRatio;
            let newProb = currentProb;
            
            if (editMore) {{
                const ratioInput = prompt('Edit connection ratio (leave empty to skip):', currentRatio);
                if (ratioInput !== null && ratioInput !== '') {{
                    newRatio = parseFloat(ratioInput);
                    if (isNaN(newRatio)) newRatio = currentRatio;
                }}
                
                const probInput = prompt('Edit traversal probability (leave empty to skip):', currentProb);
                if (probInput !== null && probInput !== '') {{
                    newProb = parseFloat(probInput);
                    if (isNaN(newProb)) newProb = currentProb;
                }}
            }}
            
            // Update edge data
            edge.data('weight', Math.abs(weightNum));
            edge.data('original_weight', weightNum);
            edge.data('is_negative', weightNum < 0 ? 1 : 0);
            
            if (newRatio !== '') {{
                edge.data('ratio', newRatio);
            }}
            if (newProb !== '') {{
                edge.data('probability', newProb);
            }}
            
            // Update tooltip
            const tooltipParts = [`Weight: ${{weightNum}}`];
            if (newRatio !== '' && !isNaN(newRatio)) {{
                tooltipParts.push(`Ratio: ${{newRatio.toFixed(3)}}`);
            }}
            if (newProb !== '' && !isNaN(newProb)) {{
                tooltipParts.push(`Probability: ${{newProb.toFixed(3)}}`);
            }}
            edge.data('tooltip', tooltipParts.join('\\n'));
            
            // Update visual properties (edge width and color)
            // Recalculate scaled width based on current scaling method
            const scaledWidth = calculateEdgeWidth(Math.abs(weightNum));
            edge.data('scaled_width', scaledWidth);
            
            // Update edge color if negative
            if (weightNum < 0) {{
                edge.style({{
                    'line-color': document.getElementById('negativeEdgeColor').value,
                    'target-arrow-color': document.getElementById('negativeEdgeColor').value
                }});
            }} else {{
                edge.style({{
                    'line-color': document.getElementById('edgeColor').value,
                    'target-arrow-color': document.getElementById('edgeColor').value
                }});
            }}
            
            // Apply the width update
            updateEdgeWidths();
            
            updateHoverInfo('‚úì Updated edge: ' + source + ' ‚Üí ' + target + ' (weight=' + weightNum + ')');
        }}
        
        // Calculate edge width based on weight and current scaling method
        function calculateEdgeWidth(weight) {{
            const scalingMethod = document.getElementById('edgeWidthScale').value;
            const baseWidth = parseFloat(document.getElementById('edgeWidthSlider').value);
            
            let scaledValue = weight;
            
            switch(scalingMethod) {{
                case 'linear':
                    scaledValue = weight;
                    break;
                case 'log_2':
                    scaledValue = weight > 0 ? Math.log2(weight + 1) : 0;
                    break;
                case 'log_10':
                    scaledValue = weight > 0 ? Math.log10(weight + 1) : 0;
                    break;
                case 'sqrt':
                    scaledValue = Math.sqrt(weight);
                    break;
                case 'none':
                    return baseWidth;
            }}
            
            // Scale to reasonable range (1-10 times base width)
            const maxDataValue = Math.max(...cy.edges().map(e => Math.abs(e.data('weight') || 1)));
            const normalized = maxDataValue > 0 ? scaledValue / maxDataValue : 0;
            return Math.max(0.5, baseWidth * (0.3 + normalized * 2));
        }}
        
        // Handle node click for edge drawing
        function handleNodeClickForEdge(node) {{
            if (!edgeDrawMode) {{
                // First click: select source node
                sourceNodeForEdge = node;
                edgeDrawMode = true;
                cy.nodes().removeClass('edge-source');
                node.addClass('edge-source');
                updateHoverInfo('Selected source: ' + node.id() + '. Click target node to create edge.');
            }} else {{
                // Second click: create edge to target
                if (node.id() !== sourceNodeForEdge.id()) {{
                    const sourceId = sourceNodeForEdge.id();
                    const targetId = node.id();
                    
                    // Check if edge already exists
                    const existingEdge = cy.edges(`[source = "${{sourceId}}"][target = "${{targetId}}"]`);
                    if (existingEdge.length > 0) {{
                        updateHoverInfo('‚ö†Ô∏è Edge already exists: ' + sourceId + ' ‚Üí ' + targetId);
                        // Reset edge draw mode
                        edgeDrawMode = false;
                        sourceNodeForEdge = null;
                        cy.nodes().removeClass('edge-source');
                        return;
                    }}
                    
                    const edgeId = 'e' + nextEdgeId++;
                    const newEdge = cy.add({{
                        group: 'edges',
                        data: {{
                            id: edgeId,
                            source: sourceId,
                            target: targetId,
                            weight: 1,
                            original_weight: 1,
                            is_negative: 0,
                            scaled_width: 3,
                            tooltip: 'Weight: 1'
                        }}
                    }});
                    
                    // Apply default edge color and opacity to newly created edge
                    newEdge.style({{
                        'line-color': defaultEdgeColor,
                        'target-arrow-color': defaultEdgeColor,
                        'opacity': defaultEdgeOpacity
                    }});
                    
                    updateHoverInfo('Edge created: ' + sourceId + ' ‚Üí ' + targetId);
                }} else {{
                    updateHoverInfo('Cannot create self-loop edge');
                }}
                
                // Reset edge draw mode
                edgeDrawMode = false;
                sourceNodeForEdge = null;
                cy.nodes().removeClass('edge-source');
            }}
        }}
        
        // Add new node
        function addNode() {{
            if (!editMode) {{
                alert('Please enable Edit Mode first');
                return;
            }}
            
            const nodeId = prompt('Enter node ID (e.g., Neuron_X):');
            if (!nodeId) return;
            
            // Check if node already exists
            if (cy.getElementById(nodeId).length > 0) {{
                alert('Node with ID "' + nodeId + '" already exists');
                return;
            }}
            
            // Get node type
            const nodeType = prompt('Enter node type (source/intermediate/target):', 'intermediate');
            if (!nodeType) return;
            
            // Determine color based on type
            let color = '{self.node_color[1]}';  // intermediate default
            if (nodeType === 'source') {{
                color = '{self.node_color[0]}';
            }} else if (nodeType === 'target') {{
                color = '{self.target_color}';
            }}
            
            // Add node at center of viewport
            const extent = cy.extent();
            const centerX = (extent.x1 + extent.x2) / 2;
            const centerY = (extent.y1 + extent.y2) / 2;
            
            cy.add({{
                group: 'nodes',
                data: {{
                    id: nodeId,
                    label: nodeId,
                    node_type: nodeType,
                    color: color
                }},
                position: {{ x: centerX, y: centerY }}
            }});
            
            updateHoverInfo('Node added: ' + nodeId + ' (' + nodeType + ')');
        }}
        
        // Delete selected element(s)
        function deleteSelected() {{
            if (!editMode) {{
                alert('Please enable Edit Mode first');
                return;
            }}
            
            const selected = cy.$(':selected');
            if (selected.length === 0) {{
                alert('No elements selected. Click to select nodes or edges.');
                return;
            }}
            
            if (confirm('Delete ' + selected.length + ' selected element(s)?')) {{
                cy.remove(selected);
                updateHoverInfo('Deleted ' + selected.length + ' element(s)');
            }}
        }}
        
        // Delete single element (right-click)
        function deleteElement(element) {{
            const type = element.isNode() ? 'node' : 'edge';
            const id = element.id();
            
            if (confirm('Delete ' + type + ': ' + id + '?')) {{
                cy.remove(element);
                updateHoverInfo('Deleted ' + type + ': ' + id);
            }}
        }}
        
        // Update hover info display
        function updateHoverInfo(text) {{
            document.getElementById('hoverInfo').innerHTML = text;
        }}
        
        // ===== EDGE FILTERING =====
        
        // Update ignored edges based on input
        function updateIgnoredEdges() {{
            const input = document.getElementById('ignoreEdgesInput');
            const expressions = input.value.split(',').map(v => v.trim()).filter(v => v !== '');
            
            // Clear previous filters
            ignoredEdges.clear();
            ignoredEdgeExpressions = [];
            
            expressions.forEach(expr => {{
                // Check if it's a comparison expression (>, <, >=, <=, ==, !=)
                const compMatch = expr.match(/^([><]=?|==|!=)\\s*(-?\\d+\\.?\\d*)$/);
                if (compMatch) {{
                    // It's a comparison expression
                    const operator = compMatch[1];
                    const threshold = parseFloat(compMatch[2]);
                    ignoredEdgeExpressions.push({{ operator, threshold }});
                }} else {{
                    // Try to parse as exact number
                    const num = parseFloat(expr);
                    if (!isNaN(num)) {{
                        ignoredEdges.add(num);
                    }}
                }}
            }});
            
            console.log('Ignored edge exact values:', Array.from(ignoredEdges));
            console.log('Ignored edge expressions:', ignoredEdgeExpressions);
            
            // Apply filter to all edges
            applyEdgeFilter();
        }}
        
        // Check if an edge weight should be ignored
        function shouldIgnoreEdge(weight) {{
            // Check exact values
            if (ignoredEdges.has(weight)) {{
                return true;
            }}
            
            // Check comparison expressions
            for (const expr of ignoredEdgeExpressions) {{
                let matches = false;
                switch (expr.operator) {{
                    case '>':
                        matches = weight > expr.threshold;
                        break;
                    case '<':
                        matches = weight < expr.threshold;
                        break;
                    case '>=':
                        matches = weight >= expr.threshold;
                        break;
                    case '<=':
                        matches = weight <= expr.threshold;
                        break;
                    case '==':
                        matches = weight === expr.threshold;
                        break;
                    case '!=':
                        matches = weight !== expr.threshold;
                        break;
                }}
                if (matches) {{
                    return true;
                }}
            }}
            
            return false;
        }}
        
        // Apply edge filter to show/hide edges
        function applyEdgeFilter() {{
            let hiddenCount = 0;
            let shownCount = 0;
            
            cy.edges().forEach(edge => {{
                // Get the edge weight (use original_weight to handle negative weights)
                const weight = edge.data('original_weight') !== undefined 
                    ? edge.data('original_weight') 
                    : edge.data('weight') || 0;
                
                if (shouldIgnoreEdge(weight)) {{
                    // Use 'filtered' class instead of display:none
                    edge.addClass('filtered');
                    hiddenCount++;
                }} else {{
                    // Remove 'filtered' class
                    edge.removeClass('filtered');
                    shownCount++;
                }}
            }});
            
            // Re-detect orphans if orphan hiding is active
            if (orphansHidden) {{
                let orphanCount = 0;
                cy.nodes().forEach(node => {{
                    const visibleEdges = node.connectedEdges().not('.hidden, .filtered');
                    if (visibleEdges.length === 0) {{
                        node.addClass('orphan-hidden');
                        orphanCount++;
                    }} else {{
                        node.removeClass('orphan-hidden');
                    }}
                }});
            }}
            
            if (hiddenCount > 0) {{
                updateHoverInfo(`üîç Edge filter: ${{shownCount}} shown, ${{hiddenCount}} hidden`);
            }} else {{
                updateHoverInfo('üîç Edge filter: All edges visible');
            }}
        }}
        
        // ===== ORPHAN NODE CONTROLS =====
        
        let orphansHidden = false;
        
        // Toggle orphan nodes visibility (dynamically detect based on current visible edges)
        function toggleOrphanNodes() {{
            const btn = document.getElementById('hideOrphansBtn');
            orphansHidden = !orphansHidden;
            
            if (orphansHidden) {{
                // Hide orphan nodes (nodes with no VISIBLE connections)
                // Check degree excluding hidden/filtered edges
                let hiddenCount = 0;
                cy.nodes().forEach(node => {{
                    // Count only visible edges (not hidden, not filtered)
                    const visibleEdges = node.connectedEdges().not('.hidden, .filtered');
                    const visibleDegree = visibleEdges.length;
                    
                    if (visibleDegree === 0) {{
                        node.addClass('orphan-hidden');
                        hiddenCount++;
                    }} else {{
                        // Remove orphan-hidden class if node has visible connections
                        node.removeClass('orphan-hidden');
                    }}
                }});
                
                btn.textContent = 'üëÅÔ∏è Show Orphans';
                btn.style.background = '#e91e63';
                updateHoverInfo(`üëª Hidden ${{hiddenCount}} orphan node(s) (based on visible edges)`);
            }} else {{
                // Show all orphan nodes
                cy.nodes('.orphan-hidden').removeClass('orphan-hidden');
                btn.textContent = 'üëª Hide Orphans';
                btn.style.background = '#9c27b0';
                updateHoverInfo('üëÅÔ∏è All nodes visible');
            }}
        }}
        
        // Refresh layout after hiding orphans or filtering edges
        function refreshLayout() {{
            // Get visible (non-hidden) nodes and edges
            const visibleElements = cy.elements().not('.hidden, .filtered, .orphan-hidden');
            
            if (visibleElements.length === 0) {{
                updateHoverInfo('‚ö†Ô∏è No visible elements to layout');
                return;
            }}
            
            updateHoverInfo('üîÑ Refreshing layout...');
            
            // Use the currently selected layout algorithm
            const layoutConfig = getLayoutConfig(currentLayoutAlgorithm);
            
            // Apply layout only to visible elements
            visibleElements.layout(layoutConfig).run();
            
            setTimeout(() => {{
                updateHoverInfo('‚úì Layout refreshed for visible elements');
            }}, 600);
        }}
        
        // ===== EXPORT/IMPORT GRAPH =====
        
        // Export graph data and layout
        function exportGraph() {{
            // Collect all nodes with their data and positions
            const nodesData = [];
            cy.nodes().forEach(node => {{
                nodesData.push({{
                    data: node.data(),
                    position: node.position(),
                    classes: node.hasClass('hidden') ? ['hidden'] : [],  // Store hidden class
                    style: {{
                        'background-color': node.style('background-color'),
                        'opacity': parseFloat(node.style('opacity'))
                    }}
                }});
            }});
            
            // Collect all edges with their data and classes
            const edgesData = [];
            cy.edges().forEach(edge => {{
                const classes = [];
                if (edge.hasClass('hidden')) classes.push('hidden');
                if (edge.hasClass('filtered')) classes.push('filtered');
                
                edgesData.push({{
                    data: edge.data(),
                    classes: classes,  // Store classes (hidden/filtered)
                    style: {{
                        'line-color': edge.style('line-color'),
                        'opacity': parseFloat(edge.style('opacity'))
                    }}
                }});
            }});
            
            // Collect current settings (with safe null checks)
            const settings = {{
                edgeFilter: {{
                    inputValue: document.getElementById('ignoreEdgesInput')?.value || '',
                    ignoredValues: Array.from(ignoredEdges),
                    expressions: ignoredEdgeExpressions
                }},
                edgeWidthScaling: {{
                    method: document.getElementById('edgeWidthScale')?.value || 'linear',
                    width: parseFloat(document.getElementById('edgeWidthSlider')?.value || 3)
                }},
                arrowSize: parseFloat(document.getElementById('arrowSizeSlider')?.value || 9),
                fontSize: parseFloat(document.getElementById('fontSizeSlider')?.value || 12),
                nodeSize: parseFloat(document.getElementById('nodeSizeSlider')?.value || 40)
            }};
            
            // Create export object
            const exportData = {{
                version: '2.0',
                timestamp: new Date().toISOString(),
                nodes: nodesData,
                edges: edgesData,
                settings: settings,
                metadata: {{
                    nodeCount: nodesData.length,
                    edgeCount: edgesData.length
                }}
            }};
            
            // Download as JSON
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {{type: 'application/json'}});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'network_graph_' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            updateHoverInfo('‚úì Exported graph with settings: ' + nodesData.length + ' nodes, ' + edgesData.length + ' edges');
        }}
        
        // Import graph (trigger file input)
        function importGraph() {{
            document.getElementById('graphFileInput').click();
        }}
        
        // Load graph from file
        function loadGraphFile(event) {{
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {{
                try {{
                    const importData = JSON.parse(e.target.result);
                    
                    if (!importData.nodes || !importData.edges) {{
                        alert('Invalid graph file format');
                        return;
                    }}
                    
                    // Ask user if they want to replace or merge
                    const action = confirm(
                        'Import ' + importData.nodes.length + ' nodes and ' + 
                        importData.edges.length + ' edges.\\n\\n' +
                        'Click OK to REPLACE current graph\\n' +
                        'Click Cancel to MERGE with current graph'
                    );
                    
                    if (action) {{
                        // Replace: clear current graph
                        cy.elements().remove();
                    }}
                    
                    // Add nodes (with layout positions if available)
                    const nodeIds = new Set();
                    importData.nodes.forEach(nodeData => {{
                        const nodeId = nodeData.data.id;
                        nodeIds.add(nodeId);
                        
                        // Check if node already exists
                        if (cy.getElementById(nodeId).length > 0) {{
                            // Update existing node position if in merge mode
                            if (!action && nodeData.position) {{
                                cy.getElementById(nodeId).position(nodeData.position);
                            }}
                        }} else {{
                            // Add new node
                            cy.add({{
                                group: 'nodes',
                                data: nodeData.data,
                                position: nodeData.position || {{ x: 0, y: 0 }}
                            }});
                            
                            // Restore classes (e.g., hidden)
                            if (nodeData.classes && nodeData.classes.length > 0) {{
                                const node = cy.getElementById(nodeId);
                                nodeData.classes.forEach(cls => node.addClass(cls));
                            }}
                            
                            // Apply custom styles if available
                            if (nodeData.style) {{
                                const node = cy.getElementById(nodeId);
                                if (nodeData.style['background-color']) {{
                                    node.style('background-color', nodeData.style['background-color']);
                                }}
                                if (nodeData.style['opacity'] !== undefined) {{
                                    node.style('opacity', nodeData.style['opacity']);
                                }}
                            }}
                        }}
                    }});
                    
                    // Add edges (only if both source and target exist)
                    let addedEdges = 0;
                    importData.edges.forEach(edgeData => {{
                        const source = edgeData.data.source;
                        const target = edgeData.data.target;
                        
                        // Check if both nodes exist
                        if (cy.getElementById(source).length > 0 && cy.getElementById(target).length > 0) {{
                            // Check if edge already exists
                            const existingEdge = cy.edges(`[source = "${{source}}"][target = "${{target}}"]`);
                            if (existingEdge.length === 0) {{
                                cy.add({{
                                    group: 'edges',
                                    data: edgeData.data
                                }});
                                
                                // Get the newly added edge
                                const edge = cy.edges(`[source = "${{source}}"][target = "${{target}}"]`);
                                
                                // Restore classes (e.g., hidden, filtered)
                                if (edgeData.classes && edgeData.classes.length > 0 && edge.length > 0) {{
                                    edgeData.classes.forEach(cls => edge.addClass(cls));
                                }}
                                
                                // Apply custom styles if available
                                if (edgeData.style && edge.length > 0) {{
                                    if (edgeData.style['line-color']) {{
                                        edge.style('line-color', edgeData.style['line-color']);
                                        edge.style('target-arrow-color', edgeData.style['line-color']);
                                    }}
                                    if (edgeData.style['opacity'] !== undefined) {{
                                        edge.style('opacity', edgeData.style['opacity']);
                                    }}
                                }}
                                addedEdges++;
                            }}
                        }}
                    }});
                    
                    // Fit to view
                    cy.fit(null, 50);
                    
                    // Restore settings if available
                    if (importData.settings) {{
                        const settings = importData.settings;
                        
                        // Restore edge filter
                        if (settings.edgeFilter) {{
                            const filterInput = document.getElementById('ignoreEdgesInput');
                            if (filterInput && settings.edgeFilter.inputValue) {{
                                filterInput.value = settings.edgeFilter.inputValue;
                                updateIgnoredEdges(); // Apply the filter
                            }}
                        }}
                        
                        // Restore edge width scaling
                        if (settings.edgeWidthScaling) {{
                            const scalingSelect = document.getElementById('edgeWidthScale');
                            if (scalingSelect && settings.edgeWidthScaling.method) {{
                                scalingSelect.value = settings.edgeWidthScaling.method;
                                updateEdgeWidths(); // Apply the scaling change
                            }}
                            
                            const widthSlider = document.getElementById('edgeWidthSlider');
                            if (widthSlider && settings.edgeWidthScaling.width !== undefined) {{
                                widthSlider.value = settings.edgeWidthScaling.width;
                                updateEdgeWidth(settings.edgeWidthScaling.width);
                            }}
                        }}
                        
                        // Restore arrow size
                        if (settings.arrowSize !== undefined) {{
                            const arrowSlider = document.getElementById('arrowSizeSlider');
                            if (arrowSlider) {{
                                arrowSlider.value = settings.arrowSize;
                                updateArrowSize(settings.arrowSize);
                            }}
                        }}
                        
                        // Restore font size
                        if (settings.fontSize !== undefined) {{
                            const fontSlider = document.getElementById('fontSizeSlider');
                            if (fontSlider) {{
                                fontSlider.value = settings.fontSize;
                                updateFontSize(settings.fontSize);
                            }}
                        }}
                        
                        // Restore node size
                        if (settings.nodeSize !== undefined) {{
                            const nodeSlider = document.getElementById('nodeSizeSlider');
                            if (nodeSlider) {{
                                nodeSlider.value = settings.nodeSize;
                                updateNodeSize(settings.nodeSize);
                            }}
                        }}
                        
                        updateHoverInfo(
                            '‚úì Imported with settings: ' + importData.nodes.length + ' nodes, ' + 
                            addedEdges + ' edges'
                        );
                    }} else {{
                        updateHoverInfo(
                            '‚úì Imported: ' + importData.nodes.length + ' nodes, ' + 
                            addedEdges + ' edges (layout preserved)'
                        );
                    }}
                    
                }} catch (error) {{
                    alert('Error loading graph file: ' + error.message);
                    console.error('Import error:', error);
                }}
            }};
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }}
        
        // ===== EXPORT/IMPORT LAYOUT ONLY =====
        
        // Export only node positions (layout)
        function exportLayout() {{
            // Collect only node IDs and positions
            const layoutData = {{}};
            cy.nodes().forEach(node => {{
                layoutData[node.id()] = {{
                    x: node.position().x,
                    y: node.position().y
                }};
            }});
            
            // Create export object
            const exportData = {{
                version: '1.0',
                type: 'layout',
                timestamp: new Date().toISOString(),
                layout: layoutData,
                metadata: {{
                    nodeCount: Object.keys(layoutData).length,
                    description: 'Node positions only (no edges or properties)'
                }}
            }};
            
            // Download as JSON
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {{type: 'application/json'}});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'network_layout_' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            updateHoverInfo('‚úì Exported layout: ' + Object.keys(layoutData).length + ' node positions');
        }}
        
        // Import layout (trigger file input)
        function importLayout() {{
            document.getElementById('layoutFileInput').click();
        }}
        
        // Load layout from file and apply to existing nodes
        function loadLayoutFile(event) {{
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {{
                try {{
                    const importData = JSON.parse(e.target.result);
                    
                    // Check if it's a layout file
                    if (!importData.layout) {{
                        alert('Invalid layout file format. Expected a layout export file.');
                        return;
                    }}
                    
                    const layoutData = importData.layout;
                    let updatedCount = 0;
                    let notFoundCount = 0;
                    const notFoundNodes = [];
                    
                    // Apply positions to existing nodes
                    for (const nodeId in layoutData) {{
                        const node = cy.getElementById(nodeId);
                        if (node.length > 0) {{
                            // Node exists - update its position
                            node.position({{
                                x: layoutData[nodeId].x,
                                y: layoutData[nodeId].y
                            }});
                            updatedCount++;
                        }} else {{
                            // Node not found in current graph
                            notFoundCount++;
                            notFoundNodes.push(nodeId);
                        }}
                    }}
                    
                    // Show results
                    let message = `‚úì Layout applied: ${{updatedCount}} nodes repositioned`;
                    
                    if (notFoundCount > 0) {{
                        message += `\\n‚ö†Ô∏è ${{notFoundCount}} nodes not found in current graph`;
                        if (notFoundCount <= 5) {{
                            message += `\\n  Missing: ${{notFoundNodes.join(', ')}}`;
                        }}
                    }}
                    
                    // Check for nodes in current graph that weren't in layout
                    const currentNodeCount = cy.nodes().length;
                    const unmappedCount = currentNodeCount - updatedCount;
                    if (unmappedCount > 0) {{
                        message += `\\nüí° ${{unmappedCount}} current nodes kept their positions`;
                    }}
                    
                    updateHoverInfo(message);
                    
                    // Optionally fit to view
                    if (confirm('Fit graph to view?')) {{
                        cy.fit(null, 50);
                    }}
                    
                }} catch (error) {{
                    alert('Error loading layout file: ' + error.message);
                    console.error('Import error:', error);
                }}
            }};
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }}
        
        // Add CSS for edge-source indicator
        cy.style().selector('.edge-source').style({{
            'border-width': '4px',
            'border-color': '#ff9800',
            'border-opacity': 1
        }}).update();
        
        // Initial fit and apply opacity
        cy.fit(null, 50);
        applyInitialOpacity();
        initializeLogBaseVisibility();
    </script>
</body>
</html>"""
        
        # Save HTML
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        if self.showfig:
            webbrowser.open('file://' + os.path.abspath(output_path))
    
    def save_data(self):
        """
        Save connection data and original paths to Excel file.
        
        Creates an Excel file with two sheets:
        1. 'connections': Aggregated connection data
        2. 'original_paths': Original pathway data
        
        Returns
        -------
        str
            Path to the generated Excel file
        """
        if self.conn_df is None:
            self.build_network()
        
        print("\nSaving data to Excel...")
        
        output_path = os.path.join(self.output_folder, self.base_filename + '_data.xlsx')
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            self.conn_df.to_excel(writer, sheet_name='connections', index=False)
            self.path_df.to_excel(writer, sheet_name='original_paths', index=False)
        
        print(f"Data saved: {output_path}")
        
        return output_path
    
    def create_heatmaps(self, conn_matrices, titles=None, color_scales=None):
        """
        Create heatmap visualizations for connection matrices.
        
        Parameters
        ----------
        conn_matrices : dict
            Dictionary of {matrix_name: matrix_dataframe} to visualize.
            Example: {'connMatrix_bodyId': df1, 'connMatrix_type': df2}
        titles : dict, optional
            Dictionary of {matrix_name: title_string}. If None, uses matrix names.
        color_scales : dict, optional
            Dictionary of {matrix_name: color_scale}. If None, uses defaults.
            Color scales should be in Plotly format: [[0, 'color1'], [1, 'color2']]
        
        Returns
        -------
        list
            List of created heatmap file paths
            
        Example
        -------
        >>> matrices = {
        ...     'connMatrix_type': conn_matrix_type,
        ...     'ratioMatrix_type': conn_matrix_ratio_type
        ... }
        >>> titles = {
        ...     'connMatrix_type': 'Connection Matrix by Type',
        ...     'ratioMatrix_type': 'Connection Ratio Matrix by Type'
        ... }
        >>> color_scales = {
        ...     'connMatrix_type': [[0, 'rgb(255,255,255)'], [1, 'rgb(14,83,13)']],
        ...     'ratioMatrix_type': [[0, 'rgb(255,255,255)'], [1, 'rgb(204,102,0)']]
        ... }
        >>> vp.create_heatmaps(matrices, titles, color_scales)
        """
        if titles is None:
            titles = {}
        if color_scales is None:
            color_scales = {}
        
        # Default color scales for different matrix types
        default_color_scales = {
            'conn': [[0, 'rgb(255,255,255)'], [1, 'rgb(14,83,13)']],        # Green for connections
            'transmission': [[0, 'rgb(255,255,255)'], [1, 'rgb(104,55,164)']],  # Purple for transmission
            'ratio': [[0, 'rgb(255,255,255)'], [1, 'rgb(204,102,0)']]       # Orange for ratios
        }
        
        created_files = []
        
        print('\nCreating heatmap visualizations...')
        for matrix_name, matrix_df in conn_matrices.items():
            if matrix_df is None or matrix_df.empty:
                continue
            
            # Generate title
            if matrix_name in titles:
                title = titles[matrix_name]
            else:
                title = f'Heatmap: {matrix_name}'
            
            # Select color scale
            if matrix_name in color_scales:
                color_scale = color_scales[matrix_name]
            else:
                # Auto-detect color scale based on matrix name
                if 'ratio' in matrix_name.lower():
                    color_scale = default_color_scales['ratio']
                elif 'transmission' in matrix_name.lower() or 'prob' in matrix_name.lower():
                    color_scale = default_color_scales['transmission']
                else:
                    color_scale = default_color_scales['conn']
            
            # Generate filename
            filename = os.path.join(self.output_folder, f'heatmap_{matrix_name}.html')
            
            # Create heatmap using the standalone VisConnMatInteractive
            VisConnMatInteractive(
                matrix_df,
                filename=filename,
                title=title,
                color_scale=color_scale,
                showfig=False  # Don't auto-open each heatmap
            )
            
            created_files.append(filename)
            print(f'  Created: heatmap_{matrix_name}.html')
        
        print('Done\n')
        return created_files

    def create_heatmap(self, custom_row_order=None, custom_col_order=None):
        """
        Create an interactive heatmap from the connection DataFrame.
        
        Converts the connection DataFrame (source, target, weight) into matrices
        and creates an interactive heatmap visualization using VisConnMatInteractive.
        
        Parameters
        ----------
        custom_row_order : list of str, optional
            Custom order for row nodes (sources). If None, uses the class attribute
            `heatmap_row_order` (if set), otherwise uses sorted order.
            Nodes not in the list will be appended at the end.
        custom_col_order : list of str, optional
            Custom order for column nodes (targets). If None, uses the class attribute
            `heatmap_col_order` (if set), otherwise uses sorted order.
            Nodes not in the list will be appended at the end.
        
        Returns
        -------
        str
            Path to the generated HTML file
            
        Notes
        -----
        - Creates matrices for weight, ratio, and probability (if available)
        - Node ordering follows source -> intermediate -> target (or custom order)
        - Missing connections are shown as 0
        - Creates an interactive heatmap with metric toggle, zoom, pan, and export features
        
        Examples
        --------
        >>> # Default sorting
        >>> vis.create_heatmap()
        >>> 
        >>> # Custom row order
        >>> vis.create_heatmap(custom_row_order=['A', 'B', 'C'])
        >>> 
        >>> # Custom both orders
        >>> vis.create_heatmap(
        ...     custom_row_order=['PN1', 'PN2', 'LHN1'],
        ...     custom_col_order=['LHN1', 'LHN2', 'MBON1']
        ... )
        """
        if self.conn_df is None or len(self.conn_df) == 0:
            print("Warning: No connection data available for heatmap.")
            return None
        
        print("\nCreating interactive heatmap...")
        
        # Create weight matrix from connections
        weight_matrix = self.conn_df.pivot_table(
            index='source',
            columns='target',
            values='weight',
            fill_value=0
        )
        
        # Determine nodes that actually appear as sources or targets in the connection data
        # This handles cases where a node can be BOTH a source and a target
        actual_sources = set(self.conn_df['source'].unique())
        actual_targets = set(self.conn_df['target'].unique())
        all_nodes = actual_sources | actual_targets
        
        # Nodes that are ONLY sources (appear as source but never as target)
        source_only = actual_sources - actual_targets
        # Nodes that are ONLY targets (appear as target but never as source)
        target_only = actual_targets - actual_sources
        # Nodes that are BOTH source AND target (intermediate nodes in pathways)
        intermediate_nodes = actual_sources & actual_targets
        
        # For heatmap: rows = nodes that act as sources, cols = nodes that act as targets
        # This ensures we don't miss any connections
        all_row_nodes = list(source_only) + list(intermediate_nodes)
        all_col_nodes = list(intermediate_nodes) + list(target_only)
        
        # Apply custom ordering if provided
        # Priority: parameter > class attribute > default (sorted)
        if custom_row_order is not None:
            row_nodes = self._apply_custom_order(all_row_nodes, custom_row_order)
        elif self.heatmap_row_order is not None:
            row_nodes = self._apply_custom_order(all_row_nodes, self.heatmap_row_order)
        else:
            row_nodes = sorted(all_row_nodes)
            
        if custom_col_order is not None:
            col_nodes = self._apply_custom_order(all_col_nodes, custom_col_order)
        elif self.heatmap_col_order is not None:
            col_nodes = self._apply_custom_order(all_col_nodes, self.heatmap_col_order)
        else:
            col_nodes = sorted(all_col_nodes)
        
        # Reindex weight matrix: rows = sources, columns = targets
        weight_matrix = weight_matrix.reindex(index=row_nodes, columns=col_nodes, fill_value=0)
        
        # Create ratio and probability matrices if those columns exist
        matrices_dict = {'weight': weight_matrix}
        
        if 'ratio' in self.conn_df.columns:
            print("  Creating ratio matrix...")
            ratio_matrix = self.conn_df.pivot_table(
                index='source',
                columns='target',
                values='ratio',
                fill_value=0
            )
            ratio_matrix = ratio_matrix.reindex(index=row_nodes, columns=col_nodes, fill_value=0)
            matrices_dict['ratio'] = ratio_matrix
        
        if 'probability' in self.conn_df.columns:
            print("  Creating probability matrix...")
            prob_matrix = self.conn_df.pivot_table(
                index='source',
                columns='target',
                values='probability',
                fill_value=0
            )
            prob_matrix = prob_matrix.reindex(index=row_nodes, columns=col_nodes, fill_value=0)
            matrices_dict['probability'] = prob_matrix
        
        # Generate filename
        heatmap_file = os.path.join(self.output_folder, f'{self.base_filename}_heatmap.html')
        
        # Create interactive heatmap with metric toggle
        title = f'Connection Matrix - {self.base_filename}'
        VisConnMatInteractive(
            weight_matrix,  # Default matrix (backward compatibility)
            filename=heatmap_file,
            title=title,
            showfig=False,
            matrices_dict=matrices_dict  # Pass all matrices for metric toggle
        )
        
        print(f"  Heatmap saved: {heatmap_file}")
        
        return heatmap_file

    def get_heatmap_node_info(self):
        """
        Get information about nodes that will appear in heatmap rows and columns.
        
        This helps users understand and customize the heatmap node ordering.
        Must be called after build_network().
        
        Returns
        -------
        dict
            Dictionary with keys:
            - 'row_nodes': list of nodes that appear in rows (sources)
            - 'col_nodes': list of nodes that appear in columns (targets)
            - 'source_only': nodes that only act as sources
            - 'target_only': nodes that only act as targets
            - 'intermediate': nodes that act as both source and target
            
        Examples
        --------
        >>> vis = VisualizePath('data.csv')
        >>> vis.build_network()
        >>> info = vis.get_heatmap_node_info()
        >>> print("Row nodes:", info['row_nodes'])
        >>> print("Column nodes:", info['col_nodes'])
        >>> print("Dual-role nodes:", info['intermediate'])
        """
        if self.conn_df is None or len(self.conn_df) == 0:
            raise ValueError("No connection data available. Run build_network() first.")
        
        # Determine nodes that actually appear as sources or targets
        actual_sources = set(self.conn_df['source'].unique())
        actual_targets = set(self.conn_df['target'].unique())
        
        source_only = actual_sources - actual_targets
        target_only = actual_targets - actual_sources
        intermediate = actual_sources & actual_targets
        
        all_row_nodes = list(source_only) + list(intermediate)
        all_col_nodes = list(intermediate) + list(target_only)
        
        return {
            'row_nodes': sorted(all_row_nodes),
            'col_nodes': sorted(all_col_nodes),
            'source_only': sorted(source_only),
            'target_only': sorted(target_only),
            'intermediate': sorted(intermediate)
        }
    
    def print_heatmap_node_info(self):
        """
        Print heatmap node information in a user-friendly format.
        
        Displays which nodes will appear in rows vs columns and their roles.
        Must be called after build_network().
        
        Examples
        --------
        >>> vis = VisualizePath('data.csv')
        >>> vis.build_network()
        >>> vis.print_heatmap_node_info()
        """
        info = self.get_heatmap_node_info()
        
        print("\n" + "=" * 80)
        print("HEATMAP NODE INFORMATION")
        print("=" * 80)
        print(f"\nRow nodes (sources): {len(info['row_nodes'])} total")
        print(f"  {', '.join(info['row_nodes'])}")
        print(f"\nColumn nodes (targets): {len(info['col_nodes'])} total")
        print(f"  {', '.join(info['col_nodes'])}")
        print(f"\nNode roles:")
        print(f"  Source-only:  {len(info['source_only'])} nodes - {', '.join(info['source_only'])}")
        print(f"  Target-only:  {len(info['target_only'])} nodes - {', '.join(info['target_only'])}")
        print(f"  Both (intermediate): {len(info['intermediate'])} nodes - {', '.join(info['intermediate'])}")
        print("\nNote: Nodes in 'Both' category appear in BOTH rows AND columns")
        print("=" * 80 + "\n")
    
    def visualize(self):
        """
        Create all visualizations (Heatmap + Sankey + Network + Data export).
        
        This is the main method to call for complete visualization workflow.
        It executes:
        1. Build network graph from pathway data
        2. Create heatmap (shown first if showfig=True)
        3. Create Sankey diagram
        4. Create interactive network graph
        5. Save data to Excel
        
        When showfig=True, opens all three visualizations in browser:
        heatmap ‚Üí sankey ‚Üí network
        
        If generate_empty_network=True, only generates an empty network HTML template.
        
        Returns
        -------
        tuple
            (conn_df, G_network) - Connection DataFrame and NetworkX graph
            For empty network: (None, None)
            
        Example
        -------
        >>> vp = VisualizePath('path_type.xlsx', showfig=True)
        >>> conn_df, G = vp.visualize()
        >>> print(f"Created {len(conn_df)} connections")
        
        >>> # Generate empty network template
        >>> vp = VisualizePath(path_file=None, generate_empty_network=True, showfig=True)
        >>> vp.visualize()
        """
        # Handle empty network generation
        if self.generate_empty_network:
            print("=" * 80)
            print("VisualizePath - Generating empty network template")
            print("=" * 80)
            self.generate_empty_network_html()
            print("=" * 80)
            print("‚úì Empty network generation complete!")
            print("=" * 80)
            return None, None
        
        print("=" * 80)
        print("VisualizePath - Creating pathway visualizations")
        print("=" * 80)
        
        # Build network
        self.build_network()
        
        # Create and show visualizations one by one
        # Order: heatmap ‚Üí sankey ‚Üí network
        import time
        
        # 1. Create heatmap and show immediately
        heatmap_path = self.create_heatmap()
        if self.showfig:
            import webbrowser
            webbrowser.open('file://' + os.path.abspath(heatmap_path))
            time.sleep(0.5)  # Small delay before next visualization
        
        # 2. Create sankey and show immediately (already handles showfig internally)
        sankey_path = self.create_sankey()
        if self.showfig:
            time.sleep(0.5)  # Small delay before next visualization
        
        # 3. Create network and show immediately
        network_path = self.create_network()
        if self.showfig:
            import webbrowser
            webbrowser.open('file://' + os.path.abspath(network_path))
        
        # Save data
        self.save_data()
        
        print("\n" + "=" * 80)
        print("‚úì Visualization complete!")
        print("=" * 80)
        print(f"\nOutput files in: {self.output_folder}")
        print(f"  ‚Ä¢ {self.base_filename}_heatmap.html - Connection matrix")
        print(f"  ‚Ä¢ {self.base_filename}_Sankey.html - Flow-based diagram")
        print(f"  ‚Ä¢ {self.base_filename}_network.html - Interactive network")
        print(f"  ‚Ä¢ {self.base_filename}_data.xlsx - Connection data")
        
        return self.conn_df, self.G_network


# Convenience function for quick usage
def visualize_paths(
    path_file,
    sheet_name=None,
    output_folder=None,
    source_color=None,
    intermediate_color=None,
    target_color=None,
    link_color=None,
    node_color=None,  # For backward compatibility
    network_layout='hierarchical',
    showfig=False
):
    """
    Convenience function to quickly visualize pathways.
    
    This is a shorthand for creating a VisualizePath instance and calling visualize().
    
    Parameters
    ----------
    path_file : str or pd.DataFrame
        Path to CSV/Excel file or DataFrame with pathway data
    sheet_name : str, optional
        Excel sheet name (default: auto-detect)
    output_folder : str, optional
        Output directory (default: '[filename]_figure' for files, './selected_paths' for DataFrames)
    source_color : str, optional
        Color for source nodes
    intermediate_color : str, optional
        Color for intermediate nodes
    target_color : str, optional
        Color for target nodes
    link_color : str, optional
        Color for Sankey connections
    node_color : list, optional
        [DEPRECATED] Colors for [source, intermediate] nodes.
        Use source_color and intermediate_color instead.
    network_layout : str, optional
        Layout algorithm: 'hierarchical', 'spring', 'circular', 'distributed'
    showfig : bool, optional
        Auto-open in browser (default: False)
        
    Returns
    -------
    tuple
        (conn_df, G_network) - Connection DataFrame and NetworkX graph
        
    Example
    -------
    >>> from vispath import visualize_paths
    >>> conn_df, G = visualize_paths('path_type.xlsx', showfig=True)
    
    >>> # With custom colors
    >>> conn_df, G = visualize_paths(
    ...     'path_type.xlsx',
    ...     source_color='#FF6B6B',
    ...     intermediate_color='#FFA500',
    ...     target_color='#FFD700',
    ...     showfig=True
    ... )
    """
    vp = VisualizePath(
        path_file=path_file,
        sheet_name=sheet_name,
        output_folder=output_folder,
        source_color=source_color,
        intermediate_color=intermediate_color,
        target_color=target_color,
        link_color=link_color,
        node_color=node_color,  # Pass for backward compatibility
        network_layout=network_layout,
        showfig=showfig
    )
    
    return vp.visualize()

def VisConnMatInteractive(cmat, filename, title='', color_scale=[[0, 'rgb(255,255,255)'], [1, 'rgb(104,55,164)']], showfig=True, fontsize=12, conn_df=None, matrices_dict=None):
    '''Create interactive heatmap with comprehensive controls similar to network visualization
    
    Features:
    - Metric toggle: Switch between weight/ratio/probability (if provided)
    - Clustering toggle: Toggle between original and clustered ordering (hierarchical clustering)
    - Scale switcher: Linear / Log2 / Log10 / Sqrt
    - Colorscale selector with presets (Greens, Purples, Oranges, Blues, Reds, Viridis, etc.)
    - Font size slider
    - Export to SVG with adjustable resolution
    - Zoom/pan controls
    - Save/load layout state
    
    Parameters
    ----------
    cmat : pd.DataFrame
        Connection matrix to visualize (weight matrix if matrices_dict not provided)
    filename : str
        Output HTML filename
    title : str, optional
        Title for the heatmap
    color_scale : list, optional
        Plotly color scale (default starting point)
    showfig : bool, optional
        Whether to open in browser
    fontsize : int, optional
        Default font size for labels
    conn_df : pd.DataFrame, optional
        Connection dataframe with type information for enhanced hover labels (bodyId heatmaps only)
    matrices_dict : dict, optional
        Dictionary with keys 'weight', 'ratio', 'probability' containing different metric matrices
        If provided, enables metric toggle. Otherwise uses cmat as weight matrix only.
    '''
    
    # Handle multiple matrices for metric toggle
    has_multiple_metrics = matrices_dict is not None and isinstance(matrices_dict, dict)
    
    if has_multiple_metrics:
        # Use provided matrices dictionary
        available_metrics = []
        matrices_data = {}
        
        if 'weight' in matrices_dict and matrices_dict['weight'] is not None:
            available_metrics.append('weight')
            matrices_data['weight'] = matrices_dict['weight'].values.copy()
        
        if 'ratio' in matrices_dict and matrices_dict['ratio'] is not None:
            available_metrics.append('ratio')
            matrices_data['ratio'] = matrices_dict['ratio'].values.copy()
        
        if 'probability' in matrices_dict and matrices_dict['probability'] is not None:
            available_metrics.append('probability')
            matrices_data['probability'] = matrices_dict['probability'].values.copy()
        
        # Use first available metric as default
        default_metric = available_metrics[0] if available_metrics else 'weight'
        data_linear = matrices_data.get(default_metric, cmat.values.copy())
        metric_type = default_metric
    else:
        # Single matrix mode - determine metric type from title/filename
        available_metrics = ['weight']  # Only one metric available
        matrices_data = {}
        
        metric_type = 'weight'
        if 'ratio' in title.lower() or 'ratio' in filename.lower():
            metric_type = 'ratio'
            available_metrics = ['ratio']
        elif 'transmission' in title.lower() or 'probability' in title.lower():
            metric_type = 'probability'
            available_metrics = ['probability']
        
        data_linear = cmat.values.copy()
        matrices_data[metric_type] = data_linear
    
    is_large = cmat.shape[0] > 100 or cmat.shape[1] > 100
    
    # Check sparsity for potential optimization
    zero_count = np.count_nonzero(data_linear == 0)
    sparsity_ratio = zero_count / data_linear.size
    is_sparse = sparsity_ratio > 0.5  # More than 50% zeros
    
    # Compute hierarchical clustering with multiple methods for row/column ordering
    print("  Computing hierarchical clustering...")
    from scipy.cluster.hierarchy import linkage, leaves_list
    from scipy.spatial.distance import pdist
    
    # Store clustering results for all methods
    clustering_methods = ['ward', 'average', 'complete', 'single']
    clustering_results = {}
    
    try:
        for method in clustering_methods:
            method_results = {}
            
            # Cluster rows (source neurons)
            if data_linear.shape[0] > 1:
                # Use euclidean distance (required for ward, good for others)
                row_distances = pdist(data_linear, metric='euclidean')
                # Check for non-finite values
                if not np.all(np.isfinite(row_distances)):
                    raise ValueError("Non-finite distances in row clustering")
                row_linkage = linkage(row_distances, method=method)
                method_results['row_order'] = leaves_list(row_linkage).tolist()
            else:
                method_results['row_order'] = [0]
            
            # Cluster columns (target neurons)
            if data_linear.shape[1] > 1:
                col_distances = pdist(data_linear.T, metric='euclidean')
                # Check for non-finite values
                if not np.all(np.isfinite(col_distances)):
                    raise ValueError("Non-finite distances in column clustering")
                col_linkage = linkage(col_distances, method=method)
                method_results['col_order'] = leaves_list(col_linkage).tolist()
            else:
                method_results['col_order'] = [0]
            
            clustering_results[method] = method_results
        
        # Use Ward as default (best for most connectome data)
        row_order_clustered = np.array(clustering_results['ward']['row_order'])
        col_order_clustered = np.array(clustering_results['ward']['col_order'])
        
        clustering_successful = True
        print(f"  ‚úì Clustering complete: {len(row_order_clustered)} rows, {len(col_order_clustered)} cols")
        print(f"  Available methods: Ward (default), Average, Complete, Single")
    except Exception as e:
        print(f"  ‚ö† Clustering failed: {e}")
        print(f"  Using original order")
        row_order_clustered = np.array(range(data_linear.shape[0]))
        col_order_clustered = np.array(range(data_linear.shape[1]))
        clustering_successful = False
        clustering_results = {}
    
    # Store both original and clustered orders
    row_order_original = list(range(data_linear.shape[0]))
    col_order_original = list(range(data_linear.shape[1]))
    
    # For large matrices, reduce precision to save HTML size
    # Keep more precision for ratio/probability metrics
    if is_large:
        if metric_type in ['ratio', 'probability']:
            # Keep 4 decimal places for ratios/probabilities
            data_linear = np.round(data_linear, 4)
        else:
            # For synapse counts, round to integers (no precision loss)
            data_linear = np.round(data_linear, 0)
    
    # Deep optimization: For very large matrices, compute transforms in JavaScript
    # This saves ~75% of HTML file size by not embedding pre-computed transforms
    use_lazy_transforms = is_large and data_linear.size > 50000
    
    # Sparse matrix optimization: For matrices with >70% zeros, use COO format
    use_sparse_format = is_large and sparsity_ratio > 0.7 and data_linear.size > 50000
    sparse_data = None
    
    if use_sparse_format:
        # Convert to COO (Coordinate) format: store only non-zero values
        rows, cols = np.nonzero(data_linear)
        values = data_linear[rows, cols]
        sparse_data = {
            'rows': rows.tolist(),
            'cols': cols.tolist(),
            'values': values.tolist(),
            'shape': list(data_linear.shape)
        }
        print(f"  Using sparse format: {sparsity_ratio*100:.1f}% zeros, storing {len(values)} values instead of {data_linear.size}")
    
    if use_lazy_transforms:
        # Store only linear data; transforms computed client-side
        data_log2 = None
        data_log10 = None
        data_sqrt = None
    else:
        # Pre-compute for small matrices (faster initial display)
        # Handle negative values: sign(v) * transform(|v|)
        data_log2 = np.where(data_linear >= 0, 
                             np.log2(data_linear + 1), 
                             -np.log2(-data_linear + 1))
        data_log10 = np.where(data_linear >= 0, 
                              np.log10(data_linear + 1), 
                              -np.log10(-data_linear + 1))
        data_sqrt = np.where(data_linear >= 0, 
                            np.sqrt(data_linear), 
                            -np.sqrt(-data_linear))
        
        if is_large:
            if metric_type in ['ratio', 'probability']:
                data_log2 = np.round(data_log2, 4)
                data_log10 = np.round(data_log10, 4)
                data_sqrt = np.round(data_sqrt, 4)
            else:
                data_log2 = np.round(data_log2, 2)
                data_log10 = np.round(data_log10, 2)
                data_sqrt = np.round(data_sqrt, 2)
    
    # Create hover text with original values
    # If conn_df is provided, create type lookup for bodyId heatmaps
    type_lookup = None
    
    if conn_df is not None and 'bodyId_pre' in conn_df.columns and 'type_pre' in conn_df.columns:
        # Create lookup dictionaries for bodyId -> type
        # Convert bodyId keys to strings to match matrix index/columns
        type_lookup = {
            'pre': {str(k): v for k, v in conn_df.set_index('bodyId_pre')['type_pre'].to_dict().items()},
            'post': {str(k): v for k, v in conn_df.set_index('bodyId_post')['type_post'].to_dict().items()}
        }
    
    # Generate hover text with actual labels for all matrix sizes
    # No longer use compact mode - always show full information with proper labels
    hover_text = []
    for i, row_label in enumerate(cmat.index):
        hover_row = []
        for j, col_label in enumerate(cmat.columns):
            value = cmat.iloc[i, j]
            if metric_type == 'ratio' or metric_type == 'probability':
                value_str = f'{value:.4f}'
            else:
                value_str = f'{int(value):,}' if value == int(value) else f'{value:,.2f}'
            
            # Always use actual labels with type info if available
            if type_lookup:
                try:
                    # Labels are already strings, use them directly for type lookup
                    row_id = str(row_label)
                    col_id = str(col_label)
                    row_type = type_lookup['pre'].get(row_id, 'Unknown')
                    col_type = type_lookup['post'].get(col_id, 'Unknown')
                    hover_row.append(f'<b>Source:</b> {row_label} ({row_type})<br><b>Target:</b> {col_label} ({col_type})<br><b>{metric_type.capitalize()}:</b> {value_str}')
                except:
                    # Fall back to label-only display if type lookup fails
                    hover_row.append(f'<b>Source:</b> {row_label}<br><b>Target:</b> {col_label}<br><b>{metric_type.capitalize()}:</b> {value_str}')
            else:
                # No type info available - just show labels
                hover_row.append(f'<b>Source:</b> {row_label}<br><b>Target:</b> {col_label}<br><b>{metric_type.capitalize()}:</b> {value_str}')
        hover_text.append(hover_row)
    
    # Determine axis labels - ALWAYS use actual names, not numeric indices
    # Even for large matrices, show proper labels (optimization only affects hover text)
    x_labels = cmat.columns.astype(str).tolist()
    y_labels = cmat.index.astype(str).tolist()
    
    # Generate unique storage key for this heatmap
    from datetime import datetime
    output_name = os.path.splitext(os.path.basename(filename))[0]
    timestamp_hash = datetime.now().strftime('%Y%m%d%H%M%S')
    storage_key = f"heatmap_settings_{output_name}#{timestamp_hash}"
    
    # Determine default colorscale name
    default_colorscale = 'Greens'
    if 'ratio' in filename.lower():
        default_colorscale = 'Oranges'
    elif 'transmission' in filename.lower() or 'probability' in filename.lower():
        default_colorscale = 'Purples'
    
    # Create HTML with comprehensive interactive controls
    html_content = f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{title}</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            user-select: text;
        }}
        
        .main-container {{
            max-width: 1800px;
            margin: 0 auto;
        }}
        
        .controls {{
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }}
        
        .controls-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }}
        
        .control-section {{
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }}
        
        .control-section h3 {{
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }}
        
        .button-group {{
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }}
        
        button {{
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            color: #495057;
        }}
        
        button:hover {{
            background: #f8f9fa;
            border-color: #adb5bd;
        }}
        
        button.active {{
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }}
        
        button.export-btn {{
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }}
        
        button.export-btn:hover {{
            background: #1976D2;
            border-color: #1976D2;
        }}
        
        button.save-btn {{
            background: #FF9800;
            color: white;
            border-color: #FF9800;
        }}
        
        button.save-btn:hover {{
            background: #F57C00;
            border-color: #F57C00;
        }}
        
        select {{
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-size: 11px;
            background: white;
            cursor: pointer;
            color: #495057;
        }}
        
        select:focus {{
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
        }}
        
        .slider-control {{
            margin-bottom: 6px;
        }}
        
        .slider-control label {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
            font-size: 10px;
            color: #495057;
            font-weight: 500;
        }}
        
        .slider-value {{
            color: #4CAF50;
            font-weight: 600;
        }}
        
        input[type="range"] {{
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }}
        
        input[type="range"]::-webkit-slider-thumb {{
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            transition: all 0.2s;
        }}
        
        input[type="range"]::-webkit-slider-thumb:hover {{
            background: #45a049;
            transform: scale(1.15);
        }}
        
        input[type="range"]::-moz-range-thumb {{
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }}
        
        #heatmap-container {{
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }}
        
        #heatmap {{
            width: 100%;
            height: 1200px;
        }}
        
        .status-message {{
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            margin-top: 8px;
        }}
        
        .status-success {{
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }}
        
        .status-info {{
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }}
        
        .status-error {{
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }}
        
        .info-box {{
            background: #e7f3ff;
            border-left: 3px solid #2196F3;
            padding: 8px;
            border-radius: 3px;
            font-size: 10px;
            color: #1976D2;
            margin-top: 8px;
            line-height: 1.4;
        }}
        
        .info-box strong {{
            display: block;
            margin-bottom: 3px;
            font-size: 11px;
        }}
        
        .drag-item {{
            background: white;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 6px 8px;
            margin-bottom: 4px;
            cursor: move;
            user-select: none;
            display: flex;
            align-items: center;
            transition: all 0.2s;
        }}
        
        .drag-item:hover {{
            background: #f0f0f0;
            border-color: #4CAF50;
        }}
        
        .drag-item.dragging {{
            opacity: 0.5;
            background: #e3f2fd;
        }}
        
        .drag-item.drag-over {{
            border-top: 3px solid #4CAF50;
        }}
        
        .drag-handle {{
            margin-right: 6px;
            color: #999;
            font-size: 12px;
        }}
    </style>
</head>
<body>
    <div class="main-container">
        <div class="controls">
            <div class="controls-grid">
                <!-- Metric, Ordering & Scale Combined Section -->
                {'<div class="control-section" id="metricOrderingSection">' if has_multiple_metrics else '<div class="control-section">'}
                    {'<h3>üìä Metric, Ordering & Scale</h3>' if has_multiple_metrics else '<h3>üîÄ Ordering & Scale</h3>'}
                    
                    <!-- Metric Selection (if multiple metrics available) -->
                    {'<div style="margin-bottom: 8px;"><label style="font-size: 10px; display: block; margin-bottom: 2px;">Metric:</label>' if has_multiple_metrics else '<!-- Single metric mode -->'}
                    {'<select id="metricSelect" onchange="updateMetric()">' if has_multiple_metrics else ''}
                        {'<option value="weight">Synapse Count</option>' if has_multiple_metrics and 'weight' in available_metrics else ''}
                        {'<option value="ratio"' + (' selected' if metric_type == 'ratio' else '') + '>Connection Ratio</option>' if has_multiple_metrics and 'ratio' in available_metrics else ''}
                        {'<option value="probability"' + (' selected' if metric_type == 'probability' else '') + '>Traversal Probability</option>' if has_multiple_metrics and 'probability' in available_metrics else ''}
                    {'</select></div>' if has_multiple_metrics else ''}
                    
                    <!-- Clustering Toggle -->
                    <div style="margin-bottom: 8px;">
                        <label style="font-size: 10px; display: block; margin-bottom: 2px;">Ordering:</label>
                        <div class="button-group">
                            <button id="btn-original" class="active" onclick="toggleClustering('original')">Original</button>
                            <button id="btn-clustered" onclick="toggleClustering('clustered')">Clustered</button>
                        </div>
                    </div>
                    
                    <!-- Clustering Method Selection -->
                    <div id="clusteringMethodSection" style="margin-bottom: 8px; display: none;">
                        <label style="font-size: 10px; display: block; margin-bottom: 2px;">Clustering Method:</label>
                        <select id="clusteringMethodSelect" onchange="updateClusteringMethod()" style="width: 100%; font-size: 10px; padding: 4px;">
                            <option value="ward">Ward (Compact Clusters)</option>
                            <option value="average">Average (Balanced)</option>
                            <option value="complete">Complete (Tight Clusters)</option>
                            <option value="single">Single (Loose Clusters)</option>
                        </select>
                    </div>
                    
                    <!-- Scale Selection -->
                    <div>
                        <label style="font-size: 10px; display: block; margin-bottom: 2px;">Scale:</label>
                        <div class="button-group">
                            <button id="btn-linear" class="active" onclick="setScale('linear')">Linear</button>
                            <button id="btn-log2" onclick="setScale('log2')">Log‚ÇÇ</button>
                            <button id="btn-log10" onclick="setScale('log10')">Log‚ÇÅ‚ÇÄ</button>
                            <button id="btn-sqrt" onclick="setScale('sqrt')">‚àö</button>
                        </div>
                    </div>
                    
                    <!-- Data Filter -->
                    <div style="margin-top: 8px;">
                        <label style="font-size: 10px; display: block; margin-bottom: 2px;">
                            üîç Data Filter (hide rows/cols):
                            <button onclick="resetDataFilter()" style="padding: 2px 6px; font-size: 9px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px;" title="Reset filter">üîÑ</button>
                        </label>
                        <input type="text" id="dataFilterInput" placeholder="e.g., <5, <=10, >100" style="width: 100%; padding: 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;" oninput="applyDataFilter()">
                        <div id="filterStatus" style="font-size: 9px; color: #666; margin-top: 2px; min-height: 14px;"></div>
                    </div>
                </div>
                
                <!-- Color -->
                <div class="control-section" id="colorscaleSection">
                    <h3>üé® Color</h3>
                    <select id="colorscaleSelect" onchange="updateColorscale()" style="margin-bottom: 8px;">
                        <option value="Greens" {'selected' if default_colorscale == 'Greens' else ''}>Greens</option>
                        <option value="Purples" {'selected' if default_colorscale == 'Purples' else ''}>Purples</option>
                        <option value="Oranges" {'selected' if default_colorscale == 'Oranges' else ''}>Oranges</option>
                        <option value="Blues" {'selected' if default_colorscale == 'Blues' else ''}>Blues</option>
                        <option value="Reds">Reds</option>
                        <option value="Viridis">Viridis</option>
                        <option value="Plasma">Plasma</option>
                        <option value="Inferno">Inferno</option>
                        <option value="Magma">Magma</option>
                        <option value="Cividis">Cividis</option>
                        <option value="Hot">Hot</option>
                        <option value="Jet">Jet</option>
                        <option value="RdBu">Red-Blue (Diverging)</option>
                        <option value="RdYlGn">Red-Yellow-Green</option>
                        <option value="Custom">Custom</option>
                    </select>
                    
                    <div id="customColorSection">
                        <div style="margin-bottom: 6px;">
                            <label style="display: block; margin-bottom: 3px; font-size: 10px;">
                                <input type="checkbox" id="use3PointScale" onchange="toggle3PointScale()"> 
                                3-Point Scale (diverging)
                            </label>
                        </div>
                        <div id="twoPointColors">
                            <div style="margin-bottom: 4px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 2px;">Min (value):</label>
                                <div style="display: flex; gap: 4px;">
                                    <input type="color" id="colorMin" value="#ffffff" style="width: 40px; height: 26px; cursor: pointer;">
                                    <input type="number" id="valueMin2" placeholder="Auto" step="any" style="flex: 1; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;">
                                </div>
                            </div>
                            <div style="margin-bottom: 4px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 2px;">Max (value):</label>
                                <div style="display: flex; gap: 4px;">
                                    <input type="color" id="colorMax" value="#68379c" style="width: 40px; height: 26px; cursor: pointer;">
                                    <input type="number" id="valueMax2" placeholder="Auto" step="any" style="flex: 1; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;">
                                </div>
                            </div>
                        </div>
                        <div id="threePointColors" style="display: none;">
                            <div style="margin-bottom: 4px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 2px;">Min (value):</label>
                                <div style="display: flex; gap: 4px;">
                                    <input type="color" id="colorMin3" value="#0000ff" style="width: 40px; height: 26px; cursor: pointer;">
                                    <input type="number" id="valueMin3" value="0" step="any" style="flex: 1; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;">
                                </div>
                            </div>
                            <div style="margin-bottom: 4px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 2px;">Mid (value):</label>
                                <div style="display: flex; gap: 4px;">
                                    <input type="color" id="colorMid3" value="#ffffff" style="width: 40px; height: 26px; cursor: pointer;">
                                    <input type="number" id="valueMid3" value="0.5" step="any" style="flex: 1; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;">
                                </div>
                            </div>
                            <div style="margin-bottom: 4px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 2px;">Max (value):</label>
                                <div style="display: flex; gap: 4px;">
                                    <input type="color" id="colorMax3" value="#ff0000" style="width: 40px; height: 26px; cursor: pointer;">
                                    <input type="number" id="valueMax3" value="1" step="any" style="flex: 1; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;">
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 4px; margin-top: 4px;">
                            <button onclick="applyCustomColors()" style="flex: 1; font-size: 10px;">Apply</button>
                            <button onclick="resetToAutoColors()" style="flex: 1; font-size: 10px;">Auto</button>
                        </div>
                    </div>
                </div>
                
                <!-- Font Size & Colorbar Settings -->
                <div class="control-section">
                    <h3>üéöÔ∏è Display</h3>
                    <div class="slider-control">
                        <label>
                            <span>Font Size:</span>
                            <span class="slider-value" id="fontSizeValue">{fontsize}px</span>
                        </label>
                        <input type="range" id="fontSizeSlider" min="8" max="48" value="{fontsize}" step="1" oninput="updateFontSize(this.value)">
                    </div>
                    <div style="margin-top: 8px; display: flex; gap: 4px;">
                        <button id="toggleLabelsBtn" onclick="toggleLabels()" style="flex: 1;">
                            {'üè∑Ô∏è Hide Text' if not is_large else 'üè∑Ô∏è Show Text'}
                        </button>
                        <button id="toggleCellValuesBtn" onclick="toggleCellValues()" style="flex: 1;">
                            üî¢ Hide Values
                        </button>
                    </div>
                    <div class="slider-control" style="margin-top: 8px;">
                        <label>
                            <span>Cell Value Size:</span>
                            <span class="slider-value" id="cellValueSizeValue">10px</span>
                        </label>
                        <input type="range" id="cellValueSizeSlider" min="6" max="48" value="10" step="1" oninput="updateCellValueSize(this.value)">
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 11px; display: block; margin-bottom: 4px;">Ignore Values (comma-separated):</label>
                        <input type="text" id="ignoreValuesInput" placeholder="e.g., 0, >20, <=5" style="width: 100%; padding: 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;" oninput="updateIgnoredValues()">
                    </div>
                    <div class="slider-control" style="margin-top: 8px;">
                        <label>
                            <span>Contrast Threshold:</span>
                            <span class="slider-value" id="contrastThresholdValue">0.5000</span>
                            <button onclick="reverseContrastColors()" style="padding: 2px 6px; font-size: 10px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px;" title="Reverse black/white colors">üîÑ</button>
                        </label>
                        <input type="range" id="contrastThresholdSlider" min="0" max="1" value="0.5" step="0.0001" oninput="updateContrastThreshold(this.value)">
                    </div>
                </div>
                
                <!-- Plot Dimensions -->
                <div class="control-section">
                    <h3>üìê Plot Size</h3>
                    <div class="slider-control">
                        <label>
                            <span>Width:</span>
                            <span class="slider-value" id="widthValue">800px</span>
                        </label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="range" id="widthSlider" min="400" max="2400" value="800" step="20" oninput="updatePlotSize()" style="flex: 1;">
                            <input type="number" id="widthInput" value="800" min="100" step="20" style="width: 70px; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;" oninput="updatePlotSizeFromInput()">
                        </div>
                    </div>
                    <div class="slider-control">
                        <label>
                            <span>Height:</span>
                            <span class="slider-value" id="heightValue">800px</span>
                        </label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="range" id="heightSlider" min="400" max="2400" value="800" step="20" oninput="updatePlotSize()" style="flex: 1;">
                            <input type="number" id="heightInput" value="800" min="100" step="20" style="width: 70px; padding: 2px 4px; font-size: 10px; border: 1px solid #dee2e6; border-radius: 3px;" oninput="updatePlotSizeFromInput()">
                        </div>
                    </div>
                    <div style="display: flex; gap: 4px;">
                        <button id="squareCellsBtn" onclick="makeSquareCells()" style="flex: 1;">‚¨ú Square Cells</button>
                        <button onclick="resetPlotSize()" style="flex: 1;">üîÑ Reset</button>
                    </div>
                    <div style="margin-top: 8px;">
                        <button id="transposeBtn" onclick="transposeMatrix()" style="width: 100%;">üîÑ Swap Rows ‚Üî Columns</button>
                    </div>
                </div>
                
                <!-- Row/Column Ordering -->
                <div class="control-section">
                    <h3>üìã Row/Column Order</h3>
                    <button onclick="toggleOrderPanel('rows')" style="width: 100%; font-size: 10px; margin-bottom: 4px;">üìë Reorder Rows</button>
                    <button onclick="toggleOrderPanel('cols')" style="width: 100%; font-size: 10px; margin-bottom: 4px;">üìë Reorder Columns</button>
                    <button onclick="resetOrder()" style="width: 100%; font-size: 10px;">üîÑ Reset to Original</button>
                    
                </div>
                
                <!-- Export & Saving -->
                <div class="control-section">
                    <h3>üíæ Export & Saving</h3>
                    <div class="slider-control" style="margin-bottom: 8px;">
                        <label>
                            <span>Export Scale:</span>
                            <span class="slider-value" id="exportScaleValue">2x</span>
                        </label>
                        <input type="range" id="exportScaleSlider" min="1" max="5" value="2" step="0.5" oninput="updateExportScale(this.value)">
                    </div>
                    <div class="button-group" style="flex-direction: column; margin-bottom: 8px;">
                        <button class="export-btn" onclick="exportSVG()" style="width: 100%;">üì• Export SVG</button>
                    </div>
                    <div class="button-group">
                        <button class="save-btn" onclick="saveSettings()">üíæ Save</button>
                        <button class="save-btn" onclick="loadSettings()">üìÇ Load</button>
                        <button onclick="resetSettings()">üîÑ Reset</button>
                    </div>
                    <div id="settingsStatus"></div>
                </div>
            </div>
            
            <div class="info-box">
                <strong>üí° Tips:</strong>
                Use Log‚ÇÇ or Log‚ÇÅ‚ÇÄ scales for large dynamic ranges ‚Ä¢ 
                Adjust plot size with width/height sliders for better visualization ‚Ä¢ 
                Use export scale (1x-5x) to control SVG resolution ‚Ä¢ 
                3-point custom colors ideal for diverging data (negative ‚Üí zero ‚Üí positive) ‚Ä¢ 
                Hover over cells for details ‚Ä¢ 
                Zoom and pan with mouse ‚Ä¢ 
                Settings persist across sessions
            </div>
        </div>
        
        <div id="heatmap-container">
            <div id="heatmap"></div>
        </div>
    </div>
    
    <!-- Floating Reorder Panel -->
    <div id="orderPanel" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                 background: white; border: 2px solid #333; border-radius: 8px; padding: 16px; 
                                 box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; min-width: 300px; max-width: 400px; 
                                 max-height: 70vh; flex-direction: column; display: none;">
        <div style="margin-bottom: 12px; border-bottom: 2px solid #ddd; padding-bottom: 8px;">
            <label id="orderPanelLabel" style="font-size: 14px; font-weight: bold; color: #333;"></label>
        </div>
        <div id="orderList" style="font-size: 12px; overflow-y: auto; flex: 1; margin-bottom: 12px;"></div>
        <button onclick="closeOrderPanel()" style="width: 100%; font-size: 12px; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">‚úì Close</button>
    </div>
    
    <!-- Overlay backdrop for floating panel -->
    <div id="orderPanelBackdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                                        background: rgba(0,0,0,0.5); z-index: 9999;" onclick="closeOrderPanel()"></div>
    
    <script>
        // Metric toggle support
        const availableMetrics = {json.dumps(available_metrics)};
        const hasMultipleMetrics = availableMetrics.length > 1;
        let currentMetric = '{metric_type}';
        
        // Store all metric matrices
        const metricsData = {{}};
'''
    
    # Add metric data assignments
    for metric in available_metrics:
        html_content += f"        metricsData['{metric}'] = {json.dumps(matrices_data[metric].tolist())};\n"
    
    html_content += f'''
        
        // Data for different scales
        const sparseData = {json.dumps(sparse_data) if sparse_data is not None else 'null'};
        const useSparseFormat = sparseData !== null;
        
        // Get current metric data
        let dataLinear = metricsData[currentMetric];
        
        const dataLog2 = {'null' if data_log2 is None else json.dumps(data_log2.tolist())};
        const dataLog10 = {'null' if data_log10 is None else json.dumps(data_log10.tolist())};
        const dataSqrt = {'null' if data_sqrt is None else json.dumps(data_sqrt.tolist())};
        const xLabels = {json.dumps(x_labels)};
        const yLabels = {json.dumps(y_labels)};
        const storageKey = '{storage_key}';
        const useLazyTransforms = {json.dumps(use_lazy_transforms)};
        
        // Track current row/column order (for interactive reordering)
        let currentXLabels = xLabels.slice();
        let currentYLabels = yLabels.slice();
        
        // Hover text - always use full array with proper labels (no compact mode)
        const hoverText = {json.dumps(hover_text)};
        
        // Cache for lazy-computed transforms
        let cachedDataLog2 = null;
        let cachedDataLog10 = null;
        let cachedDataSqrt = null;
        
        // Clustering data - row and column orders for all methods
        const rowOrderOriginal = {json.dumps(row_order_original)};
        const colOrderOriginal = {json.dumps(col_order_original)};
        const clusteringAvailable = {json.dumps(clustering_successful)};
        
        // All clustering method results
        const clusteringResults = {json.dumps(clustering_results)};
        
        // Default to Ward method
        const rowOrderClustered = {json.dumps(row_order_clustered.tolist())};
        const colOrderClustered = {json.dumps(col_order_clustered.tolist())};
        
        // Current settings
        let currentScale = 'linear';
        let currentColorscale = '{default_colorscale}';
        let currentFontSize = {fontsize};
        let useAutoRange = true;
        let customZmin = null;
        let customZmax = null;
        let customColorScale = null;  // Store custom color scale
        let use3PointScale = false;
        let currentWidth = 800;
        let currentHeight = 800;
        let exportScale = 2;
        let squareCellsLocked = false;  // Track if square cells are locked
        let showLabels = !{json.dumps(is_large)};  // Show labels for small matrices, hide for large
        let showCellValues = true;  // Track if cell values should be displayed in cells (default: true)
        let cellValueFontSize = 10;  // Font size for cell value annotations
        let ignoredValues = new Set();  // Set of values to ignore when displaying cell values
        let contrastThreshold = 0.5;  // Luminance threshold for contrast color (0-1, default: 0.5)
        let reverseContrast = false;  // Whether to reverse black/white contrast colors
        let useClusteredOrder = false;  // Track current ordering mode
        let currentClusteringMethod = 'ward';  // Current clustering method (ward, average, complete, single)
        let isTransposed = false;  // Track if matrix is transposed
        const metricType = '{metric_type}';
        const isLarge = {json.dumps(is_large)};
        const originalTitle = '{title}';
        
        // Data filter state
        let dataFilterActive = false;
        let dataFilterExpressions = [];
        let filteredRowIndices = [];  // Indices of rows to show after filtering
        let filteredColIndices = [];  // Indices of columns to show after filtering
        
        // Function to generate hover text dynamically when needed
        // Hover text is pre-generated in Python with proper labels
        // This function regenerates it when switching metrics (multi-metric mode)
        function generateHoverText() {{
            if (!hasMultipleMetrics) {{
                return hoverText;  // Use pre-generated hover text for single-metric mode
            }}
            
            // Generate hover text on-the-fly for multi-metric mode
            const rows = dataLinear.length;
            const cols = dataLinear[0].length;
            const result = new Array(rows);
            
            // Get metric display name
            const metricNames = {{
                'weight': 'Synapses',
                'ratio': 'Ratio',
                'probability': 'Probability'
            }};
            const currentMetricName = metricNames[currentMetric] || currentMetric;
            
            for (let i = 0; i < rows; i++) {{
                result[i] = new Array(cols);
                for (let j = 0; j < cols; j++) {{
                    const value = dataLinear[i][j];
                    let valueStr;
                    if (currentMetric === 'ratio' || currentMetric === 'probability') {{
                        valueStr = value.toFixed(4);
                    }} else {{
                        valueStr = Math.floor(value) === value ? 
                            value.toLocaleString() : 
                            value.toLocaleString(undefined, {{minimumFractionDigits: 2, maximumFractionDigits: 2}});
                    }}

                    // Always use actual labels from yLabels and xLabels
                    const srcLabel = yLabels[i];
                    const tgtLabel = xLabels[j];
                    result[i][j] = '<b>Source:</b> ' + srcLabel + '<br><b>Target:</b> ' + tgtLabel + '<br><b>' + currentMetricName + ':</b> ' + valueStr;
                }}
            }}
            return result;
        }}
        
        function getDataForScale(scale) {{
            if (!useLazyTransforms) {{
                // Use pre-computed data for small matrices
                switch(scale) {{
                    case 'log2': return dataLog2;
                    case 'log10': return dataLog10;
                    case 'sqrt': return dataSqrt;
                    default: return dataLinear;
                }}
            }}
            
            // Lazy computation for large matrices
            switch(scale) {{
                case 'log2':
                    if (cachedDataLog2 === null) {{
                        console.log('Computing log‚ÇÇ transform...');
                        cachedDataLog2 = dataLinear.map(row => row.map(v => {{
                            // Handle negative values: sign(v) * log2(|v| + 1)
                            if (v < 0) return -Math.log2(-v + 1);
                            return Math.log2(v + 1);
                        }}));
                    }}
                    return cachedDataLog2;
                case 'log10':
                    if (cachedDataLog10 === null) {{
                        console.log('Computing log‚ÇÅ‚ÇÄ transform...');
                        cachedDataLog10 = dataLinear.map(row => row.map(v => {{
                            // Handle negative values: sign(v) * log10(|v| + 1)
                            if (v < 0) return -Math.log10(-v + 1);
                            return Math.log10(v + 1);
                        }}));
                    }}
                    return cachedDataLog10;
                case 'sqrt':
                    if (cachedDataSqrt === null) {{
                        console.log('Computing ‚àö transform...');
                        cachedDataSqrt = dataLinear.map(row => row.map(v => {{
                            // Handle negative values: sign(v) * sqrt(|v|)
                            if (v < 0) return -Math.sqrt(-v);
                            return Math.sqrt(v);
                        }}));
                    }}
                    return cachedDataSqrt;
                default:
                    return dataLinear;
            }}
        }}
        
        function getScaleLabel(scale) {{
            switch(scale) {{
                case 'log2': return ' (log‚ÇÇ)';
                case 'log10': return ' (log‚ÇÅ‚ÇÄ)';
                case 'sqrt': return ' (‚àö)';
                default: return '';
            }}
        }}
        
        function getDataRange(data) {{
            let min = Infinity;
            let max = -Infinity;
            for (let row of data) {{
                for (let val of row) {{
                    if (val < min) min = val;
                    if (val > max) max = val;
                }}
            }}
            return {{min, max}};
        }}
        
        function reorderData(data, rowOrder, colOrder) {{
            // Reorder rows and columns of the data matrix according to given orders
            const reordered = new Array(rowOrder.length);
            for (let i = 0; i < rowOrder.length; i++) {{
                reordered[i] = new Array(colOrder.length);
                for (let j = 0; j < colOrder.length; j++) {{
                    reordered[i][j] = data[rowOrder[i]][colOrder[j]];
                }}
            }}
            return reordered;
        }}
        
        function reorderLabels(labels, order) {{
            // Reorder labels according to given order
            const reordered = new Array(order.length);
            for (let i = 0; i < order.length; i++) {{
                reordered[i] = labels[order[i]];
            }}
            return reordered;
        }}
        
        function reorderHoverText(hoverText, rowOrder, colOrder) {{
            // Reorder hover text according to given orders
            if (hoverText === null) return null;
            const reordered = new Array(rowOrder.length);
            for (let i = 0; i < rowOrder.length; i++) {{
                reordered[i] = new Array(colOrder.length);
                for (let j = 0; j < colOrder.length; j++) {{
                    reordered[i][j] = hoverText[rowOrder[i]][colOrder[j]];
                }}
            }}
            return reordered;
        }}
        
        function createHeatmap() {{
            // Safety check: ensure data is available
            if (!dataLinear || dataLinear.length === 0) {{
                console.error('Cannot create heatmap: data not available');
                return;
            }}
            
            let data = getDataForScale(currentScale);
            let dataOriginal = dataLinear.map(row => row.slice()); // Keep original for cell values
            const scaleLabel = getScaleLabel(currentScale);
            
            // Determine which labels to use based on transpose state
            let displayXLabels, displayYLabels;
            let currentHoverText = generateHoverText();
            
            if (isTransposed) {{
                // When transposed: rows become columns, columns become rows
                // So we use the swapped tracking variables
                displayXLabels = currentYLabels.slice();
                displayYLabels = currentXLabels.slice();
                
                // Transpose the data matrix
                data = data[0].map((_, colIndex) => data.map(row => row[colIndex]));
                dataOriginal = dataOriginal[0].map((_, colIndex) => dataOriginal.map(row => row[colIndex]));
                
                // Transpose hover text if available
                if (currentHoverText !== null) {{
                    currentHoverText = currentHoverText[0].map((_, colIndex) => 
                        currentHoverText.map(row => row[colIndex])
                    );
                }}
                
                // Now apply reordering based on current tracked order (already transposed)
                const baseXLabels = yLabels;
                const baseYLabels = xLabels;
                
                const rowMapping = displayYLabels.map(label => baseYLabels.indexOf(label));
                const colMapping = displayXLabels.map(label => baseXLabels.indexOf(label));
                
                // Reorder transposed data
                data = rowMapping.map(rowIdx => 
                    colMapping.map(colIdx => data[rowIdx][colIdx])
                );
                dataOriginal = rowMapping.map(rowIdx => 
                    colMapping.map(colIdx => dataOriginal[rowIdx][colIdx])
                );
                
                // Reorder hover text if available
                if (currentHoverText !== null) {{
                    currentHoverText = rowMapping.map(rowIdx => 
                        colMapping.map(colIdx => currentHoverText[rowIdx][colIdx])
                    );
                }}
            }} else {{
                // Normal (non-transposed) mode
                displayXLabels = currentXLabels.slice();
                displayYLabels = currentYLabels.slice();
                
                // Apply reordering if different from base labels
                const baseXLabels = xLabels;
                const baseYLabels = yLabels;
                
                const needsRowReorder = !arraysEqual(displayYLabels, baseYLabels);
                const needsColReorder = !arraysEqual(displayXLabels, baseXLabels);
                
                if (needsRowReorder || needsColReorder) {{
                    const rowMapping = displayYLabels.map(label => baseYLabels.indexOf(label));
                    const colMapping = displayXLabels.map(label => baseXLabels.indexOf(label));
                    
                    // Reorder data matrix
                    data = rowMapping.map(rowIdx => 
                        colMapping.map(colIdx => data[rowIdx][colIdx])
                    );
                    dataOriginal = rowMapping.map(rowIdx => 
                        colMapping.map(colIdx => dataOriginal[rowIdx][colIdx])
                    );
                    
                    // Reorder hover text if available
                    if (currentHoverText !== null) {{
                        currentHoverText = rowMapping.map(rowIdx => 
                            colMapping.map(colIdx => currentHoverText[rowIdx][colIdx])
                        );
                    }}
                }}
            }}
            
            // Apply clustering reordering if enabled (after transpose and custom reordering)
            if (useClusteredOrder && clusteringAvailable) {{
                // Get clustering results for the selected method
                const selectedMethod = clusteringResults[currentClusteringMethod];
                let methodRowOrder = rowOrderClustered;
                let methodColOrder = colOrderClustered;
                
                if (selectedMethod) {{
                    methodRowOrder = selectedMethod.row_order;
                    methodColOrder = selectedMethod.col_order;
                }} else {{
                    console.warn('Clustering method not found:', currentClusteringMethod, '- using default');
                }}
                
                // When transposed, swap the cluster orders to match the transposed dimensions
                const effectiveRowOrder = isTransposed ? methodColOrder : methodRowOrder;
                const effectiveColOrder = isTransposed ? methodRowOrder : methodColOrder;
                
                data = reorderData(data, effectiveRowOrder, effectiveColOrder);
                dataOriginal = reorderData(dataOriginal, effectiveRowOrder, effectiveColOrder);
                displayXLabels = reorderLabels(displayXLabels, effectiveColOrder);
                displayYLabels = reorderLabels(displayYLabels, effectiveRowOrder);
                // Reorder hover text if available
                if (currentHoverText !== null) {{
                    currentHoverText = reorderHoverText(currentHoverText, effectiveRowOrder, effectiveColOrder);
                }}
            }}
            
            // Apply data filter if active (hide rows/columns based on their max values)
            if (dataFilterActive && filteredRowIndices.length > 0 && filteredColIndices.length > 0) {{
                // Filter data matrix
                data = filteredRowIndices.map(rowIdx => 
                    filteredColIndices.map(colIdx => data[rowIdx][colIdx])
                );
                dataOriginal = filteredRowIndices.map(rowIdx => 
                    filteredColIndices.map(colIdx => dataOriginal[rowIdx][colIdx])
                );
                
                // Filter labels
                displayXLabels = filteredColIndices.map(idx => displayXLabels[idx]);
                displayYLabels = filteredRowIndices.map(idx => displayYLabels[idx]);
                
                // Filter hover text if available
                if (currentHoverText !== null) {{
                    currentHoverText = filteredRowIndices.map(rowIdx => 
                        filteredColIndices.map(colIdx => currentHoverText[rowIdx][colIdx])
                    );
                }}
                
                console.log(`Data filter: showing ${{filteredRowIndices.length}} rows √ó ${{filteredColIndices.length}} cols`);
            }}
            
            const range = getDataRange(data);
            
            // Determine which colorscale to use
            let colorscaleToUse;
            
            // Check if we should use custom colorscale
            if (currentColorscale === 'Custom' && customColorScale && Array.isArray(customColorScale) && customColorScale.length > 0) {{
                // Use the custom colorscale array directly
                colorscaleToUse = customColorScale;
                console.log('‚úì createHeatmap: Using CUSTOM colorscale:', {{
                    scale: customColorScale,
                    length: customColorScale.length,
                    positions: customColorScale.map(c => c[0])
                }});
            }} else {{
                // For preset colorscales, convert to array format for Plotly compatibility
                // Plotly v1.58.5 doesn't recognize all colorscale names, so we define them explicitly
                colorscaleToUse = getPlotlyColorscaleArray(currentColorscale);
                console.log('createHeatmap: Using preset colorscale:', {{
                    name: currentColorscale,
                    isArray: Array.isArray(colorscaleToUse),
                    length: Array.isArray(colorscaleToUse) ? colorscaleToUse.length : 'N/A'
                }});
            }}
            
            // Get metric display name for colorbar
            const metricDisplayNames = {{
                'weight': 'Synapses',
                'ratio': 'Ratio',
                'probability': 'Probability'
            }};
            const metricDisplayName = metricDisplayNames[currentMetric] || currentMetric;
            
            const trace = {{
                z: data,
                x: displayXLabels.map((_, i) => i),  // Use indices for positioning
                y: displayYLabels.map((_, i) => i),  // Use indices for positioning
                type: 'heatmap',
                colorscale: colorscaleToUse,
                colorbar: {{
                    title: metricDisplayName + scaleLabel,
                    titleside: 'right'
                }}
            }};
            
            // Configure text display for cell values
            console.log('createHeatmap: showCellValues =', showCellValues);
            if (showCellValues) {{
                // Show cell values: use texttemplate to display z values
                console.log('Setting texttemplate to show cell values');
                
                // Create a text array from the data for display
                const textArray = data.map(row => row.map(val => val.toString()));
                
                trace.text = textArray;  // Text array for display
                trace.texttemplate = '%{{text}}';  // Use the text array
                trace.textfont = {{
                    size: Math.max(8, Math.min(16, currentFontSize * 0.8))
                }};
                // For hover, use the detailed hover text
                trace.hovertext = currentHoverText;
                trace.hoverinfo = 'text';
                trace.hovertemplate = '%{{hovertext}}<extra></extra>';  // <extra></extra> hides "trace 0"
            }} else {{
                // Hide cell values: no texttemplate, only hover text
                console.log('NOT setting texttemplate - hiding cell values');
                trace.text = currentHoverText;  // Text for hover only
                trace.hoverinfo = 'text';  // Show hover text on hover
                trace.hovertemplate = '%{{text}}<extra></extra>';  // <extra></extra> hides "trace 0"
            }}
            console.log('trace texttemplate:', trace.texttemplate);
            console.log('trace text sample:', trace.text ? trace.text[0] : 'none');
            
            // Apply custom colorbar range
            // Priority: 1) Custom color range (for cross-heatmap comparison)
            //           2) Manual slider range (if not auto)
            //           3) Auto range (default)
            if (window.customColorRange) {{
                trace.zmin = window.customColorRange.min;
                trace.zmax = window.customColorRange.max;
                console.log('Using custom color range:', window.customColorRange);
            }} else if (!useAutoRange && customZmin !== null && customZmax !== null) {{
                trace.zmin = customZmin;
                trace.zmax = customZmax;
            }}
            
            // Store current range for slider scaling
            window.currentDataRange = range;
            
            // Update 2-point color value inputs to show current data range in auto mode
            if (!window.customColorRange) {{
                document.getElementById('valueMin2').value = formatValueDisplay(range.min);
                document.getElementById('valueMax2').value = formatValueDisplay(range.max);
            }}
            
            // Determine axis titles based on transpose state
            const xAxisLabel = isTransposed ? 'Source' : 'Target';
            const yAxisLabel = isTransposed ? 'Target' : 'Source';
            const xAxisCount = displayXLabels.length;
            const yAxisCount = displayYLabels.length;
            
            const layout = {{
                title: originalTitle,
                font: {{size: currentFontSize}},
                autosize: false,
                xaxis: {{
                    title: isLarge ? '<b>' + xAxisLabel + '</b> (' + xAxisCount + ' neurons)' : '<b>' + xAxisLabel + '</b>',
                    side: 'bottom',
                    titlefont: {{size: currentFontSize + 2, color: '#333333'}},
                    tickangle: displayXLabels.length > 1 ? -45 : 0,  // Always rotate when multiple labels
                    showticklabels: showLabels,
                    tickmode: 'array',  // Use explicit tick values
                    tickvals: displayXLabels.map((_, i) => i),  // Use indices as tick positions
                    ticktext: displayXLabels  // Use labels as tick text
                }},
                yaxis: {{
                    title: isLarge ? '<b>' + yAxisLabel + '</b> (' + yAxisCount + ' neurons)' : '<b>' + yAxisLabel + '</b>',
                    side: 'left',
                    titlefont: {{size: currentFontSize + 2, color: '#333333'}},
                    autorange: 'reversed',
                    showticklabels: showLabels,
                    tickmode: 'array',  // Use explicit tick values
                    tickvals: displayYLabels.map((_, i) => i),  // Use indices as tick positions
                    ticktext: displayYLabels  // Use labels as tick text
                }},
                hoverlabel: {{
                    bgcolor: 'white',
                    font_size: 12,
                    font_family: 'Arial'
                }},
                width: currentWidth,
                height: currentHeight,
                margin: {{l: 120, r: 40, b: 120, t: 100, pad: 4}}
            }};
            
            const config = {{
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                toImageButtonOptions: {{
                    format: 'png',
                    filename: 'heatmap_' + currentScale,
                    height: currentHeight,
                    width: currentWidth,
                    scale: exportScale
                }}
            }};
            
            // Add cell value annotations if enabled
            if (showCellValues) {{
                const annotations = [];
                
                // Get the actual zmin/zmax for color mapping
                const actualZmin = trace.zmin !== undefined ? trace.zmin : range.min;
                const actualZmax = trace.zmax !== undefined ? trace.zmax : range.max;
                
                for (let i = 0; i < data.length; i++) {{
                    for (let j = 0; j < data[i].length; j++) {{
                        const scaledValue = data[i][j];  // Scaled value for color
                        const originalValue = dataOriginal[i][j];  // Original value for display
                        
                        // Skip this value if it matches ignore criteria (exact value or expression)
                        if (shouldIgnoreValue(originalValue)) {{
                            continue;
                        }}
                        
                        // Calculate the background color for this cell using scaled value
                        const normalized = (scaledValue - actualZmin) / (actualZmax - actualZmin);
                        
                        // Get color from the colorscale
                        let bgColor = 'rgb(128, 128, 128)';  // default gray
                        if (Array.isArray(colorscaleToUse)) {{
                            // For custom colorscales - interpolate between color stops
                            bgColor = interpolateColorscale(colorscaleToUse, normalized);
                        }} else {{
                            // For named colorscales, get color from Plotly's colorscale
                            bgColor = getColorFromPlotlyScale(colorscaleToUse, normalized);
                        }}
                        
                        // Convert color to RGB and determine contrast color
                        const rgb = hexToRgb(bgColor);
                        const textColor = getContrastColor(rgb);
                        
                        // Debug logging for first few cells
                        if (i === 0 && j < 3) {{
                            const luminance = 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2];
                            console.log(`Cell [${{i}},${{j}}] original=${{originalValue}}, scaled=${{scaledValue}}, normalized=${{normalized.toFixed(3)}}, bgColor=${{bgColor}}, rgb=[${{rgb}}], luminance=${{luminance.toFixed(1)}}, threshold=${{(contrastThreshold * 255).toFixed(1)}}, textColor=${{textColor}}`);
                        }}
                        
                        annotations.push({{
                            x: j,  // Use index for positioning
                            y: i,  // Use index for positioning
                            text: String(originalValue),  // Display original value
                            showarrow: false,
                            font: {{
                                size: cellValueFontSize,
                                color: textColor
                            }},
                            xref: 'x',
                            yref: 'y'
                        }});
                    }}
                }}
                layout.annotations = annotations;
                console.log('Added', annotations.length, 'annotations for cell values with adaptive colors');
            }}
            
            Plotly.newPlot('heatmap', [trace], layout, config);
        }}
        
        function toggleClustering(mode) {{
            // Toggle between original and clustered ordering
            useClusteredOrder = (mode === 'clustered');
            
            // Update button states
            document.getElementById('btn-original').classList.toggle('active', mode === 'original');
            document.getElementById('btn-clustered').classList.toggle('active', mode === 'clustered');
            
            // Show/hide clustering method selector
            const methodSection = document.getElementById('clusteringMethodSection');
            if (methodSection) {{
                methodSection.style.display = (mode === 'clustered' && clusteringAvailable) ? 'block' : 'none';
            }}
            
            // If clustering is not available, show message and revert
            if (mode === 'clustered' && !clusteringAvailable) {{
                alert('Clustering is not available for this matrix. Using original order.');
                useClusteredOrder = false;
                document.getElementById('btn-original').classList.add('active');
                document.getElementById('btn-clustered').classList.remove('active');
                return;
            }}
            
            // Update data filter state (disables when clustering is active)
            applyDataFilter();
            
            // Recreate heatmap with new ordering
            createHeatmap();
        }}
        
        function updateClusteringMethod() {{
            // Get selected clustering method
            const methodSelect = document.getElementById('clusteringMethodSelect');
            currentClusteringMethod = methodSelect.value;
            
            console.log('Switching to clustering method:', currentClusteringMethod);
            
            // Update the heatmap with new clustering method
            if (useClusteredOrder) {{
                createHeatmap();
            }}
        }}
        
        function setScale(scale) {{
            currentScale = scale;
            
            // Update button states
            document.querySelectorAll('[id^="btn-"]').forEach(btn => {{
                btn.classList.remove('active');
            }});
            document.getElementById('btn-' + scale).classList.add('active');
            
            createHeatmap();
        }}
        
        function updateMetric() {{
            // Switch to the selected metric
            currentMetric = document.getElementById('metricSelect').value;
            console.log('Switching to metric:', currentMetric);
            
            // Update dataLinear with the new metric's data (always use original ordering)
            dataLinear = metricsData[currentMetric];
            
            // Clear cached transforms so they're recomputed for new metric
            cachedDataLog2 = null;
            cachedDataLog10 = null;
            cachedDataSqrt = null;
            
            // Recreate the heatmap with new metric data (clustering will be applied in createHeatmap)
            createHeatmap();
        }}
        
        function updateColorscale() {{
            currentColorscale = document.getElementById('colorscaleSelect').value;
            
            // If switching to Custom and no custom scale exists, create default
            if (currentColorscale === 'Custom' && !customColorScale) {{
                applyCustomColors();
            }}
            
            createHeatmap();
        }}
        
        function toggleCustomColorPanel() {{
            const panel = document.getElementById('customColorPanel');
            if (panel.style.display === 'none') {{
                panel.style.display = 'block';
            }} else {{
                panel.style.display = 'none';
            }}
        }}
        
        function toggle3PointScale() {{
            use3PointScale = document.getElementById('use3PointScale').checked;
            const twoPoint = document.getElementById('twoPointColors');
            const threePoint = document.getElementById('threePointColors');
            
            if (use3PointScale) {{
                twoPoint.style.display = 'none';
                threePoint.style.display = 'block';
                
                // Set default values based on current data range
                if (window.currentDataRange) {{
                    const range = window.currentDataRange;
                    const mid = (range.min + range.max) / 2;
                    document.getElementById('valueMin3').value = formatValueDisplay(range.min);
                    document.getElementById('valueMid3').value = formatValueDisplay(mid);
                    document.getElementById('valueMax3').value = formatValueDisplay(range.max);
                }}
            }} else {{
                twoPoint.style.display = 'block';
                threePoint.style.display = 'none';
            }}
        }}
        
        function rgbToPlotlyFormat(hex) {{
            // Convert hex color to RGB format for Plotly
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgb(${{r}},${{g}},${{b}})`;
        }}
        
        // Helper function to compare two arrays for equality
        function arraysEqual(arr1, arr2) {{
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {{
                if (arr1[i] !== arr2[i]) return false;
            }}
            return true;
        }}
        
        function formatValueDisplay(value) {{
            // Format number to remove trailing zeros and unnecessary decimal point
            // Examples: 0.000000 -> "0", 250.123456 -> "250.123456", 1.500000 -> "1.5"
            if (value === 0) return "0";
            const str = value.toFixed(6);
            // Remove trailing zeros and decimal point if not needed
            return str.replace(/\.?0+$/, '');
        }}
        
        function applyCustomColors() {{
            if (use3PointScale) {{
                // 3-point scale with custom value mapping
                const colorMin = document.getElementById('colorMin3').value;
                const colorMid = document.getElementById('colorMid3').value;
                const colorMax = document.getElementById('colorMax3').value;
                
                const valueMin = parseFloat(document.getElementById('valueMin3').value);
                const valueMid = parseFloat(document.getElementById('valueMid3').value);
                const valueMax = parseFloat(document.getElementById('valueMax3').value);
                
                // Get current data range
                const range = window.currentDataRange;
                if (!range) {{
                    alert('Please wait for data to load before applying custom colors.');
                    return;
                }}
                
                // Map custom values to [0, 1] range - allows values beyond actual data range
                const normalizeValue = (val, rangeMin, rangeMax) => {{
                    if (rangeMax === rangeMin) return 0.5;
                    return (val - rangeMin) / (rangeMax - rangeMin);
                }};
                
                // Use custom value range for normalization (allows cross-heatmap comparison)
                const customRangeMin = valueMin;
                const customRangeMax = valueMax;
                
                if (customRangeMax === customRangeMin) {{
                    alert('Custom min and max values cannot be the same.');
                    return;
                }}
                
                // Map custom value points to [0, 1] colorscale positions
                // This defines where each color appears on the scale
                const posMid = normalizeValue(valueMid, customRangeMin, customRangeMax);
                
                // Clamp mid position to [0, 1]
                const clampedPosMid = Math.max(0, Math.min(1, posMid));
                
                // Create color scale array spanning 0 to 1
                // Plotly will map data values to this scale based on customColorRange
                customColorScale = [
                    [0, rgbToPlotlyFormat(colorMin)],
                    [clampedPosMid, rgbToPlotlyFormat(colorMid)],
                    [1, rgbToPlotlyFormat(colorMax)]
                ];
                
                // Set custom range for Plotly to use
                window.customColorRange = {{min: valueMin, max: valueMax}};
                
                // Sort by position (required by Plotly)
                customColorScale.sort((a, b) => a[0] - b[0]);
                
                // Ensure positions are distinct (avoid duplicates)
                const epsilon = 0.001;
                for (let i = 1; i < customColorScale.length; i++) {{
                    if (Math.abs(customColorScale[i][0] - customColorScale[i-1][0]) < epsilon) {{
                        customColorScale[i][0] = customColorScale[i-1][0] + epsilon;
                    }}
                }}
                
                console.log('Applied 3-point scale:', {{
                    inputs: {{
                        min: {{value: valueMin, color: colorMin}},
                        mid: {{value: valueMid, color: colorMid}},
                        max: {{value: valueMax, color: colorMax}}
                    }},
                    customRange: {{min: valueMin, max: valueMax}},
                    midPosition: clampedPosMid,
                    colorScale: customColorScale
                }});
            }} else {{
                // 2-point scale with optional custom value mapping
                const colorMin = document.getElementById('colorMin').value;
                const colorMax = document.getElementById('colorMax').value;
                
                const valueMin2Input = document.getElementById('valueMin2').value;
                const valueMax2Input = document.getElementById('valueMax2').value;
                
                // Check if custom values are specified
                if (valueMin2Input !== '' && valueMax2Input !== '') {{
                    // Use custom values for cross-heatmap comparison
                    const valueMin = parseFloat(valueMin2Input);
                    const valueMax = parseFloat(valueMax2Input);
                    
                    if (valueMax === valueMin) {{
                        alert('Custom min and max values cannot be the same.');
                        return;
                    }}
                    
                    // Colorscale spans from 0 to 1 (representing valueMin to valueMax)
                    // Plotly will map data values to this scale automatically
                    customColorScale = [
                        [0, rgbToPlotlyFormat(colorMin)],
                        [1, rgbToPlotlyFormat(colorMax)]
                    ];
                    
                    // Override the data normalization by setting colorscale range
                    window.customColorRange = {{min: valueMin, max: valueMax}};
                    
                    console.log('Applied 2-point scale with custom values:', {{
                        customRange: {{min: valueMin, max: valueMax}},
                        colorScale: customColorScale
                    }});
                }} else {{
                    // Auto mode: use full data range
                    customColorScale = [
                        [0, rgbToPlotlyFormat(colorMin)],
                        [1, rgbToPlotlyFormat(colorMax)]
                    ];
                    
                    // Clear custom range
                    window.customColorRange = null;
                    
                    console.log('Applied 2-point scale (auto):', customColorScale);
                }}
            }}
            
            // Switch to Custom colorscale and update
            currentColorscale = 'Custom';
            
            // Update dropdown without triggering the onchange handler
            const selectElement = document.getElementById('colorscaleSelect');
            const oldOnchange = selectElement.onchange;
            selectElement.onchange = null;
            selectElement.value = 'Custom';
            selectElement.onchange = oldOnchange;
            
            console.log('About to create heatmap with custom scale:', {{
                currentColorscale: currentColorscale,
                customColorScale: customColorScale,
                dropdownValue: selectElement.value
            }});
            
            createHeatmap();
        }}
        
        function resetToAutoColors() {{
            // Clear custom color range
            window.customColorRange = null;
            
            // Update value input boxes to show current data range
            const range = window.currentDataRange;
            if (range) {{
                document.getElementById('valueMin2').value = formatValueDisplay(range.min);
                document.getElementById('valueMax2').value = formatValueDisplay(range.max);
            }}
            
            // Recreate heatmap with auto colors
            createHeatmap();
            
            console.log('Reset to auto color mode');
        }}
        
        function updateFontSize(size) {{
            currentFontSize = parseInt(size);
            document.getElementById('fontSizeValue').textContent = size + 'px';
            createHeatmap();
        }}
        
        function toggleLabels() {{
            showLabels = !showLabels;
            const btn = document.getElementById('toggleLabelsBtn');
            btn.textContent = showLabels ? 'üè∑Ô∏è Hide Text' : 'üè∑Ô∏è Show Text';
            
            // Update the layout to hide/show ALL text elements including colorbar
            const gd = document.getElementById('heatmap');
            
            // Update colorbar text (trace-level property)
            const traceUpdate = {{
                'colorbar.title.text': showLabels ? (metricType.charAt(0).toUpperCase() + metricType.slice(1)) : '',
                'colorbar.showticklabels': showLabels
            }};
            
            // Update layout elements
            const layoutUpdate = {{
                'title.text': showLabels ? originalTitle : '',
                'xaxis.showticklabels': showLabels,
                'yaxis.showticklabels': showLabels,
                'xaxis.title.text': showLabels ? (isLarge ? '<b>Target</b> (' + gd.data[0].x.length + ' neurons)' : '<b>Target</b>') : '',
                'yaxis.title.text': showLabels ? (isLarge ? '<b>Source</b> (' + gd.data[0].y.length + ' neurons)' : '<b>Source</b>') : '',
                'xaxis.ticks': showLabels ? 'outside' : '',
                'yaxis.ticks': showLabels ? 'outside' : '',
                // Prevent autosize from expanding the plot
                'autosize': false,
                // Keep margins fixed to prevent rescaling
                'margin.l': 120,
                'margin.r': 40,
                'margin.t': 100,
                'margin.b': 120,
                // Preserve dimensions explicitly
                'width': currentWidth,
                'height': currentHeight
            }};
            
            // Update both trace and layout
            Plotly.restyle(gd, traceUpdate, 0);
            Plotly.relayout(gd, layoutUpdate);
        }}
        
        function toggleCellValues() {{
            showCellValues = !showCellValues;
            const btn = document.getElementById('toggleCellValuesBtn');
            btn.textContent = showCellValues ? 'üî¢ Hide Values' : 'üî¢ Show Values';
            
            console.log('toggleCellValues called, showCellValues is now:', showCellValues);
            
            // Recreate heatmap to add/remove cell value annotations
            createHeatmap();
        }}
        
        function updateCellValueSize(size) {{
            cellValueFontSize = parseInt(size);
            document.getElementById('cellValueSizeValue').textContent = cellValueFontSize + 'px';
            
            // Only recreate if cell values are currently shown
            if (showCellValues) {{
                createHeatmap();
            }}
        }}
        
        function updateContrastThreshold(value) {{
            contrastThreshold = parseFloat(value);
            document.getElementById('contrastThresholdValue').textContent = contrastThreshold.toFixed(4);
            console.log('Contrast threshold updated to:', contrastThreshold);
            
            // Recreate heatmap if cell values are currently shown
            if (showCellValues) {{
                createHeatmap();
            }}
        }}
        
        function reverseContrastColors() {{
            reverseContrast = !reverseContrast;
            console.log('Contrast colors reversed:', reverseContrast);
            
            // Recreate heatmap if cell values are currently shown
            if (showCellValues) {{
                createHeatmap();
            }}
        }}
        
        function updateIgnoredValues() {{
            const input = document.getElementById('ignoreValuesInput');
            const expressions = input.value.split(',').map(v => v.trim()).filter(v => v !== '');
            
            // Clear and repopulate the ignored values array
            // Store both exact values and comparison expressions
            ignoredValues.clear();
            ignoredValues.expressions = [];  // Array to store comparison expressions
            
            expressions.forEach(expr => {{
                // Check if it's a comparison expression (>, <, >=, <=)
                const compMatch = expr.match(/^([><]=?|==|!=)\\s*(-?\\d+\\.?\\d*)$/);
                if (compMatch) {{
                    // It's a comparison expression
                    const operator = compMatch[1];
                    const threshold = parseFloat(compMatch[2]);
                    ignoredValues.expressions.push({{ operator, threshold }});
                }} else {{
                    // Try to parse as exact number
                    const num = parseFloat(expr);
                    if (!isNaN(num)) {{
                        ignoredValues.add(num);
                    }}
                }}
            }});
            
            console.log('Ignored exact values:', Array.from(ignoredValues));
            console.log('Ignored expressions:', ignoredValues.expressions);
            
            // Recreate heatmap if cell values are shown
            if (showCellValues) {{
                createHeatmap();
            }}
        }}
        
        function shouldIgnoreValue(value) {{
            // Check if value matches any exact value
            if (ignoredValues.has(value)) {{
                return true;
            }}
            
            // Check if value matches any comparison expression
            if (ignoredValues.expressions && ignoredValues.expressions.length > 0) {{
                for (const expr of ignoredValues.expressions) {{
                    let matches = false;
                    switch (expr.operator) {{
                        case '>':
                            matches = value > expr.threshold;
                            break;
                        case '<':
                            matches = value < expr.threshold;
                            break;
                        case '>=':
                            matches = value >= expr.threshold;
                            break;
                        case '<=':
                            matches = value <= expr.threshold;
                            break;
                        case '==':
                            matches = value === expr.threshold;
                            break;
                        case '!=':
                            matches = value !== expr.threshold;
                            break;
                    }}
                    if (matches) {{
                        return true;
                    }}
                }}
            }}
            
            return false;
        }}
        
        // ===== DATA FILTER FUNCTIONS =====
        // Filter entire rows/columns based on their maximum values
        
        function parseFilterExpressions(inputString) {{
            const expressions = inputString.split(',').map(v => v.trim()).filter(v => v !== '');
            const parsedExpressions = [];
            
            expressions.forEach(expr => {{
                // Check if it's a comparison expression (>, <, >=, <=, ==, !=)
                const compMatch = expr.match(/^([><]=?|==|!=)\\s*(-?\\d+\\.?\\d*)$/);
                if (compMatch) {{
                    const operator = compMatch[1];
                    const threshold = parseFloat(compMatch[2]);
                    parsedExpressions.push({{ operator, threshold }});
                }} else {{
                    // Try to parse as exact number (will hide if max == this value)
                    const num = parseFloat(expr);
                    if (!isNaN(num)) {{
                        parsedExpressions.push({{ operator: '==', threshold: num }});
                    }}
                }}
            }});
            
            return parsedExpressions;
        }}
        
        function shouldHideRowOrColumn(maxValue, expressions) {{
            if (expressions.length === 0) return false;
            
            for (const expr of expressions) {{
                let matches = false;
                switch (expr.operator) {{
                    case '>':
                        matches = maxValue > expr.threshold;
                        break;
                    case '<':
                        matches = maxValue < expr.threshold;
                        break;
                    case '>=':
                        matches = maxValue >= expr.threshold;
                        break;
                    case '<=':
                        matches = maxValue <= expr.threshold;
                        break;
                    case '==':
                        matches = maxValue === expr.threshold;
                        break;
                    case '!=':
                        matches = maxValue !== expr.threshold;
                        break;
                }}
                if (matches) {{
                    return true;  // Hide if any expression matches
                }}
            }}
            
            return false;
        }}
        
        function applyDataFilter() {{
            const input = document.getElementById('dataFilterInput');
            const statusDiv = document.getElementById('filterStatus');
            const filterValue = input.value.trim();
            
            // Disable data filtering when clustering is active
            if (useClusteredOrder && clusteringAvailable) {{
                statusDiv.textContent = '‚ö†Ô∏è Data filter disabled during clustering';
                statusDiv.style.color = '#ff9800';
                input.disabled = true;
                dataFilterActive = false;
                dataFilterExpressions = [];
                filteredRowIndices = [];
                filteredColIndices = [];
                return;
            }} else {{
                input.disabled = false;
            }}
            
            if (!filterValue) {{
                // No filter - show all rows/columns
                dataFilterActive = false;
                dataFilterExpressions = [];
                filteredRowIndices = [];
                filteredColIndices = [];
                statusDiv.textContent = '';
                createHeatmap();
                return;
            }}
            
            // Parse filter expressions
            dataFilterExpressions = parseFilterExpressions(filterValue);
            
            if (dataFilterExpressions.length === 0) {{
                statusDiv.textContent = '‚ö†Ô∏è Invalid filter format';
                statusDiv.style.color = '#d32f2f';
                return;
            }}
            
            // Get current data based on scale
            let currentData = dataLinear;
            if (currentScale === 'log2' && (useLazyTransforms ? cachedDataLog2 : dataLog2)) {{
                currentData = useLazyTransforms ? cachedDataLog2 : dataLog2;
            }} else if (currentScale === 'log10' && (useLazyTransforms ? cachedDataLog10 : dataLog10)) {{
                currentData = useLazyTransforms ? cachedDataLog10 : dataLog10;
            }} else if (currentScale === 'sqrt' && (useLazyTransforms ? cachedDataSqrt : dataSqrt)) {{
                currentData = useLazyTransforms ? cachedDataSqrt : dataSqrt;
            }}
            
            // Use original unscaled data for filtering
            const filterData = metricsData[currentMetric];
            
            const nRows = filterData.length;
            const nCols = filterData[0].length;
            
            // Calculate max value for each row and column
            const rowMaxValues = new Array(nRows).fill(-Infinity);
            const colMaxValues = new Array(nCols).fill(-Infinity);
            
            for (let i = 0; i < nRows; i++) {{
                for (let j = 0; j < nCols; j++) {{
                    const value = filterData[i][j];
                    if (value > rowMaxValues[i]) rowMaxValues[i] = value;
                    if (value > colMaxValues[j]) colMaxValues[j] = value;
                }}
            }}
            
            // Determine which rows and columns to keep
            filteredRowIndices = [];
            filteredColIndices = [];
            
            for (let i = 0; i < nRows; i++) {{
                if (!shouldHideRowOrColumn(rowMaxValues[i], dataFilterExpressions)) {{
                    filteredRowIndices.push(i);
                }}
            }}
            
            for (let j = 0; j < nCols; j++) {{
                if (!shouldHideRowOrColumn(colMaxValues[j], dataFilterExpressions)) {{
                    filteredColIndices.push(j);
                }}
            }}
            
            dataFilterActive = true;
            
            const hiddenRows = nRows - filteredRowIndices.length;
            const hiddenCols = nCols - filteredColIndices.length;
            
            if (filteredRowIndices.length === 0 || filteredColIndices.length === 0) {{
                statusDiv.textContent = '‚ö†Ô∏è Filter hides all data!';
                statusDiv.style.color = '#d32f2f';
                dataFilterActive = false;
                return;
            }}
            
            statusDiv.textContent = `‚úì Showing ${{filteredRowIndices.length}}/${{nRows}} rows, ${{filteredColIndices.length}}/${{nCols}} cols`;
            statusDiv.style.color = '#2e7d32';
            
            console.log(`Data filter applied: hiding ${{hiddenRows}} rows and ${{hiddenCols}} cols`);
            
            createHeatmap();
        }}
        
        function resetDataFilter() {{
            document.getElementById('dataFilterInput').value = '';
            document.getElementById('filterStatus').textContent = '';
            dataFilterActive = false;
            dataFilterExpressions = [];
            filteredRowIndices = [];
            filteredColIndices = [];
            createHeatmap();
        }}
        
        // ===== END DATA FILTER FUNCTIONS =====
        
        function getPlotlyColorscaleArray(scaleName) {{
            // Return colorscale array for Plotly heatmap
            // Plotly v1.58.5 doesn't recognize all colorscale names, so we define them as arrays
            const colorscales = {{
                'Greens': [
                    [0.0, 'rgb(247,252,245)'],
                    [0.125, 'rgb(229,245,224)'],
                    [0.25, 'rgb(199,233,192)'],
                    [0.375, 'rgb(161,217,155)'],
                    [0.5, 'rgb(116,196,118)'],
                    [0.625, 'rgb(65,171,93)'],
                    [0.75, 'rgb(35,139,69)'],
                    [0.875, 'rgb(0,109,44)'],
                    [1.0, 'rgb(0,68,27)']
                ],
                'Blues': [
                    [0.0, 'rgb(247,251,255)'],
                    [0.125, 'rgb(222,235,247)'],
                    [0.25, 'rgb(198,219,239)'],
                    [0.375, 'rgb(158,202,225)'],
                    [0.5, 'rgb(107,174,214)'],
                    [0.625, 'rgb(66,146,198)'],
                    [0.75, 'rgb(33,113,181)'],
                    [0.875, 'rgb(8,81,156)'],
                    [1.0, 'rgb(8,48,107)']
                ],
                'Reds': [
                    [0.0, 'rgb(255,245,240)'],
                    [0.125, 'rgb(254,224,210)'],
                    [0.25, 'rgb(252,187,161)'],
                    [0.375, 'rgb(252,146,114)'],
                    [0.5, 'rgb(251,106,74)'],
                    [0.625, 'rgb(239,59,44)'],
                    [0.75, 'rgb(203,24,29)'],
                    [0.875, 'rgb(165,15,21)'],
                    [1.0, 'rgb(103,0,13)']
                ],
                'Purples': [
                    [0.0, 'rgb(252,251,253)'],
                    [0.125, 'rgb(239,237,245)'],
                    [0.25, 'rgb(218,218,235)'],
                    [0.375, 'rgb(188,189,220)'],
                    [0.5, 'rgb(158,154,200)'],
                    [0.625, 'rgb(128,125,186)'],
                    [0.75, 'rgb(106,81,163)'],
                    [0.875, 'rgb(84,39,143)'],
                    [1.0, 'rgb(63,0,125)']
                ],
                'Oranges': [
                    [0.0, 'rgb(255,245,235)'],
                    [0.125, 'rgb(254,230,206)'],
                    [0.25, 'rgb(253,208,162)'],
                    [0.375, 'rgb(253,174,107)'],
                    [0.5, 'rgb(253,141,60)'],
                    [0.625, 'rgb(241,105,19)'],
                    [0.75, 'rgb(217,72,1)'],
                    [0.875, 'rgb(166,54,3)'],
                    [1.0, 'rgb(127,39,4)']
                ],
                'Viridis': [
                    [0, 'rgb(68,1,84)'],
                    [0.25, 'rgb(59,82,139)'],
                    [0.5, 'rgb(33,145,140)'],
                    [0.75, 'rgb(94,201,98)'],
                    [1, 'rgb(253,231,37)']
                ],
                'Plasma': [
                    [0, 'rgb(13,8,135)'],
                    [0.25, 'rgb(126,3,168)'],
                    [0.5, 'rgb(204,71,120)'],
                    [0.75, 'rgb(248,149,64)'],
                    [1, 'rgb(240,249,33)']
                ],
                'Inferno': [
                    [0, 'rgb(0,0,4)'],
                    [0.25, 'rgb(87,16,110)'],
                    [0.5, 'rgb(188,55,84)'],
                    [0.75, 'rgb(249,142,9)'],
                    [1, 'rgb(252,255,164)']
                ],
                'Magma': [
                    [0, 'rgb(0,0,4)'],
                    [0.25, 'rgb(81,18,124)'],
                    [0.5, 'rgb(182,54,121)'],
                    [0.75, 'rgb(251,136,97)'],
                    [1, 'rgb(252,253,191)']
                ],
                'Cividis': [
                    [0, 'rgb(0,32,76)'],
                    [0.25, 'rgb(0,79,110)'],
                    [0.5, 'rgb(53,133,136)'],
                    [0.75, 'rgb(149,189,161)'],
                    [1, 'rgb(253,231,37)']
                ],
                'Hot': [
                    [0, 'rgb(0,0,0)'],
                    [0.33, 'rgb(255,0,0)'],
                    [0.66, 'rgb(255,255,0)'],
                    [1, 'rgb(255,255,255)']
                ],
                'Jet': [
                    [0, 'rgb(0,0,143)'],
                    [0.25, 'rgb(0,159,255)'],
                    [0.5, 'rgb(0,255,0)'],
                    [0.75, 'rgb(255,159,0)'],
                    [1, 'rgb(143,0,0)']
                ],
                'RdBu': [
                    [0, 'rgb(5,10,172)'],
                    [0.35, 'rgb(106,137,247)'],
                    [0.5, 'rgb(190,190,190)'],
                    [0.65, 'rgb(220,170,132)'],
                    [1, 'rgb(178,10,28)']
                ],
                'RdYlGn': [
                    [0, 'rgb(165,0,38)'],
                    [0.25, 'rgb(253,174,97)'],
                    [0.5, 'rgb(255,255,191)'],
                    [0.75, 'rgb(166,217,106)'],
                    [1, 'rgb(0,104,55)']
                ]
            }};
            
            // Return the colorscale array, or fallback to the name string
            return colorscales[scaleName] || scaleName;
        }}
        
        function getColorFromPlotlyScale(scaleName, normalized) {{
            // Map of Plotly colorscales to their RGB interpolations
            // These are approximations of Plotly's built-in scales
            const colorscales = {{
                'Greens': [
                    [0.0, 'rgb(247,252,245)'],
                    [0.125, 'rgb(229,245,224)'],
                    [0.25, 'rgb(199,233,192)'],
                    [0.375, 'rgb(161,217,155)'],
                    [0.5, 'rgb(116,196,118)'],
                    [0.625, 'rgb(65,171,93)'],
                    [0.75, 'rgb(35,139,69)'],
                    [0.875, 'rgb(0,109,44)'],
                    [1.0, 'rgb(0,68,27)']
                ],
                'Blues': [
                    [0.0, 'rgb(247,251,255)'],
                    [0.125, 'rgb(222,235,247)'],
                    [0.25, 'rgb(198,219,239)'],
                    [0.375, 'rgb(158,202,225)'],
                    [0.5, 'rgb(107,174,214)'],
                    [0.625, 'rgb(66,146,198)'],
                    [0.75, 'rgb(33,113,181)'],
                    [0.875, 'rgb(8,81,156)'],
                    [1.0, 'rgb(8,48,107)']
                ],
                'Reds': [
                    [0.0, 'rgb(255,245,240)'],
                    [0.125, 'rgb(254,224,210)'],
                    [0.25, 'rgb(252,187,161)'],
                    [0.375, 'rgb(252,146,114)'],
                    [0.5, 'rgb(251,106,74)'],
                    [0.625, 'rgb(239,59,44)'],
                    [0.75, 'rgb(203,24,29)'],
                    [0.875, 'rgb(165,15,21)'],
                    [1.0, 'rgb(103,0,13)']
                ],
                'Purples': [
                    [0.0, 'rgb(252,251,253)'],
                    [0.125, 'rgb(239,237,245)'],
                    [0.25, 'rgb(218,218,235)'],
                    [0.375, 'rgb(188,189,220)'],
                    [0.5, 'rgb(158,154,200)'],
                    [0.625, 'rgb(128,125,186)'],
                    [0.75, 'rgb(106,81,163)'],
                    [0.875, 'rgb(84,39,143)'],
                    [1.0, 'rgb(63,0,125)']
                ],
                'Oranges': [
                    [0.0, 'rgb(255,245,235)'],
                    [0.125, 'rgb(254,230,206)'],
                    [0.25, 'rgb(253,208,162)'],
                    [0.375, 'rgb(253,174,107)'],
                    [0.5, 'rgb(253,141,60)'],
                    [0.625, 'rgb(241,105,19)'],
                    [0.75, 'rgb(217,72,1)'],
                    [0.875, 'rgb(166,54,3)'],
                    [1.0, 'rgb(127,39,4)']
                ],
                'Viridis': [
                    [0, 'rgb(68,1,84)'],
                    [0.25, 'rgb(59,82,139)'],
                    [0.5, 'rgb(33,145,140)'],
                    [0.75, 'rgb(94,201,98)'],
                    [1, 'rgb(253,231,37)']
                ],
                'Plasma': [
                    [0, 'rgb(13,8,135)'],
                    [0.25, 'rgb(126,3,168)'],
                    [0.5, 'rgb(204,71,120)'],
                    [0.75, 'rgb(248,149,64)'],
                    [1, 'rgb(240,249,33)']
                ],
                'Inferno': [
                    [0, 'rgb(0,0,4)'],
                    [0.25, 'rgb(87,16,110)'],
                    [0.5, 'rgb(188,55,84)'],
                    [0.75, 'rgb(249,142,9)'],
                    [1, 'rgb(252,255,164)']
                ],
                'Magma': [
                    [0, 'rgb(0,0,4)'],
                    [0.25, 'rgb(81,18,124)'],
                    [0.5, 'rgb(182,54,121)'],
                    [0.75, 'rgb(251,136,97)'],
                    [1, 'rgb(252,253,191)']
                ],
                'Cividis': [
                    [0, 'rgb(0,32,76)'],
                    [0.25, 'rgb(0,79,110)'],
                    [0.5, 'rgb(53,133,136)'],
                    [0.75, 'rgb(149,189,161)'],
                    [1, 'rgb(253,231,37)']
                ],
                'Hot': [
                    [0, 'rgb(0,0,0)'],
                    [0.33, 'rgb(255,0,0)'],
                    [0.66, 'rgb(255,255,0)'],
                    [1, 'rgb(255,255,255)']
                ],
                'Jet': [
                    [0, 'rgb(0,0,143)'],
                    [0.25, 'rgb(0,159,255)'],
                    [0.5, 'rgb(0,255,0)'],
                    [0.75, 'rgb(255,159,0)'],
                    [1, 'rgb(143,0,0)']
                ],
                'RdBu': [
                    [0, 'rgb(5,10,172)'],
                    [0.35, 'rgb(106,137,247)'],
                    [0.5, 'rgb(190,190,190)'],
                    [0.65, 'rgb(220,170,132)'],
                    [1, 'rgb(178,10,28)']
                ],
                'RdYlGn': [
                    [0, 'rgb(165,0,38)'],
                    [0.25, 'rgb(253,174,97)'],
                    [0.5, 'rgb(255,255,191)'],
                    [0.75, 'rgb(166,217,106)'],
                    [1, 'rgb(0,104,55)']
                ]
            }};
            
            // Get the colorscale array
            const scale = colorscales[scaleName];
            if (!scale) {{
                // Fallback to grayscale
                const gray = Math.round(normalized * 255);
                return `rgb(${{gray}},${{gray}},${{gray}})`;
            }}
            
            // Find the two color stops to interpolate between
            let lower = scale[0];
            let upper = scale[scale.length - 1];
            
            for (let i = 0; i < scale.length - 1; i++) {{
                if (normalized >= scale[i][0] && normalized <= scale[i + 1][0]) {{
                    lower = scale[i];
                    upper = scale[i + 1];
                    break;
                }}
            }}
            
            // Interpolate between the two colors
            const t = (normalized - lower[0]) / (upper[0] - lower[0]);
            const lowerRgb = hexToRgb(lower[1]);
            const upperRgb = hexToRgb(upper[1]);
            
            const r = Math.round(lowerRgb[0] + t * (upperRgb[0] - lowerRgb[0]));
            const g = Math.round(lowerRgb[1] + t * (upperRgb[1] - lowerRgb[1]));
            const b = Math.round(lowerRgb[2] + t * (upperRgb[2] - lowerRgb[2]));
            
            return `rgb(${{r}},${{g}},${{b}})`;
        }}
        
        function interpolateColorscale(colorscale, normalized) {{
            // Interpolate color from a custom colorscale array
            // colorscale format: [[0, 'color1'], [0.5, 'color2'], [1, 'color3'], ...]
            
            if (!Array.isArray(colorscale) || colorscale.length === 0) {{
                return 'rgb(128, 128, 128)';  // fallback gray
            }}
            
            // Handle edge cases
            if (normalized <= 0 || normalized <= colorscale[0][0]) {{
                return Array.isArray(colorscale[0]) && colorscale[0].length > 1 ? colorscale[0][1] : 'rgb(128, 128, 128)';
            }}
            if (normalized >= 1 || normalized >= colorscale[colorscale.length - 1][0]) {{
                const last = colorscale[colorscale.length - 1];
                return Array.isArray(last) && last.length > 1 ? last[1] : 'rgb(128, 128, 128)';
            }}
            
            // Find the two color stops to interpolate between
            let lower = colorscale[0];
            let upper = colorscale[colorscale.length - 1];
            
            for (let i = 0; i < colorscale.length - 1; i++) {{
                if (normalized >= colorscale[i][0] && normalized <= colorscale[i + 1][0]) {{
                    lower = colorscale[i];
                    upper = colorscale[i + 1];
                    break;
                }}
            }}
            
            // Interpolate between the two colors
            const t = (normalized - lower[0]) / (upper[0] - lower[0]);
            const lowerRgb = hexToRgb(lower[1]);
            const upperRgb = hexToRgb(upper[1]);
            
            const r = Math.round(lowerRgb[0] + t * (upperRgb[0] - lowerRgb[0]));
            const g = Math.round(lowerRgb[1] + t * (upperRgb[1] - lowerRgb[1]));
            const b = Math.round(lowerRgb[2] + t * (upperRgb[2] - lowerRgb[2]));
            
            return `rgb(${{r}},${{g}},${{b}})`;
        }}
        
        function getContrastColor(rgb) {{
            // Calculate luminance from RGB color
            // If luminance is high (light background), use dark text; otherwise use light text
            const r = rgb[0];
            const g = rgb[1];
            const b = rgb[2];
            
            // Calculate relative luminance using the formula for sRGB
            const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            
            // Convert normalized threshold (0-1) to 0-255 range for comparison
            const threshold = contrastThreshold * 255;
            
            // Compare against the adjustable threshold
            // Normal: high luminance (light bg) ‚Üí black text, low luminance (dark bg) ‚Üí white text
            // Reverse: swap the logic
            if (reverseContrast) {{
                return luminance > threshold ? 'white' : 'black';
            }} else {{
                return luminance > threshold ? 'black' : 'white';
            }}
        }}
        
        function getColorForValue(value, zmin, zmax, colorscale) {{
            // Normalize value to 0-1 range
            const normalized = (value - zmin) / (zmax - zmin);
            
            // Get RGB color from the colorscale at the normalized position
            // This is a simplified version - Plotly has complex colorscale interpolation
            // For now, we'll sample the colorscale array
            if (Array.isArray(colorscale) && colorscale.length > 0) {{
                const idx = Math.floor(normalized * (colorscale.length - 1));
                const colorStop = colorscale[Math.max(0, Math.min(idx, colorscale.length - 1))];
                if (Array.isArray(colorStop) && colorStop.length > 1) {{
                    return colorStop[1];
                }}
            }}
            
            // Fallback: return a color based on normalized value
            if (normalized < 0.5) {{
                return `rgb(${{Math.round(normalized * 510)}}, ${{Math.round(normalized * 510)}}, 255)`;
            }} else {{
                return `rgb(255, ${{Math.round((1 - normalized) * 510)}}, ${{Math.round((1 - normalized) * 510)}})`;
            }}
        }}
        
        function hexToRgb(hex) {{
            // Convert hex color to RGB array
            if (hex.startsWith('#')) {{
                const result = /^#?([a-f\\d]{{2}})([a-f\\d]{{2}})([a-f\\d]{{2}})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [128, 128, 128];
            }} else if (hex.startsWith('rgb')) {{
                const match = hex.match(/\\d+/g);
                return match ? match.slice(0, 3).map(Number) : [128, 128, 128];
            }}
            return [128, 128, 128];
        }}
        
        function updatePlotSize() {{
            const gd = document.getElementById('heatmap');
            currentWidth = parseInt(document.getElementById('widthSlider').value);
            
            // If square cells are locked, auto-adjust height
            if (squareCellsLocked && gd.data && gd.data[0]) {{
                const numRows = gd.data[0].y.length;
                const numCols = gd.data[0].x.length;
                const margins = gd.layout.margin || {{l: 120, r: 40, b: 120, t: 100}};
                const marginHorizontal = margins.l + margins.r;
                const marginVertical = margins.t + margins.b;
                const plotAreaWidth = currentWidth - marginHorizontal;
                const plotAreaHeight = plotAreaWidth * numRows / numCols;
                currentHeight = Math.round(plotAreaHeight + marginVertical);
            }} else {{
                currentHeight = parseInt(document.getElementById('heightSlider').value);
            }}
            
            // Sync input boxes with sliders
            document.getElementById('widthInput').value = currentWidth;
            document.getElementById('heightInput').value = currentHeight;
            document.getElementById('widthValue').textContent = currentWidth + 'px';
            document.getElementById('heightValue').textContent = currentHeight + 'px';
            document.getElementById('heightSlider').value = Math.min(2400, Math.max(400, currentHeight));
            
            // Update the layout without recreating the entire plot
            Plotly.relayout(gd, {{
                width: currentWidth,
                height: currentHeight
            }});
        }}
        
        function updatePlotSizeFromInput() {{
            const gd = document.getElementById('heatmap');
            const widthInput = parseInt(document.getElementById('widthInput').value);
            
            // Update width
            currentWidth = widthInput;
            
            // If square cells are locked, auto-adjust height
            if (squareCellsLocked && gd.data && gd.data[0]) {{
                const numRows = gd.data[0].y.length;
                const numCols = gd.data[0].x.length;
                const margins = gd.layout.margin || {{l: 120, r: 40, b: 120, t: 100}};
                const marginHorizontal = margins.l + margins.r;
                const marginVertical = margins.t + margins.b;
                const plotAreaWidth = currentWidth - marginHorizontal;
                const plotAreaHeight = plotAreaWidth * numRows / numCols;
                currentHeight = Math.round(plotAreaHeight + marginVertical);
            }} else {{
                currentHeight = parseInt(document.getElementById('heightInput').value);
            }}
            
            // Update sliders (clamped to their range) and displays
            document.getElementById('widthSlider').value = Math.min(2400, Math.max(400, currentWidth));
            document.getElementById('heightSlider').value = Math.min(2400, Math.max(400, currentHeight));
            document.getElementById('widthInput').value = currentWidth;
            document.getElementById('heightInput').value = currentHeight;
            document.getElementById('widthValue').textContent = currentWidth + 'px';
            document.getElementById('heightValue').textContent = currentHeight + 'px';
            
            // Update the layout
            Plotly.relayout(gd, {{
                width: currentWidth,
                height: currentHeight
            }});
        }}
        
        function makeSquareCells() {{
            const gd = document.getElementById('heatmap');
            if (!gd.data || !gd.data[0]) return;
            
            const btn = document.getElementById('squareCellsBtn');
            squareCellsLocked = !squareCellsLocked;
            
            if (squareCellsLocked) {{
                // Lock to square cells
                const numRows = gd.data[0].y.length;
                const numCols = gd.data[0].x.length;
                
                // Get margins (l=120, r=40, b=120, t=100)
                const margins = gd.layout.margin || {{l: 120, r: 40, b: 120, t: 100}};
                const marginHorizontal = margins.l + margins.r;  // 160px
                const marginVertical = margins.t + margins.b;    // 220px
                
                // Calculate height for square cells based on current width
                const plotAreaWidth = currentWidth - marginHorizontal;
                const plotAreaHeight = plotAreaWidth * numRows / numCols;
                const targetHeight = Math.round(plotAreaHeight + marginVertical);
                
                // Update height
                currentHeight = targetHeight;
                document.getElementById('heightSlider').value = Math.min(2400, Math.max(400, targetHeight));
                document.getElementById('heightInput').value = targetHeight;
                document.getElementById('heightValue').textContent = targetHeight + 'px';
                
                // Lock aspect ratio
                Plotly.relayout(gd, {{
                    width: currentWidth,
                    height: targetHeight,
                    'xaxis.scaleanchor': 'y',
                    'xaxis.scaleratio': 1,
                    'yaxis.constrain': 'domain'
                }});
                
                btn.textContent = 'üîì Unlock Cells';
                btn.style.backgroundColor = '#28a745';
                
                console.log('Square cells LOCKED:', {{
                    numCols: numCols,
                    numRows: numRows,
                    width: currentWidth,
                    height: targetHeight,
                    cellAspectRatio: 1.0
                }});
            }} else {{
                // Unlock - remove aspect ratio constraint
                Plotly.relayout(gd, {{
                    'xaxis.scaleanchor': null,
                    'xaxis.scaleratio': null,
                    'yaxis.constrain': null
                }});
                
                btn.textContent = '‚¨ú Square Cells';
                btn.style.backgroundColor = '';
                
                console.log('Square cells UNLOCKED - free adjustment enabled');
            }}
        }}
        
        function transposeMatrix() {{
            isTransposed = !isTransposed;
            
            // Update button text
            const btn = document.getElementById('transposeBtn');
            btn.textContent = isTransposed ? 'üîÑ Restore Original' : 'üîÑ Swap Rows ‚Üî Columns';
            btn.style.backgroundColor = isTransposed ? '#17a2b8' : '';
            
            console.log('Matrix transposed:', isTransposed);
            
            // Recreate heatmap with transposed data
            createHeatmap();
        }}
        
        // Row/Column reordering functions
        function resetOrder() {{
            // Reset to original order (before any reordering operations)
            currentXLabels = xLabels.slice();
            currentYLabels = yLabels.slice();
            console.log('Reset to original order');
            closeOrderPanel();  // Close panel if open
            createHeatmap();
        }}
        
        // Drag and drop ordering
        let currentOrderType = null;  // 'rows' or 'cols'
        let draggedItem = null;
        let tempOrder = [];
        
        function toggleOrderPanel(type) {{
            currentOrderType = type;
            const panel = document.getElementById('orderPanel');
            const backdrop = document.getElementById('orderPanelBackdrop');
            const label = document.getElementById('orderPanelLabel');
            const listContainer = document.getElementById('orderList');
            
            // Get current labels based on type and transpose state
            // We need to show the ACTUAL order displayed on heatmap, including clustering
            let labels;
            if (type === 'rows') {{
                // Visual rows = Y-axis
                labels = isTransposed ? currentXLabels.slice() : currentYLabels.slice();
                
                // Apply clustering if enabled
                if (useClusteredOrder && clusteringAvailable) {{
                    const effectiveRowOrder = isTransposed ? colOrderClustered : rowOrderClustered;
                    labels = reorderLabels(labels, effectiveRowOrder);
                }}
                label.textContent = 'Reorder Rows (Y-axis)';
            }} else {{
                // Visual columns = X-axis
                labels = isTransposed ? currentYLabels.slice() : currentXLabels.slice();
                
                // Apply clustering if enabled
                if (useClusteredOrder && clusteringAvailable) {{
                    const effectiveColOrder = isTransposed ? rowOrderClustered : colOrderClustered;
                    labels = reorderLabels(labels, effectiveColOrder);
                }}
                label.textContent = 'Reorder Columns (X-axis)';
            }}
            
            tempOrder = labels.slice();
            console.log('toggleOrderPanel:', type, 'isTransposed:', isTransposed, 'clustered:', useClusteredOrder, 'labels:', labels);
            
            // Create draggable list
            listContainer.innerHTML = '';
            labels.forEach((item, index) => {{
                const div = document.createElement('div');
                div.className = 'drag-item';
                div.draggable = true;
                div.dataset.label = item;
                div.innerHTML = '<span class="drag-handle">‚ò∞</span>' + item;
                
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
                div.addEventListener('dragenter', handleDragEnter);
                div.addEventListener('dragleave', handleDragLeave);
                
                listContainer.appendChild(div);
            }});
            
            // Show panel and backdrop
            panel.style.display = 'flex';
            backdrop.style.display = 'block';
        }}
        
        function closeOrderPanel() {{
            document.getElementById('orderPanel').style.display = 'none';
            document.getElementById('orderPanelBackdrop').style.display = 'none';
            currentOrderType = null;
            draggedItem = null;
            tempOrder = [];
        }}
        
        function handleDragStart(e) {{
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }}
        
        function handleDragOver(e) {{
            if (e.preventDefault) {{
                e.preventDefault();
            }}
            e.dataTransfer.dropEffect = 'move';
            return false;
        }}
        
        function handleDragEnter(e) {{
            if (this !== draggedItem) {{
                this.classList.add('drag-over');
            }}
        }}
        
        function handleDragLeave(e) {{
            this.classList.remove('drag-over');
        }}
        
        function handleDrop(e) {{
            if (e.stopPropagation) {{
                e.stopPropagation();
            }}
            
            if (draggedItem !== this) {{
                // Reorder in DOM - insert before the target
                const draggedLabel = draggedItem.dataset.label;
                const targetLabel = this.dataset.label;
                
                const listContainer = document.getElementById('orderList');
                
                // Always insert before the target element
                // This gives consistent behavior: dropping on X puts item before X
                this.parentNode.insertBefore(draggedItem, this);
                
                // Read the new order from DOM to ensure perfect sync
                const itemsAfter = Array.from(listContainer.children);
                tempOrder = itemsAfter.map(item => item.dataset.label);
                
                console.log('Dragged', draggedLabel, 'before', targetLabel, '| New order:', tempOrder);
                
                // Apply immediately to heatmap
                applyReorderImmediate();
            }}
            
            this.classList.remove('drag-over');
            return false;
        }}
        
        function handleDragEnd(e) {{
            this.classList.remove('dragging');
            
            // Remove drag-over class from all items
            const items = document.querySelectorAll('.drag-item');
            items.forEach(item => item.classList.remove('drag-over'));
        }}
        
        function applyReorderImmediate() {{
            if (!currentOrderType || tempOrder.length === 0) return;
            
            // When user manually reorders, disable clustering to respect their choice
            if (useClusteredOrder) {{
                useClusteredOrder = false;
                const orderBtn = document.getElementById('orderBtn');
                if (orderBtn) {{
                    orderBtn.textContent = 'üîÄ Clustered Order';
                }}
                console.log('Disabled clustering due to manual reordering');
            }}
            
            if (currentOrderType === 'rows') {{
                if (isTransposed) {{
                    currentXLabels = tempOrder.slice();
                }} else {{
                    currentYLabels = tempOrder.slice();
                }}
                console.log('Applied immediate reorder to rows:', tempOrder);
            }} else {{
                if (isTransposed) {{
                    currentYLabels = tempOrder.slice();
                }} else {{
                    currentXLabels = tempOrder.slice();
                }}
                console.log('Applied immediate reorder to columns:', tempOrder);
            }}
            
            createHeatmap();
        }}
        
        function applyDragOrder() {{
            // Just close the panel - reordering already applied immediately
            closeOrderPanel();
        }}
        
        function resetPlotSize() {{
            currentWidth = 800;
            currentHeight = 800;
            document.getElementById('widthSlider').value = 800;
            document.getElementById('heightSlider').value = 800;
            document.getElementById('widthInput').value = 800;
            document.getElementById('heightInput').value = 800;
            document.getElementById('widthValue').textContent = '800px';
            document.getElementById('heightValue').textContent = '800px';
            updatePlotSize();
        }}
        
        function updateExportScale(value) {{
            exportScale = parseFloat(value);
            document.getElementById('exportScaleValue').textContent = value + 'x';
        }}
        
        function exportSVG() {{
            const filename = 'heatmap_' + currentScale + '_' + new Date().getTime() + '.svg';
            
            // Get the plotly graph element
            const gd = document.getElementById('heatmap');
            
            // Use current layout dimensions with scale parameter
            // This preserves fonts and colors correctly
            Plotly.toImage(gd, {{
                format: 'svg',
                width: currentWidth,
                height: currentHeight,
                scale: exportScale
            }}).then(function(dataUrl) {{
                const link = document.createElement('a');
                link.download = filename;
                link.href = dataUrl;
                link.click();
                const actualWidth = currentWidth * exportScale;
                const actualHeight = currentHeight * exportScale;
                showStatus(`‚úÖ SVG exported: ${{actualWidth}}x${{actualHeight}}px`, 'success');
                console.log('SVG exported:', actualWidth, 'x', actualHeight);
            }}).catch(function(error) {{
                console.error('SVG export failed:', error);
                showStatus('‚ö†Ô∏è SVG export failed. See console.', 'error');
            }});
        }}
        
        function saveSettings() {{
            try {{
                const settings = {{
                    // Scale and colorscale
                    scale: currentScale,
                    colorscale: currentColorscale,
                    fontSize: currentFontSize,
                    useAutoRange: useAutoRange,
                    zminSlider: document.getElementById('zminSlider')?.value,
                    zmaxSlider: document.getElementById('zmaxSlider')?.value,
                    // Custom colorscale settings
                    customColorScale: customColorScale,
                    use3PointScale: use3PointScale,
                    colorMin: document.getElementById('colorMin')?.value,
                    colorMax: document.getElementById('colorMax')?.value,
                    colorMin3: document.getElementById('colorMin3')?.value,
                    colorMid3: document.getElementById('colorMid3')?.value,
                    colorMax3: document.getElementById('colorMax3')?.value,
                    valueMin3: document.getElementById('valueMin3')?.value,
                    valueMid3: document.getElementById('valueMid3')?.value,
                    valueMax3: document.getElementById('valueMax3')?.value,
                    // Layout
                    width: currentWidth,
                    height: currentHeight,
                    exportScale: exportScale,
                    showLabels: showLabels,
                    // Data state
                    currentMetric: currentMetric,
                    useClusteredOrder: useClusteredOrder,
                    clusteringMethod: currentClusteringMethod,
                    isTransposed: isTransposed,
                    // Cell values
                    showCellValues: showCellValues,
                    cellValueFontSize: cellValueFontSize,
                    ignoredValuesInput: document.getElementById('ignoreValuesInput')?.value,
                    contrastThreshold: contrastThreshold,
                    reverseContrast: reverseContrast,
                    // UI state
                    squareCellsLocked: squareCellsLocked,
                    // Row/column order after reordering
                    currentXLabels: currentXLabels,
                    currentYLabels: currentYLabels
                }};
                localStorage.setItem(storageKey, JSON.stringify(settings));
                console.log('Settings saved successfully:', settings);
                showStatus('‚úÖ Settings saved!', 'success');
            }} catch (error) {{
                console.error('Error saving settings:', error);
                showStatus('‚ö†Ô∏è Error saving settings', 'error');
            }}
        }}
        
        function loadSettings(showStatusMsg = true) {{
            const saved = localStorage.getItem(storageKey);
            if (saved) {{
                try {{
                    const settings = JSON.parse(saved);
                currentScale = settings.scale || 'linear';
                currentColorscale = settings.colorscale || '{default_colorscale}';
                currentFontSize = settings.fontSize || {fontsize};
                useAutoRange = settings.useAutoRange !== undefined ? settings.useAutoRange : true;
                customColorScale = settings.customColorScale || null;
                use3PointScale = settings.use3PointScale || false;
                
                // Update UI
                document.querySelectorAll('[id^="btn-"]').forEach(btn => btn.classList.remove('active'));
                document.getElementById('btn-' + currentScale).classList.add('active');
                document.getElementById('colorscaleSelect').value = currentColorscale;
                document.getElementById('fontSizeSlider').value = currentFontSize;
                document.getElementById('fontSizeValue').textContent = currentFontSize + 'px';
                
                // Restore custom colors
                if (settings.colorMin) document.getElementById('colorMin').value = settings.colorMin;
                if (settings.colorMax) document.getElementById('colorMax').value = settings.colorMax;
                if (settings.colorMin3) document.getElementById('colorMin3').value = settings.colorMin3;
                if (settings.colorMid3) document.getElementById('colorMid3').value = settings.colorMid3;
                if (settings.colorMax3) document.getElementById('colorMax3').value = settings.colorMax3;
                if (settings.valueMin3) document.getElementById('valueMin3').value = settings.valueMin3;
                if (settings.valueMid3) document.getElementById('valueMid3').value = settings.valueMid3;
                if (settings.valueMax3) document.getElementById('valueMax3').value = settings.valueMax3;
                document.getElementById('use3PointScale').checked = use3PointScale;
                toggle3PointScale();
                
                // Restore plot size (clamp to valid range)
                if (settings.width) {{
                    currentWidth = Math.min(3000, Math.max(400, settings.width));
                    document.getElementById('widthSlider').value = Math.min(2400, Math.max(400, currentWidth));
                    document.getElementById('widthInput').value = currentWidth;
                    document.getElementById('widthValue').textContent = currentWidth + 'px';
                }}
                if (settings.height) {{
                    currentHeight = Math.min(3000, Math.max(400, settings.height));
                    document.getElementById('heightSlider').value = Math.min(2400, Math.max(400, currentHeight));
                    document.getElementById('heightInput').value = currentHeight;
                    document.getElementById('heightValue').textContent = currentHeight + 'px';
                }}
                if (settings.exportScale) {{
                    exportScale = Math.min(5, Math.max(1, settings.exportScale || 2));
                    document.getElementById('exportScaleSlider').value = exportScale;
                    document.getElementById('exportScaleValue').textContent = exportScale + 'x';
                }}
                
                // Restore label visibility
                if (settings.showLabels !== undefined) {{
                    showLabels = settings.showLabels;
                    document.getElementById('toggleLabelsBtn').textContent = showLabels ? 'üè∑Ô∏è Hide Text' : 'üè∑Ô∏è Show Text';
                }}
                
                // Restore additional state
                if (settings.currentMetric !== undefined && hasMultipleMetrics) {{
                    currentMetric = settings.currentMetric;
                    document.querySelectorAll('.metric-btn').forEach(btn => btn.classList.remove('active'));
                    const metricBtn = document.getElementById('metric-' + currentMetric);
                    if (metricBtn) {{
                        metricBtn.classList.add('active');
                    }}
                }}
                
                if (settings.useClusteredOrder !== undefined && clusteringAvailable) {{
                    useClusteredOrder = settings.useClusteredOrder;
                    const orderBtn = document.getElementById('orderBtn');
                    if (orderBtn) {{
                        orderBtn.textContent = useClusteredOrder ? 'üìä Original Order' : 'üîÄ Clustered Order';
                    }}
                }}
                
                if (settings.clusteringMethod !== undefined && clusteringAvailable) {{
                    currentClusteringMethod = settings.clusteringMethod;
                    const methodSelect = document.getElementById('clusteringMethodSelect');
                    if (methodSelect) {{
                        methodSelect.value = currentClusteringMethod;
                    }}
                    // Update the method selector visibility based on clustering state
                    const methodSection = document.getElementById('clusteringMethodSection');
                    if (methodSection) {{
                        methodSection.style.display = useClusteredOrder ? 'block' : 'none';
                    }}
                }}
                
                if (settings.isTransposed !== undefined) {{
                    isTransposed = settings.isTransposed;
                    const transposeBtn = document.getElementById('transposeBtn');
                    if (transposeBtn) {{
                        transposeBtn.textContent = isTransposed ? 'üîÑ Un-Transpose' : 'üîÑ Transpose';
                    }}
                }}
                
                if (settings.showCellValues !== undefined) {{
                    showCellValues = settings.showCellValues;
                    const cellValuesBtn = document.getElementById('toggleCellValuesBtn');
                    if (cellValuesBtn) {{
                        cellValuesBtn.textContent = showCellValues ? 'üî¢ Hide Values' : 'üî¢ Show Values';
                    }}
                }}
                
                if (settings.cellValueFontSize !== undefined) {{
                    cellValueFontSize = settings.cellValueFontSize;
                    const sizeSlider = document.getElementById('cellValueSizeSlider');
                    const sizeValue = document.getElementById('cellValueSizeValue');
                    if (sizeSlider) sizeSlider.value = cellValueFontSize;
                    if (sizeValue) sizeValue.textContent = cellValueFontSize + 'px';
                }}
                
                if (settings.ignoredValuesInput !== undefined) {{
                    const ignoreInput = document.getElementById('ignoreValuesInput');
                    if (ignoreInput) {{
                        ignoreInput.value = settings.ignoredValuesInput;
                        updateIgnoredValues();
                    }}
                }}
                
                if (settings.contrastThreshold !== undefined) {{
                    contrastThreshold = settings.contrastThreshold;
                    const thresholdSlider = document.getElementById('contrastThresholdSlider');
                    const thresholdValue = document.getElementById('contrastThresholdValue');
                    if (thresholdSlider) thresholdSlider.value = contrastThreshold;
                    if (thresholdValue) thresholdValue.textContent = contrastThreshold.toFixed(4);
                }}
                
                if (settings.reverseContrast !== undefined) {{
                    reverseContrast = settings.reverseContrast;
                }}
                
                if (settings.squareCellsLocked !== undefined) {{
                    squareCellsLocked = settings.squareCellsLocked;
                    const lockBtn = document.getElementById('lockSquareCellsBtn');
                    if (lockBtn) {{
                        lockBtn.textContent = squareCellsLocked ? 'üîì Unlock Square Cells' : 'üîí Lock Square Cells';
                    }}
                }}
                
                // Restore row/column order after custom reordering
                if (settings.currentXLabels && Array.isArray(settings.currentXLabels)) {{
                    currentXLabels = settings.currentXLabels.slice();
                }}
                if (settings.currentYLabels && Array.isArray(settings.currentYLabels)) {{
                    currentYLabels = settings.currentYLabels.slice();
                }}
                
                if (!useAutoRange && settings.zminSlider && settings.zmaxSlider) {{
                    document.getElementById('zminSlider').value = settings.zminSlider;
                    document.getElementById('zmaxSlider').value = settings.zmaxSlider;
                    updateColorbarRange();
                }}
                
                    createHeatmap();
                    if (showStatusMsg) {{
                        showStatus('‚úÖ Settings loaded!', 'success');
                    }}
                }} catch (error) {{
                    console.error('Error loading settings:', error);
                    if (showStatusMsg) {{
                        showStatus('‚ö†Ô∏è Error loading settings, using defaults', 'error');
                    }}
                    createHeatmap();
                }}
            }} else {{
                if (showStatusMsg) {{
                    showStatus('‚ÑπÔ∏è No saved settings found', 'info');
                }}
            }}
        }}
        
        function resetSettings() {{
            currentScale = 'linear';
            currentColorscale = '{default_colorscale}';
            currentFontSize = {fontsize};
            customColorScale = null;
            use3PointScale = false;
            currentWidth = 800;
            currentHeight = 800;
            exportScale = 2;
            showLabels = !isLarge;
            
            document.querySelectorAll('[id^="btn-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-linear').classList.add('active');
            document.getElementById('colorscaleSelect').value = currentColorscale;
            document.getElementById('fontSizeSlider').value = currentFontSize;
            document.getElementById('fontSizeValue').textContent = currentFontSize + 'px';
            
            // Reset plot size
            document.getElementById('widthSlider').value = 800;
            document.getElementById('heightSlider').value = 800;
            document.getElementById('widthValue').textContent = '800px';
            document.getElementById('heightValue').textContent = '800px';
            document.getElementById('exportScaleSlider').value = 2;
            document.getElementById('exportScaleValue').textContent = '2x';
            
            // Reset custom color inputs
            document.getElementById('colorMin').value = '#ffffff';
            document.getElementById('colorMax').value = '#68379c';
            document.getElementById('colorMin3').value = '#0000ff';
            document.getElementById('colorMid3').value = '#ffffff';
            document.getElementById('colorMax3').value = '#ff0000';
            document.getElementById('use3PointScale').checked = false;
            toggle3PointScale();
            
            createHeatmap();
            showStatus('‚úÖ Reset to defaults', 'success');
        }}
        
        function showStatus(message, type) {{
            console.log('showStatus called:', message, type);
            const statusDiv = document.getElementById('settingsStatus');
            console.log('statusDiv found:', statusDiv);
            if (!statusDiv) {{
                console.error('settingsStatus div not found!');
                return;
            }}
            statusDiv.innerHTML = '<div class="status-message status-' + type + '">' + message + '</div>';
            console.log('Status message displayed:', statusDiv.innerHTML);
            setTimeout(() => {{
                statusDiv.innerHTML = '';
            }}, 3000);
        }}
        
        // Try to load saved settings on page load
        window.addEventListener('load', () => {{
            const saved = localStorage.getItem(storageKey);
            if (saved) {{
                loadSettings(false);  // Silent load on initialization
            }} else {{
                createHeatmap();
            }}
        }});
    </script>
</body>
</html>
'''
    
    # Write HTML file
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    if showfig:
        import webbrowser
        webbrowser.open('file://' + os.path.abspath(filename))


